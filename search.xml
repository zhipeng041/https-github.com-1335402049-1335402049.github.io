<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes部署redis-cluster集群</title>
      <link href="2020/09/18/Kubernetes%E9%83%A8%E7%BD%B2redis-cluster%E9%9B%86%E7%BE%A4/"/>
      <url>2020/09/18/Kubernetes%E9%83%A8%E7%BD%B2redis-cluster%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装NFS"><a href="#安装NFS" class="headerlink" title="安装NFS"></a>安装NFS</h2><p>NFS安装可以参照我前面的几篇文章，这边就略过了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/exports</span><br><span class="line">/redis/pv *(async,insecure,no_root_squash,no_subtree_check,rw)</span><br><span class="line"></span><br><span class="line">mkdir -p /redis</span><br><span class="line">systemctl restart rpcbind</span><br><span class="line">systemctl restart nfs</span><br></pre></td></tr></table></figure><h2 id="创建名称空间"><a href="#创建名称空间" class="headerlink" title="创建名称空间"></a>创建名称空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-cluster</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-cluster</span><br></pre></td></tr></table></figure><h2 id="创建configmap"><a href="#创建configmap" class="headerlink" title="创建configmap"></a>创建configmap</h2><p>准备一份redis.conf文件放到/redis目录下，修改redis.conf下面配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">dir /data </span><br><span class="line">pidfile /data/redis_6379.pid</span><br><span class="line">logfile <span class="string">&quot;/data/redis.log&quot;</span></span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes-6379.conf </span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">appendonly yes </span><br><span class="line">protected-mode no </span><br><span class="line">requirepass 123456 </span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create configmap redis-conf --from-file=/redis/redis.conf -n redis-cluster</span><br></pre></td></tr></table></figure><h2 id="创建headless"><a href="#创建headless" class="headerlink" title="创建headless"></a>创建headless</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myredis</span><br><span class="line">  namespace: redis-cluster</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: myredis</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br></pre></td></tr></table></figure><h2 id="创建statefulset"><a href="#创建statefulset" class="headerlink" title="创建statefulset"></a>创建statefulset</h2><p>我这边是使用基于storageclass的nfs，动态提供pv，基于storageclass的nfs-client请查看前面的文章</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-cluster</span><br><span class="line">  namespace: redis-cluster</span><br><span class="line">spec:</span><br><span class="line">  replicas: 6</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myredis</span><br><span class="line">  serviceName: myredis</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">    - metadata:</span><br><span class="line">        name: redis-data</span><br><span class="line">        annotations:</span><br><span class="line">          volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">      spec:</span><br><span class="line">        accessModes: [<span class="string">&quot;ReadWriteOnce&quot;</span>]</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            storage: 1Gi</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myredis</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: redis-conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-conf</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis:5.0.5</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /data/redis.conf</span><br><span class="line">              name: redis-conf</span><br><span class="line">              subPath: redis.conf</span><br><span class="line">            - mountPath: /data</span><br><span class="line">              name: redis-data</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - redis-server</span><br><span class="line">            - /data/redis.conf</span><br></pre></td></tr></table></figure><h2 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h2><p>可以看出来我们的6个redis都起来了，并且每个redis都有自己的存储<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/18/Kubernetes%E9%83%A8%E7%BD%B2redis-cluster%E9%9B%86%E7%BE%A4/a1.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/09/18/Kubernetes%E9%83%A8%E7%BD%B2redis-cluster%E9%9B%86%E7%BE%A4/a2.png"><br>下面我们在创建一个基础centos7的容器，通过redis-cli去构建集群</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it centos7 --image=centos:7 --restart=Never -n redis-cluster /bin/bash</span><br></pre></td></tr></table></figure><p>安装redis</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc vim wget make <span class="built_in">bind</span>-utils</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.5</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>使用redis-cli构建集群</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli  -a 123456 --cluster create --cluster-replicas 1 \</span><br><span class="line">`dig +short redis-cluster-0.myredis.redis-cluster.svc.cluster.local`:6379 \</span><br><span class="line">`dig +short redis-cluster-1.myredis.redis-cluster.svc.cluster.local`:6379 \</span><br><span class="line">`dig +short redis-cluster-2.myredis.redis-cluster.svc.cluster.local`:6379 \</span><br><span class="line">`dig +short redis-cluster-3.myredis.redis-cluster.svc.cluster.local`:6379 \</span><br><span class="line">`dig +short redis-cluster-4.myredis.redis-cluster.svc.cluster.local`:6379 \</span><br><span class="line">`dig +short redis-cluster-5.myredis.redis-cluster.svc.cluster.local`:6379 </span><br></pre></td></tr></table></figure><p>如上，命令 dig +short redis-cluster-0.myredis.redis-cluster.svc.cluster.local 用于将pod的域名转化为ip<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/18/Kubernetes%E9%83%A8%E7%BD%B2redis-cluster%E9%9B%86%E7%BE%A4/a3.png"><br>到此为止，我们的redis cluster集群已经创建完毕</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -c -a 123456</span><br><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:895</span><br><span class="line">cluster_stats_messages_pong_sent:845</span><br><span class="line">cluster_stats_messages_sent:1740</span><br><span class="line">cluster_stats_messages_ping_received:840</span><br><span class="line">cluster_stats_messages_pong_received:895</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:1740</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">b1d33e5a9d30c2c6e698e67eb0bee8a6cf81713b 10.244.2.72:6379@16379 myself,master - 0 1600394683000 1 connected 0-5460</span><br><span class="line">eac16b517d15281bbd9519ae7e30225734fba776 10.244.1.108:6379@16379 master - 0 1600394684000 2 connected 5461-10922</span><br><span class="line">c17c159a5eacc2ff856b7237e100f1ae6fd62f83 10.244.2.74:6379@16379 slave eac16b517d15281bbd9519ae7e30225734fba776 0 1600394685000 5 connected</span><br><span class="line">72827e742cb17b844794b78ef1874551ee14358d 10.244.2.73:6379@16379 master - 0 1600394685791 3 connected 10923-16383</span><br><span class="line">353c8a0f85491bfb3f7347281846ae99bd072b2b 10.244.1.110:6379@16379 slave 72827e742cb17b844794b78ef1874551ee14358d 0 1600394684000 6 connected</span><br><span class="line">e15013580f59ce4f0f197ffdc69b6c86ceea5185 10.244.1.109:6379@16379 slave b1d33e5a9d30c2c6e698e67eb0bee8a6cf81713b 0 1600394684000 4 connected</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes部署Prometheus</title>
      <link href="2020/09/16/Kubernetes%E9%83%A8%E7%BD%B2Prometheus/"/>
      <url>2020/09/16/Kubernetes%E9%83%A8%E7%BD%B2Prometheus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="获取prometheus"><a href="#获取prometheus" class="headerlink" title="获取prometheus"></a>获取prometheus</h2><p>注意下载的prometheus版本是否支持自己的kubernetes版本<br>下载地址：<a href="https://github.com/prometheus-operator/kube-prometheus/archive/v0.2.0.zip">https://github.com/prometheus-operator/kube-prometheus/archive/v0.2.0.zip</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir prometheus</span><br><span class="line"><span class="built_in">cd</span> prometheus</span><br></pre></td></tr></table></figure><h2 id="Prometheus部署"><a href="#Prometheus部署" class="headerlink" title="Prometheus部署"></a>Prometheus部署</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /k8s/prometheus/kube-prometheus-0.2.0/manifests</span><br></pre></td></tr></table></figure><p>vim grafana-service.yaml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: grafana</span><br><span class="line">  name: grafana</span><br><span class="line">  namespace: monitoring</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 3000</span><br><span class="line">    nodePort: 30100</span><br><span class="line">    targetPort: http</span><br><span class="line">  selector:</span><br><span class="line">    app: grafana</span><br></pre></td></tr></table></figure><p>vim prometheus-service.yaml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    prometheus: k8s</span><br><span class="line">  name: prometheus-k8s</span><br><span class="line">  namespace: monitoring</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: web</span><br><span class="line">    port: 9090</span><br><span class="line">    nodePort: 30200</span><br><span class="line">    targetPort: web</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus</span><br><span class="line">    prometheus: k8s</span><br><span class="line">  sessionAffinity: ClientIP</span><br></pre></td></tr></table></figure><p>vim alertmanager-service.yaml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    alertmanager: main</span><br><span class="line">  name: alertmanager-main</span><br><span class="line">  namespace: monitoring</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: web</span><br><span class="line">    port: 9093</span><br><span class="line">    nodePort: 30300</span><br><span class="line">    targetPort: web</span><br><span class="line">  selector:</span><br><span class="line">    alertmanager: main</span><br><span class="line">    app: alertmanager</span><br><span class="line">  sessionAffinity: ClientIP</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f manifests/</span><br></pre></td></tr></table></figure><h2 id="访问prometheus"><a href="#访问prometheus" class="headerlink" title="访问prometheus"></a>访问prometheus</h2><p>prometheus：<a href="http://ip:30200/">http://ip:30200</a><br>grafana：<a href="http://ip:30100/">http://ip:30100</a><br><img src= "/img/loading.gif" data-lazy-src="/2020/09/16/Kubernetes%E9%83%A8%E7%BD%B2Prometheus/a1.png"><br>导入模板<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/16/Kubernetes%E9%83%A8%E7%BD%B2Prometheus/a2.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/09/16/Kubernetes%E9%83%A8%E7%BD%B2Prometheus/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/09/16/Kubernetes%E9%83%A8%E7%BD%B2Prometheus/a4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes中使用NFS的StorageClass</title>
      <link href="2020/09/16/Kubernetes%E4%B8%AD%E4%BD%BF%E7%94%A8NFS%E7%9A%84StorageClass/"/>
      <url>2020/09/16/Kubernetes%E4%B8%AD%E4%BD%BF%E7%94%A8NFS%E7%9A%84StorageClass/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装NFS"><a href="#安装NFS" class="headerlink" title="安装NFS"></a>安装NFS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nfs</span></span><br><span class="line">yum -y install nfs-utils rpcbind</span><br><span class="line"><span class="comment">#创建nfs共享目录及设置权限</span></span><br><span class="line">mkdir /nfs/renren -p</span><br><span class="line">chmod 755 /nfs/renren -R</span><br><span class="line"><span class="comment">#配置nfs</span></span><br><span class="line">cat /etc/exports</span><br><span class="line">/nfs/renren *(async,insecure,no_root_squash,no_subtree_check,rw)</span><br></pre></td></tr></table></figure><h2 id="启动NFS"><a href="#启动NFS" class="headerlink" title="启动NFS"></a>启动NFS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl status rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line">systemctl status nfs</span><br></pre></td></tr></table></figure><p>客户端在使用NFS时，需要安装NFS</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在客户端上安装启动nfs</span></span><br><span class="line">yum -y install nfs-utils rpcbind</span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"><span class="comment">#查看nfs共享</span></span><br><span class="line">showmount -e k8s-master</span><br></pre></td></tr></table></figure><h2 id="创建基于NFS的StorageClass"><a href="#创建基于NFS的StorageClass" class="headerlink" title="创建基于NFS的StorageClass"></a>创建基于NFS的StorageClass</h2><p><a href="https://github.com/kubernetes-retired/external-storage.git">https://github.com/kubernetes-retired/external-storage.git</a><br>主要部署下面这些资源清单，只有deployment.yaml需要修改nfs相关配置<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/16/Kubernetes%E4%B8%AD%E4%BD%BF%E7%94%A8NFS%E7%9A%84StorageClass/a1.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署deployment.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">  labels:</span><br><span class="line">    app: nfs-client-provisioner</span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-client-provisioner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-client-provisioner</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: nfs-client-provisioner</span><br><span class="line">      containers:</span><br><span class="line">        - name: nfs-client-provisioner</span><br><span class="line">          image: quay.io/external_storage/nfs-client-provisioner:latest</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: nfs-client-root</span><br><span class="line">              mountPath: /persistentvolumes</span><br><span class="line">          env:</span><br><span class="line">            - name: PROVISIONER_NAME</span><br><span class="line">              value: fuseim.pri/ifs</span><br><span class="line">            - name: NFS_SERVER</span><br><span class="line">              value: 192.168.126.130  <span class="comment">#修改nfs服务器地址</span></span><br><span class="line">            - name: NFS_PATH</span><br><span class="line">              value: /nfs/renren       <span class="comment">#nfs目录</span></span><br><span class="line">      volumes:</span><br><span class="line">        - name: nfs-client-root</span><br><span class="line">          nfs:</span><br><span class="line">            server: 192.168.126.130  <span class="comment">#修改nfs服务器地址</span></span><br><span class="line">            path: /nfs/renren        <span class="comment">#nfs目录</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f deployment.yaml</span><br><span class="line"><span class="comment">#部署rbac</span></span><br><span class="line">kubectl apply -f rbac.yaml</span><br><span class="line"><span class="comment">#部署storageclass</span></span><br><span class="line">kubectl apply -f class.yaml</span><br><span class="line"><span class="comment">#查看创建的资源</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><h2 id="在pvc中调用storageclass动态提供pv"><a href="#在pvc中调用storageclass动态提供pv" class="headerlink" title="在pvc中调用storageclass动态提供pv"></a>在pvc中调用storageclass动态提供pv</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-mysql</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line"></span><br><span class="line">kubectl apply -f pvc-mysql.yaml</span><br></pre></td></tr></table></figure><h2 id="在pod控制器中使用storageclass"><a href="#在pod控制器中使用storageclass" class="headerlink" title="在pod控制器中使用storageclass"></a>在pod控制器中使用storageclass</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-mysql</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: statefulset-mysql</span><br><span class="line">  serviceName: headless-mysql</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">    - metadata:</span><br><span class="line">        name: pvc-mysql</span><br><span class="line">        annotations:</span><br><span class="line">          volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">      spec:</span><br><span class="line">        accessModes: [<span class="string">&quot;ReadWriteOnce&quot;</span>]</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            storage: 1Gi</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: statefulset-mysql</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: mysql-conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: mysql-configmap</span><br><span class="line">            items:</span><br><span class="line">              - key: mysql.cnf</span><br><span class="line">                path: mysql.cnf</span><br><span class="line">              - key: mysqld.cnf</span><br><span class="line">                path: mysqld.cnf</span><br><span class="line">              - key: mysqldump.cnf</span><br><span class="line">                path: mysqldump.cnf</span><br><span class="line">              - key: docker.cnf</span><br><span class="line">                path: docker.cnf</span><br><span class="line">      containers:</span><br><span class="line">        - name: mysql</span><br><span class="line">          image: mysql:5.6</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 3306</span><br><span class="line">          env:</span><br><span class="line">            - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">              valueFrom:</span><br><span class="line">                secretKeyRef:</span><br><span class="line">                  name: secret-mysql</span><br><span class="line">                  key: password</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /var/lib/mysql</span><br><span class="line">              name: mysql-data</span><br><span class="line">            - mountPath: /etc/mysql/conf.d/mysql.cnf</span><br><span class="line">              subPath: mysql.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">            - mountPath: /etc/mysql/conf.d/mysqldump.cnf</span><br><span class="line">              subPath: mysqldump.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">            - mountPath: /etc/mysql/conf.d/docker.cnf</span><br><span class="line">              subPath: docker.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">            - mountPath: /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">              subPath: mysqld.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">              </span><br><span class="line">kubectl apply -f statefulset-mysql.yaml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes部署renren-fast开源项目</title>
      <link href="2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>renren-fast是一个开源的前后端分离项目，前端使用vue框架，后端采用springboot。<br>在刚接触完Kubernetes后，使用Kubernetes部署renren-fast项目练练手。</p><h2 id="获取renren-fast"><a href="#获取renren-fast" class="headerlink" title="获取renren-fast"></a>获取renren-fast</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取后端</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.oschina.net/renrenio/renren-fast.git</span><br><span class="line"><span class="comment">#获取前端</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/daxiongYang/renren-fast-vue.git</span><br></pre></td></tr></table></figure><h2 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h2><h3 id="修改mysql配置"><a href="#修改mysql配置" class="headerlink" title="修改mysql配置"></a>修改mysql配置</h3><p>修改application-dev.yml的mysql配置项，我主要修改了以下几项,此处headless-mysql是我的无头服务的名称，renren-fast是库名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url: jdbc:mysql://headless-mysql:3306/renren-fast?useUnicode=<span class="literal">true</span>&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure><h3 id="修改redis配置"><a href="#修改redis配置" class="headerlink" title="修改redis配置"></a>修改redis配置</h3><p>修改application.yml的redis配置项，我主要修改了以下几处，此处headless-redis是我的无头服务名称，password是客户端连接密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">host: headless-redis</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><h3 id="部署nfs的storageclass"><a href="#部署nfs的storageclass" class="headerlink" title="部署nfs的storageclass"></a>部署nfs的storageclass</h3><p>（1）安装nfs</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nfs</span></span><br><span class="line">yum -y install nfs-utils rpcbind</span><br><span class="line"><span class="comment">#创建nfs共享目录及设置权限</span></span><br><span class="line">mkdir /nfs/renren -p</span><br><span class="line">chmod 755 /nfs/renren -R</span><br><span class="line"><span class="comment">#配置nfs</span></span><br><span class="line">cat /etc/exports</span><br><span class="line">/nfs/renren *(async,insecure,no_root_squash,no_subtree_check,rw)</span><br></pre></td></tr></table></figure><p>（2）启动nfs</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl status rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line">systemctl status nfs</span><br></pre></td></tr></table></figure><p>（3）客户端配置<br>客户端在使用nfs时，需要安装nfs</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在客户端上安装启动nfs</span></span><br><span class="line">yum -y install nfs-utils rpcbind</span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"><span class="comment">#查看nfs共享</span></span><br><span class="line">showmount -e k8s-master</span><br></pre></td></tr></table></figure><p>（4）创建基于nfs的storageclass</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-retired/external-storage.git</span><br></pre></td></tr></table></figure><p>主要部署下面这些资源清单，只有deployment.yaml需要修改nfs相关配置<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a1.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署deployment.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">  labels:</span><br><span class="line">    app: nfs-client-provisioner</span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-client-provisioner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-client-provisioner</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: nfs-client-provisioner</span><br><span class="line">      containers:</span><br><span class="line">        - name: nfs-client-provisioner</span><br><span class="line">          image: quay.io/external_storage/nfs-client-provisioner:latest</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: nfs-client-root</span><br><span class="line">              mountPath: /persistentvolumes</span><br><span class="line">          env:</span><br><span class="line">            - name: PROVISIONER_NAME</span><br><span class="line">              value: fuseim.pri/ifs</span><br><span class="line">            - name: NFS_SERVER</span><br><span class="line">              value: 192.168.126.130  <span class="comment">#修改nfs服务器地址</span></span><br><span class="line">            - name: NFS_PATH</span><br><span class="line">              value: /nfs/renren       <span class="comment">#nfs目录</span></span><br><span class="line">      volumes:</span><br><span class="line">        - name: nfs-client-root</span><br><span class="line">          nfs:</span><br><span class="line">            server: 192.168.126.130  <span class="comment">#修改nfs服务器地址</span></span><br><span class="line">            path: /nfs/renren        <span class="comment">#nfs目录</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f deployment.yaml</span><br><span class="line"><span class="comment">#部署rbac</span></span><br><span class="line">kubectl apply -f rbac.yaml</span><br><span class="line"><span class="comment">#部署storageclass</span></span><br><span class="line">kubectl apply -f class.yaml</span><br><span class="line"><span class="comment">#查看创建的资源</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><h3 id="部署mysql"><a href="#部署mysql" class="headerlink" title="部署mysql"></a>部署mysql</h3><p>需要提前创建好namespace，我创建的是renren-fast<br>（1）创建pvc</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-mysql</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line"></span><br><span class="line">kubectl apply -f pvc-mysql.yaml</span><br></pre></td></tr></table></figure><p>（2）创建secret</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-mysql</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">data:</span><br><span class="line">  password: dGFuZzE2MTE=</span><br><span class="line">stringData:</span><br><span class="line">  username: root</span><br><span class="line"></span><br><span class="line">kubectl apply -f secret-mysql.yaml</span><br></pre></td></tr></table></figure><p>（3）创建configmap</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /nfs/renren/conf_mysql</span><br><span class="line">kubectl create configmap mysql-configmap --from-file=/nfs/renren/conf_mysql -n renren-fast</span><br></pre></td></tr></table></figure><p>需要提前将mysql容器中的配置文件准备好<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a2.png"><br>（4）创建headless</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: headless-mysql</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: statefulset-mysql</span><br><span class="line">  ports:</span><br><span class="line">    - port: 3306</span><br><span class="line">    </span><br><span class="line">kubectl apply -f headless-mysql.yaml</span><br></pre></td></tr></table></figure><p>（5）创建statefulset</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-mysql</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: statefulset-mysql</span><br><span class="line">  serviceName: headless-mysql</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: statefulset-mysql</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: mysql-data</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: pvc-mysql</span><br><span class="line">        - name: mysql-conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: mysql-configmap</span><br><span class="line">            items:</span><br><span class="line">              - key: mysql.cnf</span><br><span class="line">                path: mysql.cnf</span><br><span class="line">              - key: mysqld.cnf</span><br><span class="line">                path: mysqld.cnf</span><br><span class="line">              - key: mysqldump.cnf</span><br><span class="line">                path: mysqldump.cnf</span><br><span class="line">              - key: docker.cnf</span><br><span class="line">                path: docker.cnf</span><br><span class="line">      containers:</span><br><span class="line">        - name: mysql</span><br><span class="line">          image: mysql:5.6</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 3306</span><br><span class="line">          env:</span><br><span class="line">            - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">              valueFrom:</span><br><span class="line">                secretKeyRef:</span><br><span class="line">                  name: secret-mysql</span><br><span class="line">                  key: password</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /var/lib/mysql</span><br><span class="line">              name: mysql-data</span><br><span class="line">            - mountPath: /etc/mysql/conf.d/mysql.cnf</span><br><span class="line">              subPath: mysql.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">            - mountPath: /etc/mysql/conf.d/mysqldump.cnf</span><br><span class="line">              subPath: mysqldump.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">            - mountPath: /etc/mysql/conf.d/docker.cnf</span><br><span class="line">              subPath: docker.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">            - mountPath: /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">              subPath: mysqld.cnf</span><br><span class="line">              name: mysql-conf</span><br><span class="line">              </span><br><span class="line">kubectl apply -f statefulset-mysql.yaml</span><br></pre></td></tr></table></figure><p>部署完成mysql后，可以登录进去，将mysql.sql导入进去，库名是renren-fast，mysql.sql文件在renren-fast\db里面</p><h3 id="部署redis"><a href="#部署redis" class="headerlink" title="部署redis"></a>部署redis</h3><p>（1）创建pvc</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-redis</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 2Gi</span><br><span class="line">      </span><br><span class="line">kubectl apply -f pvc-redis.yaml</span><br></pre></td></tr></table></figure><p>（2）创建configmap</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /nfs/renren/conf_redis</span><br><span class="line">kubectl create configmap redis-configmap --from-file=redis.conf -n renren-fast</span><br></pre></td></tr></table></figure><p>需要提前将redis.conf准备好，相关pid、log、rdb、aof相关的文件我都放到了容器的/data目录下，redis密码记得改成与项目配置文件的一致<br>（3）创建headless</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: headless-redis</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: statefulset-redis</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br><span class="line">    </span><br><span class="line">kubectl apply -f headless-redis.yaml</span><br></pre></td></tr></table></figure><p>（4）创建statefulset</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-redis</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: statefulset-redis</span><br><span class="line">  serviceName: headless-redis</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: statefulset-redis</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: redis-conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-configmap</span><br><span class="line">        - name: redis-data</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: pvc-redis</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis:5.0.5</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /data/redis.conf</span><br><span class="line">              name: redis-conf</span><br><span class="line">              subPath: redis.conf</span><br><span class="line">            - mountPath: /data</span><br><span class="line">              name: redis-data</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - redis-server</span><br><span class="line">            - /data/redis.conf</span><br><span class="line">              </span><br><span class="line">kubectl apply -f statefulset-redis.yaml</span><br></pre></td></tr></table></figure><h3 id="部署java环境"><a href="#部署java环境" class="headerlink" title="部署java环境"></a>部署java环境</h3><p>（1）我这边制作了一个简单的dockerfile，将打包的renren-fast.jar与dockerfile放在同级目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">RUN mkdir -p /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY renren-fast.jar .</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD java -jar renren-fast.jar &gt;&gt; renren.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#build</span></span><br><span class="line">docker build -t my-java-app .</span><br></pre></td></tr></table></figure><p>（2）创建pvc<br>需要将打包好的renren-fast.jar放入这个pvc生成的目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-java</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br><span class="line">      </span><br><span class="line">kubectl apply -f pvc-java.yaml</span><br></pre></td></tr></table></figure><p>（3）创建deployment-java</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: deployment-java</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: myapp-jar</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: pvc-java</span><br><span class="line">      containers:</span><br><span class="line">        - name: java</span><br><span class="line">          image: my-java-app</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 8080</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /app</span><br><span class="line">              name: myapp-jar</span><br><span class="line">        </span><br><span class="line">kubectl apply -f deployment-java.yaml</span><br></pre></td></tr></table></figure><p>（4）部署service-java</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-java</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: myapp</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">    </span><br><span class="line">kubectl apply -f service-java.yaml</span><br><span class="line"><span class="comment">#获取svc,拿到nodeport暴露的端口</span></span><br><span class="line">kubectl get svc -n renren-fast</span><br></pre></td></tr></table></figure><h3 id="测试后端部署是否成功"><a href="#测试后端部署是否成功" class="headerlink" title="测试后端部署是否成功"></a>测试后端部署是否成功</h3><p>在浏览器输入 宿主机ip:nodeport/renren-fast/swagger/index.html,例如<a href="http://192.168.126.130:31375/renren-fast/swagger/index.html">http://192.168.126.130:31375/renren-fast/swagger/index.html</a><br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a3.png"></p><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><p>修改renren-fast-vue\static\config\index-prod.js，修改下面配置，将ip、port改成对应的即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// api接口请求地址</span><br><span class="line">window.SITE_CONFIG[<span class="string">&#x27;baseUrl&#x27;</span>] = <span class="string">&#x27;http://192.168.126.130:31375/renren-fast&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装依赖，可能由于网络原因，部份依赖安装失败，可以尝试安装cnpm，然后使用cnpm安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">#打包</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包成功后会生成一个dist目录<br>（1）创建pvc<br>需要将打包出来的dist目录放入这个pvc生成的目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-nginx</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">  annotations:</span><br><span class="line">    volume.beta.kubernetes.io/storage-class: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br><span class="line">      </span><br><span class="line">kubectl apply -f pvc-nginx.yaml</span><br></pre></td></tr></table></figure><p>（2）创建configmap</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /nfs/renren/conf_nginx</span><br><span class="line">kubectl create configmap nginx-configmap --from-file=/nfs/renren/conf_nginx -n renren-fast</span><br></pre></td></tr></table></figure><p>需要提前准备nginx配置文件，我这边就是要nginx.conf和default.conf，修改default.conf<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a4.png"><br>（3）deployment-nginx</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: deployment-nginx</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: deployment-nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: deployment-nginx</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: nginx-conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: nginx-configmap</span><br><span class="line">            items:</span><br><span class="line">              - key: nginx.conf</span><br><span class="line">                path: nginx.conf</span><br><span class="line">              - key: default.conf</span><br><span class="line">                path: default.conf</span><br><span class="line">        - name: nginx-data</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: pvc-nginx</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /etc/nginx/conf.d/default.conf</span><br><span class="line">              name: nginx-conf</span><br><span class="line">              subPath: default.conf</span><br><span class="line">            - mountPath: /etc/nginx/nginx.conf</span><br><span class="line">              name: nginx-conf</span><br><span class="line">              subPath: nginx.conf</span><br><span class="line">            - mountPath: /usr/share/nginx/html</span><br><span class="line">              name: nginx-data</span><br><span class="line">              </span><br><span class="line">kubectl apply -f deployment-nginx.yaml</span><br></pre></td></tr></table></figure><p>（4）创建service-nginx</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-nginx</span><br><span class="line">  namespace: renren-fast</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: deployment-nginx</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">    </span><br><span class="line">kubectl apply -f service-nginx.yaml</span><br><span class="line"><span class="comment">#获取svc,拿到nodeport暴露的端口</span></span><br><span class="line">kubectl get svc -n renren-fast</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>到此整个项目都部署完成了，浏览器输入 ip:nodeport 即可访问<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a5.png"><br>用户名 admin 密码 admin<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/Kubernetes%E9%83%A8%E7%BD%B2renren-fast%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a6.png"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kuboard部署</title>
      <link href="2020/09/15/Kuboard%E9%83%A8%E7%BD%B2/"/>
      <url>2020/09/15/Kuboard%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Kuboard是一款免费的Kubernetes图形化管理工具</p><h2 id="安装Kuboard"><a href="#安装Kuboard" class="headerlink" title="安装Kuboard"></a>安装Kuboard</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://kuboard.cn/install-script/kuboard.yaml</span><br><span class="line">wget https://addons.kuboard.cn/metrics-server/0.3.6/metrics-server.yaml</span><br><span class="line">kubectl apply -f kuboard.yaml</span><br><span class="line">kubectl apply -f metrics-server.yaml</span><br></pre></td></tr></table></figure><h2 id="获取Token"><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>) -o go-template=<span class="string">&#x27;&#123;&#123;.data.token&#125;&#125;&#x27;</span> | base64 -d)  </span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>通过任意节点 IP:32567 即可访问</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JIRA部署</title>
      <link href="2020/09/15/JIRA%E9%83%A8%E7%BD%B2/"/>
      <url>2020/09/15/JIRA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>JIRA广泛应用于任务跟踪、需求分析、流程审批、项目跟踪和敏捷管理领域。</p><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk-*</span><br></pre></td></tr></table></figure><h2 id="安装mariadb"><a href="#安装mariadb" class="headerlink" title="安装mariadb"></a>安装mariadb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum  -y install mariadb-server</span><br><span class="line">service mariadb start</span><br></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">create database jira default character <span class="built_in">set</span> utf8 collate utf8_bin;</span><br><span class="line">use mysql;</span><br><span class="line">UPDATE mysql.user SET password = PASSWORD(<span class="string">&#x27;123456&#x27;</span>) WHERE user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">update user <span class="built_in">set</span> host=<span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span>  user=<span class="string">&#x27;root&#x27;</span> and host=<span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h2 id="下载jira和破解jar"><a href="#下载jira和破解jar" class="headerlink" title="下载jira和破解jar"></a>下载jira和破解jar</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget  https://downloads.atlassian.com/software/jira/downloads/atlassian-jira-software-7.3.7-x64.bin</span><br><span class="line">链接：https://pan.baidu.com/s/1CLmY1B3MzBtPQiQqQvXBIA </span><br><span class="line">提取码：kmp1</span><br></pre></td></tr></table></figure><h2 id="安装jira"><a href="#安装jira" class="headerlink" title="安装jira"></a>安装jira</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 755 /opt/atlassian-jira-software-7.3.7-x64.bin</span><br><span class="line">./atlassian-jira-software-7.3.7-x64.bin</span><br></pre></td></tr></table></figure><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>将atlassian-extras-3.2.jar破解文件复制到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下<br>将破解包里面的mysql-connector-java-5.1.46-bin.jar文件复制到/opt/atlassian/jira/lib/目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重新启动jira</span></span><br><span class="line"><span class="built_in">cd</span> /opt/atlassian/jira/bin</span><br><span class="line">sh shutdown.sh</span><br><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>通过 ip:8080 访问web界面，选择l’ll set it up myself 配置数据源<br>生成许可证，需要注册<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/JIRA%E9%83%A8%E7%BD%B2/a1.png"><br>拿到许可证复制进去即可<br>这个表示即破解成功<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/15/JIRA%E9%83%A8%E7%BD%B2/a2.png"></p>]]></content>
      
      
      <categories>
          
          <category> JIRA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JIRA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes部署有状态服务-Redis</title>
      <link href="2020/09/10/Kubernetes%E9%83%A8%E7%BD%B2%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1-Redis/"/>
      <url>2020/09/10/Kubernetes%E9%83%A8%E7%BD%B2%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1-Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装nfs"><a href="#安装nfs" class="headerlink" title="安装nfs"></a>安装nfs</h2><p>我这边就选择k8s-master作为nfs存储了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="comment">#在 /etc/exports 添加</span></span><br><span class="line">/nfs/volumes *(async,insecure,no_root_squash,no_subtree_check,rw)</span><br><span class="line"><span class="comment"># 创建nfs挂载目录</span></span><br><span class="line">mkdir -p /nfs/volumes</span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl start rpcbind &amp; systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl start nfs-server &amp; systemctl <span class="built_in">enable</span> nfs-server</span><br><span class="line"><span class="comment">#查看nfs状态</span></span><br><span class="line">showmount -e k8s-master</span><br><span class="line"><span class="comment">#创建存储</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/volumes</span><br><span class="line">mkdir data_redis</span><br><span class="line">mkdir conf_redis  <span class="comment">#需要准备一份redis配置文件，配置文件里面相关的存储数据、pid、log等我是放在容器的/data下的</span></span><br></pre></td></tr></table></figure><h2 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-redis</span><br><span class="line">spec:</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 2Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/volumes/data_redis</span><br><span class="line">    server: k8s-master</span><br></pre></td></tr></table></figure><p>创建PV</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pv-redis.yaml</span><br></pre></td></tr></table></figure><h2 id="创建pvc"><a href="#创建pvc" class="headerlink" title="创建pvc"></a>创建pvc</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-redis</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 2Gi</span><br></pre></td></tr></table></figure><p>创建pvc</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pvc-redis.yaml</span><br></pre></td></tr></table></figure><h2 id="创建configmap"><a href="#创建configmap" class="headerlink" title="创建configmap"></a>创建configmap</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create configmap redis-configmap --from-file=/nfs/volumes/conf_redis/redis.conf</span><br></pre></td></tr></table></figure><h2 id="创建headless"><a href="#创建headless" class="headerlink" title="创建headless"></a>创建headless</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: headless-redis</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: statefulset-redis</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br></pre></td></tr></table></figure><p>创建headless</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f headless-redis.yaml</span><br></pre></td></tr></table></figure><h2 id="创建statefulset"><a href="#创建statefulset" class="headerlink" title="创建statefulset"></a>创建statefulset</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-redis</span><br><span class="line">spec:</span><br><span class="line">  serviceName: headless-redis</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: statefulset-redis</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: statefulset-redis</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: redis-conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-configmap</span><br><span class="line">        - name: data-redis</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: pvc-redis</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis:5.0.5</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /data/redis.conf</span><br><span class="line">              name: redis-conf</span><br><span class="line">              subPath: redis.conf</span><br><span class="line">            - mountPath: /data</span><br><span class="line">              name: data-redis</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - redis-server</span><br><span class="line">            - /data/redis.conf</span><br></pre></td></tr></table></figure><p>创建headless</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f statefulset-redis.yaml</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在部署statefulset的时候出现下面这个问题，pod的状态一会completed，一会CrashLoopBackOff<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/10/Kubernetes%E9%83%A8%E7%BD%B2%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1-Redis/a1.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/09/10/Kubernetes%E9%83%A8%E7%BD%B2%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1-Redis/a2.png"><br>解决：花了很多时间去研究，describe和log指令也没有提供有用的报错信息，最后发现是配置文件的daemonize配置项的问题，因为redis.conf是我之前改过的，daemonize默认是no，我改成了yes会出现这种问题，所以daemonize保持默认的no即可。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins启动tomcat后，随着job结束，tomcat进程也结束</title>
      <link href="2020/09/10/Jenkins%E5%90%AF%E5%8A%A8tomcat%E5%90%8E%EF%BC%8C%E9%9A%8F%E7%9D%80job%E7%BB%93%E6%9D%9F%EF%BC%8Ctomcat%E8%BF%9B%E7%A8%8B%E4%B9%9F%E7%BB%93%E6%9D%9F/"/>
      <url>2020/09/10/Jenkins%E5%90%AF%E5%8A%A8tomcat%E5%90%8E%EF%BC%8C%E9%9A%8F%E7%9D%80job%E7%BB%93%E6%9D%9F%EF%BC%8Ctomcat%E8%BF%9B%E7%A8%8B%E4%B9%9F%E7%BB%93%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在使用jenkins构建项目时，执行shell脚本启动tomcat，但是随着jenkins job的结束，tomcat进程也会被杀死</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在shell脚本最上面加上 export BUILD_ID=DONTKILLME<br>如果你是pipeline job，那么请使用 JENKINS_NODE_COOKIE 代替 BUILD_ID</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/09/10/Jenkins%E5%90%AF%E5%8A%A8tomcat%E5%90%8E%EF%BC%8C%E9%9A%8F%E7%9D%80job%E7%BB%93%E6%9D%9F%EF%BC%8Ctomcat%E8%BF%9B%E7%A8%8B%E4%B9%9F%E7%BB%93%E6%9D%9F/a1.png"><br>在使用jenkins构建另一个项目，在日志中找到这个报错，最后发现是由于我使用nohup启动项目大概需要40秒，但是启动项目时最后一个stage，可能在项目还没启动成功，jenkins已经结束了这次构建，最后我在shell脚本末尾加了sleep 60，测试了确实时这个原因导致的报错，而且也可以解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix告警后远程执行shell命令</title>
      <link href="2020/09/10/Zabbix%E5%91%8A%E8%AD%A6%E5%90%8E%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/"/>
      <url>2020/09/10/Zabbix%E5%91%8A%E8%AD%A6%E5%90%8E%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有的时候我们的服务意外宕掉，需要在报警后自动尝试重新启动，zabbix可以在告警后执行shell命令实现重新启动服务</p><h2 id="增加远程执行命令配置"><a href="#增加远程执行命令配置" class="headerlink" title="增加远程执行命令配置"></a>增加远程执行命令配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim /etc/zabbix/zabbix_agentd.conf</span></span><br><span class="line">EnableRemoteCommands=1    <span class="comment">#允许远程执行命令</span></span><br><span class="line">LogRemoteCommands=1      <span class="comment">#开启远程执行命令的日志</span></span><br></pre></td></tr></table></figure><h2 id="配置zabbix用户sudo权限"><a href="#配置zabbix用户sudo权限" class="headerlink" title="配置zabbix用户sudo权限"></a>配置zabbix用户sudo权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/09/10/Zabbix%E5%91%8A%E8%AD%A6%E5%90%8E%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/a1.png"></p><h2 id="zabbix动作配置"><a href="#zabbix动作配置" class="headerlink" title="zabbix动作配置"></a>zabbix动作配置</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/09/10/Zabbix%E5%91%8A%E8%AD%A6%E5%90%8E%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/a2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Zabbix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx做反向代理时浏览器加载大文件失败ERR_CONTENT_LENGTH_MISMATCH</title>
      <link href="2020/09/10/Nginx%E5%81%9A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5ERR-CONTENT-LENGTH-MISMATCH/"/>
      <url>2020/09/10/Nginx%E5%81%9A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5ERR-CONTENT-LENGTH-MISMATCH/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Nginx做后端代理，后端是tomcat，浏览器请求项目时加载大文件失败<br>查看nginx日志<br><img src= "/img/loading.gif" data-lazy-src="/2020/09/10/Nginx%E5%81%9A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5ERR-CONTENT-LENGTH-MISMATCH/a1.png"><br>日志中会提示具体的大文件</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>ps -ef | grep nginx 查看 work process 的nginx进程<br>nginx会对大文件进行缓存，存放在proxy_temp目录下，可能由于权限问题，导致无法访问<br>在配置文件中加入 user root; 重启nginx即可。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 运行时出现Invalid character found in the HTTP protocol</title>
      <link href="2020/08/22/Tomcat%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0Invalid-character-found-in-the-HTTP-protocol/"/>
      <url>2020/08/22/Tomcat%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0Invalid-character-found-in-the-HTTP-protocol/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这段时间tomcat日志中出现Invalid character found in the HTTP protocol,还有Invalid character found in method name.HTTP method names must be tokens<br>下面是具体报错信息，试了很久，找到了原因</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">       java.lang.IllegalArgumentException: Invalid character found <span class="keyword">in</span> the HTTP protocol [HTTP/1.10x0aHost:]</span><br><span class="line">               at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:560)</span><br><span class="line">               at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:260)</span><br><span class="line">               at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)</span><br><span class="line">               at org.apache.coyote.AbstractProtocol<span class="variable">$ConnectionHandler</span>.process(AbstractProtocol.java:868)</span><br><span class="line">               at org.apache.tomcat.util.net.NioEndpoint<span class="variable">$SocketProcessor</span>.doRun(NioEndpoint.java:1590)</span><br><span class="line">               at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">               at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">               at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class="line">               at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61)</span><br><span class="line">               at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">       java.lang.IllegalArgumentException: Invalid character found <span class="keyword">in</span> method name. HTTP method names must be tokens</span><br><span class="line">               at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:418)</span><br><span class="line">               at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:260)</span><br><span class="line">               at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)</span><br><span class="line">               at org.apache.coyote.AbstractProtocol<span class="variable">$ConnectionHandler</span>.process(AbstractProtocol.java:868)</span><br><span class="line">               at org.apache.tomcat.util.net.NioEndpoint<span class="variable">$SocketProcessor</span>.doRun(NioEndpoint.java:1590)</span><br><span class="line">               at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">               at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">               at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class="line">               at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61)</span><br><span class="line">               at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在网上查了很久，找到很多解决方法，下面我们来看<br>（1）在server.xml的Connector添加maxHttpHeaderSize=”8192”<br>这个参数是设置请求头长度的，不过貌似没有解决问题<br>（2）删除server.xml的监听<br>看到stackOverflow中说删除server.xml下面的监听，不过我试过了，并没有解决，我的日志中还是会出此类错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Listener className=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> SSLEngine=<span class="string">&quot;on&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>（3）涉及非法字符的原因<br>tomcat在7.0.73, 8.0.39, 8.5.7 版本后，对http解析时做了严格限制。RFC3986文档规定，请求url中只允许包含字母（a-zA-Z）、数字（0-9）和 -_.~ 4个特殊字符，以及保留字符! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])<br>如果你的url请求中包含这些以外的特殊字符，可以在conf/catalina.properties中最后添加2行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tomcat.util.http.parser.HttpParser.requestTargetAllow=|&#123;&#125;</span><br><span class="line">org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在conf/server.xml的Connector添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">relaxedPathChars=<span class="string">&quot;[]|&#123;&#125;^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot;</span> </span><br><span class="line">relaxedQueryChars=<span class="string">&quot;[]|&#123;&#125;^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot;</span></span><br></pre></td></tr></table></figure><p>（4）还有一种说法是跟https有关<br>说是原本是http的请求，然后错误使用https访问导致的，首先我这个http和https都是可以访问的，不存在这种情况，然后代码里面有一些第三方的调用，也是没有问题的<br>（5）非法访问<br>网上看到一篇博客有说可能一些非法访问的请求也会导致这种问题，我找到了报错信息的具体时间，然后找到localhost_access_log.2020-08-20.txt<br>![](Tomcat 运行时出现Invalid character found in the HTTP protocol/a1.png)<br>![](Tomcat 运行时出现Invalid character found in the HTTP protocol/a2.png)<br>这种情况导致这种错误也是不可避免的</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决logrotate日志切割后继续输出在原日志的问题</title>
      <link href="2020/08/22/%E8%A7%A3%E5%86%B3logrotate%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%90%8E%E7%BB%A7%E7%BB%AD%E8%BE%93%E5%87%BA%E5%9C%A8%E5%8E%9F%E6%97%A5%E5%BF%97%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2020/08/22/%E8%A7%A3%E5%86%B3logrotate%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%90%8E%E7%BB%A7%E7%BB%AD%E8%BE%93%E5%87%BA%E5%9C%A8%E5%8E%9F%E6%97%A5%E5%BF%97%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果线上使用logrotate切割日志会出现切割后，新的日志输出还是会写在老的日志</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>网上查下来有两种解决方法，两种方式我都尝试了切割nginx日志，但是只成功了第一种<br>（1）通过copytruncate参数<br>copytruncate参数的原理：将之前的日志内容拷贝走作为备份，接着清空当前文件。这个方法会存在丢失部分日志数据的可能</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/app/nginx/logs/access.log &#123;</span><br><span class="line">        daily</span><br><span class="line">        dateext</span><br><span class="line">        rotate 14</span><br><span class="line">        compress</span><br><span class="line">        delaycompress</span><br><span class="line">        missingok</span><br><span class="line">        notifempty</span><br><span class="line">        copytruncate</span><br><span class="line">        create 0664 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）给rsyslog发信号<br>这个方法我试过了，但是没有成功，新的日志还是输出在老的日志文件中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/app/nginx/logs/access.log &#123;</span><br><span class="line">        daily</span><br><span class="line">        dateext</span><br><span class="line">        rotate 14</span><br><span class="line">        compress</span><br><span class="line">        delaycompress</span><br><span class="line">        missingok</span><br><span class="line">        notifempty</span><br><span class="line">        create 0664 root root</span><br><span class="line">        postrotate</span><br><span class="line">            /bin/<span class="built_in">kill</span> -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || <span class="literal">true</span></span><br><span class="line">        endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logrotate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7搭建Harbor私有仓库</title>
      <link href="2020/08/21/CentOS7%E6%90%AD%E5%BB%BAHarbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
      <url>2020/08/21/CentOS7%E6%90%AD%E5%BB%BAHarbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在生产环境中，我们肯定需要使用docker的私有仓库，下面介绍HarBor私有仓库的搭建</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更新yum</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment">#安装需要的软件包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data 1vm2</span><br><span class="line"><span class="comment">#设置yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">yum install docker-ce-17.12.1.ce</span><br><span class="line"><span class="comment">#设置开机自启，启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#授权</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h2 id="下载Harbor"><a href="#下载Harbor" class="headerlink" title="下载Harbor"></a>下载Harbor</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.5.3.tgz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -zxvf harbor-offline-installer-v1.5.3.tgz</span><br><span class="line">mv harbor /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改harbor.cfg配置</span></span><br><span class="line">hostname = 192.168.37.148</span><br><span class="line">harbor_admin_password = Harbor12345  <span class="comment">#密码</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置</span></span><br><span class="line">./prepare</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p>当出现这个表示已经成功了<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/21/CentOS7%E6%90%AD%E5%BB%BAHarbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/a1.png"><br>浏览器输入ip 即可访问，用户名：admin  密码是配置文件 harbor_admin_password 所对应的<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/21/CentOS7%E6%90%AD%E5%BB%BAHarbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/a2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab数据备份与恢复</title>
      <link href="2020/08/13/GitLab%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>2020/08/13/GitLab%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>GitLab需要备份的数据有2块，一个是/etc/gitlab下的配置文件，还有一个是使用gitlab-rake指令备份的相关文件</p><h2 id="GitLab配置文件"><a href="#GitLab配置文件" class="headerlink" title="GitLab配置文件"></a>GitLab配置文件</h2><p>GitLab默认的配置文件路径：/etc/gitlab/，需要手工备份</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar cvf /opt/backup/gitlab/conf/`date +%Y%m%d`-gitlab.tar.gz  /etc/gitlab</span><br></pre></td></tr></table></figure><h2 id="编辑备份参数"><a href="#编辑备份参数" class="headerlink" title="编辑备份参数"></a>编辑备份参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">#备份路径</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;backup_path&#x27;</span>] = <span class="string">&quot;/opt/nas/gitlabback/data&quot;</span></span><br><span class="line"><span class="comment">#备份包权限</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;backup_archive_permissions&#x27;</span>] = 0644</span><br><span class="line"><span class="comment">#备份保留时间，单位秒，默认7天</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;backup_keep_time&#x27;</span>] = 604800</span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置，使之生效</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><h2 id="执行备份"><a href="#执行备份" class="headerlink" title="执行备份"></a>执行备份</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><h2 id="还原数据"><a href="#还原数据" class="headerlink" title="还原数据"></a>还原数据</h2><p>保证GitLab版本号是一致的<br>（1）还原配置文件<br>将配置文件上传至服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\mv gitlab.rb gitlab-secrets.json /etc/gitlab/</span><br></pre></td></tr></table></figure><p>修改配置文件里面关于url地址 external_url</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重载gitlab配置</span></span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>（2）还原GitLab数据<br>将gitlab-rake打包的文件放到 gitlab_rails[‘backup_path’] 对应目录下<br>gitlab_rails[‘backup_path’] = “/opt/nas/gitlabback/data”</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复数据，注意BACKUP=后面只要 _gitlab_backup.tar 前面的版本号，如下</span></span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1597282053_2020_08_13_10.0.6</span><br><span class="line"><span class="comment">#重载gitlab配置</span></span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins数据备份与恢复</title>
      <link href="2020/08/13/Jenkins%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>2020/08/13/Jenkins%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>生产环境我们肯定会考虑jenkins的数据备份和恢复问题，ThinBackup插件方便我们通过界面方式快速备份数据与恢复</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在jenkins插件市场搜索ThinBackup，并下载安装</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>在Manage Jenkins -&gt; ThinBackup -&gt; setting 配置备份信息<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/13/Jenkins%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/a1.png"><br>各参数说明</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#备份目录，用于存储备份的文件</span></span><br><span class="line">Backup directory</span><br><span class="line"><span class="comment">#全量备份计划，跟crontab一样</span></span><br><span class="line">Backup schedule <span class="keyword">for</span> full backups</span><br><span class="line"><span class="comment">#进行差异化备份的计划任务，同上</span></span><br><span class="line">Backup schedule <span class="keyword">for</span> differential backups</span><br><span class="line"><span class="comment">#备份的最大数量</span></span><br><span class="line">Max number of backup sets</span><br><span class="line"><span class="comment">#不需要进行备份的文件的正则表达式</span></span><br><span class="line">Files excluded from backup (regular expression)</span><br><span class="line"><span class="comment">#等待jenkins空闲多长时间后进行备份</span></span><br><span class="line">Wait until Jenkins/Hudson is idle to perform a backup</span><br><span class="line"><span class="comment">#备份构建结果</span></span><br><span class="line">Backup build results</span><br><span class="line"><span class="comment">#备份`$&#123;jenkins_home&#125;/userContent `目录下的文件</span></span><br><span class="line">Backup <span class="string">&#x27;userContent&#x27;</span> folder</span><br><span class="line"><span class="comment">#备份jenkins构建的build id文件</span></span><br><span class="line">Backup next build number file</span><br><span class="line"><span class="comment">#备份插件</span></span><br><span class="line">Backup plugins archives</span><br><span class="line"><span class="comment">#完成备份以后清除所有的差异备份</span></span><br><span class="line">Clean up differential backups</span><br><span class="line"><span class="comment">#将老的文件压缩</span></span><br><span class="line">Move old backups to ZIP files</span><br></pre></td></tr></table></figure><p>可以通过点击 Backup Now 立即备份<br>注：记得授权备份存储路径：chown -R jenkins:jenkins /opt/nas/jenkinsbackup</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>点击Restore，选择要恢复的时间点<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/13/Jenkins%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/a2.png"><br>在点击 Manage Jenkins -&gt; Reload Configuration from Disk 重载配置，恢复完成</p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL通过binlog日志恢复数据</title>
      <link href="2020/08/13/MySQL%E9%80%9A%E8%BF%87binlog%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
      <url>2020/08/13/MySQL%E9%80%9A%E8%BF%87binlog%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果是云数据库，一般可以通过控制台看到binlog日志记录时间等信息，如果是本地数据库可以通过一下命令查看信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有binlog日志列表</span></span><br><span class="line">show master logs;</span><br><span class="line"><span class="comment">#查看最后一个binlog日志编号及其最后一个操作事件pos结束点的值</span></span><br><span class="line">show master status;</span><br><span class="line"><span class="comment">#查看mysql-bin.000003具体信息</span></span><br><span class="line">show binlog events <span class="keyword">in</span> ‘mysql-bin.000003’; </span><br></pre></td></tr></table></figure><p>将二进制日志转成可阅读的文档</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog --base64-output=decode-rows -v  mysql-bin.000003 &gt; mysql-bin.000003.txt</span><br></pre></td></tr></table></figure><p>查看二进制文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># at 30857945</span></span><br><span class="line"><span class="comment">#200812  3:17:00 server id 2798978092  end_log_pos 30858334</span></span><br><span class="line"><span class="comment">### UPDATE `staff`.`info`</span></span><br><span class="line"><span class="comment">###   @1=&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">### SET</span></span><br><span class="line"><span class="comment">###   @1=&#x27;2&#x27;</span></span><br><span class="line"><span class="comment"># at 30858334</span></span><br></pre></td></tr></table></figure><p>第一行at表示起始pos点，end_log_pos表示该事件结束的pos点,最后一行at表示下个事件的起始pos点</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--start-position表示起始pos点，--stop-position表示结束pos点 --database表示数据库  |表示将输出交给mysql命令  -v表示执行</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog --start-position=30857945 --stop-position=30858334 --database=staff mysql-bin.000003 | /usr/<span class="built_in">local</span>/mysql/bin/mysql -uroot -p<span class="string">&#x27;123456&#x27;</span> -v staff</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy+PXC实现负载均衡</title>
      <link href="2020/08/12/HAProxy-PXC%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2020/08/12/HAProxy-PXC%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PXC集群搭建请参考之前的文章</p><h2 id="安装HAProxy"><a href="#安装HAProxy" class="headerlink" title="安装HAProxy"></a>安装HAProxy</h2><p>下载：<a href="https://src.fedoraproject.org/repo/pkgs/haproxy/%EF%BC%8C%E6%88%91%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF1.8.20%E7%89%88%E6%9C%AC">https://src.fedoraproject.org/repo/pkgs/haproxy/，我使用的是1.8.20版本</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar zxvf haproxy-1.8.20.tar.gz</span><br><span class="line"><span class="built_in">cd</span> haproxy-1.8.20</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make TARGET=linux31</span><br><span class="line">make install PREFIX=/usr/<span class="built_in">local</span>/haproxy</span><br><span class="line"><span class="comment">#复制配置文件到指定目录</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/haproxy/conf</span><br><span class="line">cp /usr/<span class="built_in">local</span>/haproxy-1.8.20/examples/option-http_proxy.cfg /usr/<span class="built_in">local</span>/haproxy/conf/haproxy.cfg</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># demo config for Proxy mode</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">global</span><br><span class="line">    maxconn         20000</span><br><span class="line">    <span class="built_in">ulimit</span>-n        16384</span><br><span class="line">    <span class="built_in">log</span>             127.0.0.1 local0 info</span><br><span class="line">    uid             200</span><br><span class="line">    gid             200</span><br><span class="line">    chroot          /var/empty</span><br><span class="line">    nbproc            4</span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    <span class="built_in">log</span>            global</span><br><span class="line">    mode        http</span><br><span class="line">    <span class="comment">#日志格式</span></span><br><span class="line">    option        httplog</span><br><span class="line">    <span class="comment">#日志中不记录负载均衡的心跳检测记录</span></span><br><span class="line">    option        dontlognull</span><br><span class="line">    <span class="comment">#连接超时（毫秒）</span></span><br><span class="line">    timeout connect 5000</span><br><span class="line">    <span class="comment">#客户端超时（毫秒）</span></span><br><span class="line">    timeout client  5000</span><br><span class="line">    <span class="comment">#服务器超时（毫秒）</span></span><br><span class="line">    timeout server  5000</span><br><span class="line">    <span class="comment">#尝试次数</span></span><br><span class="line">    retries         2</span><br><span class="line"></span><br><span class="line">listen  admin_stats</span><br><span class="line">    <span class="comment">#监控界面的访问ip和port</span></span><br><span class="line">    <span class="built_in">bind</span>        0.0.0.0:8888</span><br><span class="line">    <span class="comment">#访问协议</span></span><br><span class="line">    mode        http</span><br><span class="line">    <span class="comment">#URI相对地址</span></span><br><span class="line">    stats uri    /dbs</span><br><span class="line">    <span class="comment">#统计报告格式</span></span><br><span class="line">    stats realm    Global\ statistics</span><br><span class="line">    <span class="comment">#登录账户信息</span></span><br><span class="line">    stats auth    admin:123456</span><br><span class="line">    </span><br><span class="line">listen proxy-mysql        </span><br><span class="line">    <span class="built_in">bind</span>        0.0.0.0:3306</span><br><span class="line">    mode        tcp</span><br><span class="line">    <span class="comment">#负载均衡算法</span></span><br><span class="line">    <span class="comment">#轮询：roundrobin  权重：static-rr  最少连接：leastconn  请求ip：source</span></span><br><span class="line">    balance        roundrobin</span><br><span class="line">    <span class="comment">#日志格式</span></span><br><span class="line">    option        tcplog</span><br><span class="line">    <span class="comment">#在MySQL中创建一个没有权限的haproxy用户，密码为空. Haproxy使用这个账户对MySQL数据库心跳检测</span></span><br><span class="line">    <span class="comment"># CREATE USER &#x27;haproxy&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&#x27;; </span></span><br><span class="line">    option        mysql-check user haproxy</span><br><span class="line">    <span class="comment">#使用keepalive检测死链</span></span><br><span class="line">    option        tcpka</span><br><span class="line">    server        server1 192.168.37.142:3306 check maxconn 2000</span><br><span class="line">    server      server2 192.168.37.143:3306 check maxconn 2000</span><br><span class="line">    server      server3 192.168.37.144:3306 check maxconn 2000</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1.浏览器输入ip:8888/dbs,通过配置的用户名和密码登录<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/12/HAProxy-PXC%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/a1.png"><br>2.使用navicat连接数据库<br>通过HAProxy的 ip 加上 listen proxy-mysql 配置的端口连接，在创建数据库，查看pxc各个节点的数据库</p>]]></content>
      
      
      <categories>
          
          <category> HAProxy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy配置参数详解</title>
      <link href="2020/08/12/HAProxy%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/08/12/HAProxy%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>HAProxy配置文件分成五个部分，主要介绍常用配置<br>    1.global：设置全局配置参数，主要是进程、操作系统相关的配置<br>    2.defaults：配置默认参数，这些参数可以被用到frontend、backend、listen组件<br>    3.frontend：接收请求的前端虚拟节点，可以添加相应的规则匹配到后端backend<br>    4.backend：后端真实服务器集群配置<br>    5.listen：frontend和backend的组合</p><h2 id="global组件"><a href="#global组件" class="headerlink" title="global组件"></a>global组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    <span class="comment">#以守护进程方式启动</span></span><br><span class="line">    daemon</span><br><span class="line">    <span class="comment">#设置运行haproxy的用户和组</span></span><br><span class="line">    user        haproxy</span><br><span class="line">    group        haproxy</span><br><span class="line">    <span class="comment">#设置haproxy启动时的进程数</span></span><br><span class="line">    nbproc        4</span><br><span class="line">    <span class="comment">#每个进程支持的最大并发连接数</span></span><br><span class="line">    maxconn        20000</span><br><span class="line">    <span class="comment">#设置最大打开文件描述符</span></span><br><span class="line">    <span class="built_in">ulimit</span>-n    16384</span><br><span class="line">    <span class="comment">#设置haproxy的pid文件</span></span><br><span class="line">    pidfile /var/run/haproxy.pid</span><br><span class="line">    <span class="comment">#设置日志配置</span></span><br><span class="line">    <span class="built_in">log</span> 127.0.0.1 local0 info</span><br></pre></td></tr></table></figure><h2 id="defaults组件"><a href="#defaults组件" class="headerlink" title="defaults组件"></a>defaults组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">    <span class="comment">#访问协议,mode &#123;http|tcp|health&#125;,http是七层模式    tcp是四层模式 health是健康检测</span></span><br><span class="line">    mode        http</span><br><span class="line">    <span class="comment">#日志配置，也可以使用 log  global 引入全局配置    </span></span><br><span class="line">    <span class="built_in">log</span> 127.0.0.1 local0 error</span><br><span class="line">    <span class="comment">#设置连接后端服务器失败重连次数，超过该值将会将对应服务器标记为不可用</span></span><br><span class="line">    retries    3</span><br><span class="line">    <span class="comment">#启动日志记录HTTP请求，默认haproxy是不记录HTTP请求的</span></span><br><span class="line">    option     httplog</span><br><span class="line">    <span class="comment">#当使用了cookie时，haproxy将会将其请求的后端服务器的serverID插入到cookie中，以保证会话的SESSION持久性；</span></span><br><span class="line">    <span class="comment">#而此时，如果后端的服务器宕掉了，但是客户端的cookie是不会刷新的，如果设置此参数，将会将客户的请求强制定向到另外一个后端server上，以保证服务的正常。</span></span><br><span class="line">    option  redispatch</span><br><span class="line">    <span class="comment">#当服务器负载很高的时候，自动结束当前队列处理比较久的连接</span></span><br><span class="line">    option     abortonclose</span><br><span class="line">    <span class="comment">#启用该项，日志将不会记录空连接。官方建议如果上游服务器没有其他负载均衡器，建议不要使用该参数</span></span><br><span class="line">    option  dontlognull</span><br><span class="line">    <span class="comment">#客户端与服务端完成一次连接请求后，自动关闭此TCP连接</span></span><br><span class="line">    option    httpclose</span><br><span class="line">    <span class="comment">#连接超时（毫秒）</span></span><br><span class="line">    timeout connect 5000</span><br><span class="line">    <span class="comment">#客户端超时（毫秒）</span></span><br><span class="line">    timeout client  5000</span><br><span class="line">    <span class="comment">#服务器超时（毫秒）</span></span><br><span class="line">    timeout server  5000</span><br><span class="line">    <span class="comment">#检查超时时间（毫秒）</span></span><br><span class="line">    timeout check    5000</span><br></pre></td></tr></table></figure><h2 id="frontend组件"><a href="#frontend组件" class="headerlink" title="frontend组件"></a>frontend组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个web前端部分</span></span><br><span class="line">frontend myweb</span><br><span class="line">    <span class="comment">#监听的端口</span></span><br><span class="line">    <span class="built_in">bind</span>    0.0.0.0:80</span><br><span class="line">    <span class="comment">#访问协议</span></span><br><span class="line">    mode    http</span><br><span class="line">    <span class="comment">#日志配置</span></span><br><span class="line">    <span class="built_in">log</span>        global</span><br><span class="line">    <span class="comment">#允许插入X_forward_for数据包头给后端server，可让后端server获得客户端的真实IP</span></span><br><span class="line">    option    forwardfor</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义一个web_static_req的acl，当请求的url末尾是以.css .jpg .png .jpeg .js .gif结尾时，将会匹配</span></span><br><span class="line">    acl web_static_req /*.(css|jpg|png|jpeg|js|gif)$</span><br><span class="line">    <span class="comment">#定义一个realserver_req的acl，当 static_server 中存活机器小于1时将会被匹配</span></span><br><span class="line">    acl realserver_req nbsrv(static_server) lt 1</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认规则</span></span><br><span class="line">    default_backend  web_server</span><br><span class="line">    <span class="comment">#如果realserver_req满足，走backend web_server</span></span><br><span class="line">    use_backend web_server <span class="keyword">if</span> realserver_req</span><br><span class="line">    <span class="comment">#如果web_static_req满足，走backend static_server</span></span><br><span class="line">    use_backend static_server <span class="keyword">if</span> web_static_req</span><br></pre></td></tr></table></figure><h2 id="backend组件"><a href="#backend组件" class="headerlink" title="backend组件"></a>backend组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backend web_server</span><br><span class="line">    mode http</span><br><span class="line">    <span class="comment">#轮询算法：roundrobin 权重算法：static-rr 最少连接算法：leastconn 请求源IP算法：source</span></span><br><span class="line">    balance  roundrobin</span><br><span class="line">    <span class="comment">#开启对后端服务器的健康检测</span></span><br><span class="line">    option httpchk GET /<span class="built_in">test</span>/index.php</span><br><span class="line">    <span class="comment">#后端真实服务器</span></span><br><span class="line">    check表示接受健康检测  inter表示健康检测间隔  rise表示检测成功多少次正常才算正常 fail表示检测多少次失败才算失败 weight表示分发权重 maxconn表示最大连接</span><br><span class="line">    server  server1 172.18.0.2:3306 check inter 2000 rise 3 fall 3  weight 1 maxconn 2000</span><br><span class="line">    server  server2 172.18.0.3:3306 check inter 2000 rise 3 fall 3 weight 1 maxconn 2000</span><br><span class="line">    server  server3 172.18.0.4:3306 check inter 2000 rise 3 fall 3 weight 1 maxconn 2000</span><br></pre></td></tr></table></figure><h2 id="listen组件"><a href="#listen组件" class="headerlink" title="listen组件"></a>listen组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen admin_stats</span><br><span class="line">    <span class="built_in">bind</span>    0.0.0.0:8888</span><br><span class="line">    mode     http</span><br><span class="line">    <span class="built_in">log</span>     global</span><br><span class="line">    <span class="comment">#haproxy统计页面刷新间隔</span></span><br><span class="line">    stats refresh    30s    </span><br><span class="line">    <span class="comment">#URI相对地址</span></span><br><span class="line">    stats uri     /dbs</span><br><span class="line">    <span class="comment">#统计报告格式</span></span><br><span class="line">    stats realm     Global\ statistics</span><br><span class="line">    <span class="comment">#登陆帐户信息  用户名:密码</span></span><br><span class="line">    stats auth  admin:admin</span><br><span class="line">    <span class="comment">#隐藏统计页面上的haproxy版本信息</span></span><br><span class="line">    stats hide-version</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库负载均衡</span></span><br><span class="line">listen  proxy-mysql</span><br><span class="line">    <span class="comment">#访问的IP和端口</span></span><br><span class="line">    <span class="built_in">bind</span>  0.0.0.0:3306</span><br><span class="line">    <span class="comment">#网络协议</span></span><br><span class="line">    mode  tcp</span><br><span class="line">    <span class="comment">#负载均衡算法（轮询算法）</span></span><br><span class="line">    <span class="comment">#轮询算法：roundrobin</span></span><br><span class="line">    <span class="comment">#权重算法：static-rr</span></span><br><span class="line">    <span class="comment">#最少连接算法：leastconn</span></span><br><span class="line">    <span class="comment">#请求源IP算法：source</span></span><br><span class="line">    balance  roundrobin</span><br><span class="line">    <span class="comment">#日志格式</span></span><br><span class="line">    option  tcplog</span><br><span class="line">    <span class="comment">#在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span></span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    <span class="comment">#使用keepalive检测死链</span></span><br><span class="line">    option  tcpka</span><br><span class="line">    <span class="comment">#后端真实服务器    </span></span><br><span class="line">    server  MySQL_1 192.168.37.100:3306 check weight 1 maxconn 2000</span><br><span class="line">    server  MySQL_2 192.168.37.101:3306 check weight 1 maxconn 2000</span><br><span class="line">    server  MySQL_3 192.168.37.102:3306 check weight 1 maxconn 2000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HAProxy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之高可用PXC集群搭建</title>
      <link href="2020/08/12/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8PXC%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>2020/08/12/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8PXC%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Percona XtraDB Cluster是MySQL高可用的一种方案,PXC集群是以节点组成（建议至少3个节点）,每个节点都是常规的MySQL或者Percona Server,并且所有节点都是可读可写的,集群中的每个节点都保留着完整的数据,相对于主从架构，PXC更加体现出数据的强一致性。</p><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>（1）服务高可用：所有节点数据是相同的，所有节点可读可写，只要存在一个节点可用，整个服务还能正常运行<br>（2）同步复制：当请求过来，只有所有节点成功提交，否则算提交失败<br>（3）多主复制：所有节点可读可写<br>总结来说PXC最大的优势：强一致性、所有节点可读可写、无同步时延</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>（1）仅支持InnoDB事务控制<br>（2）数据重复，所有节点都保留一份完整的数据<br>（3）PXC具有强一致性，必须所有节点执行成功才算提交成功，写入效率取决于节点最弱的一台<br>（4）新加入节点需要复制一份完整的数据,采用全量数据传输（SST）代价高<br>（5）所有表都要有主键<br>（6）存在较多的锁冲突、死锁问题<br>（7）不支持LOCK TABLE<br>（8）不支持XA</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node1:192.168.37.142</span><br><span class="line">node2:192.168.37.143</span><br><span class="line">node3:192.168.37.144</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27;</span> /etc/sysconfig/selinux</span><br><span class="line"><span class="comment">#设置hostname,三台机器分别对应node1 node2 node3</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node1</span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node2</span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node3</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="安装Percona-XtraDB-Cluster-5-7"><a href="#安装Percona-XtraDB-Cluster-5-7" class="headerlink" title="安装Percona XtraDB Cluster 5.7"></a>安装Percona XtraDB Cluster 5.7</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所有机器配置yum源 vim /etc/yum.repos.d/pxc.repo</span></span><br><span class="line">[percona]</span><br><span class="line">name=percona_repo</span><br><span class="line">baseurl =https://mirrors.tuna.tsinghua.edu.cn/percona/release/<span class="variable">$releasever</span>/RPMS/<span class="variable">$basearch</span></span><br><span class="line">enabled = 1</span><br><span class="line">gpgcheck = 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#所有机器安装</span></span><br><span class="line">yum -y install Percona-XtraDB-Cluster-57</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsrep_provider：指定Gelera库的路径</span><br><span class="line">wsrep_cluster_address：Galera集群各节点地址</span><br><span class="line">binlog_format：二进制日志格式，仅支持row格式的二进制日志</span><br><span class="line">default_storage_engine：指定默认存储引擎，仅支持InnoDB</span><br><span class="line">wsrep_slave_threads：用于设置读节点执行写集的线程个数</span><br><span class="line">wsrep_log_conflicts：启用时输出的错误日志将包含产生冲突的表和schema</span><br><span class="line">innodb_autoinc_lock_mode：只能设置为2，设置0或1时无法正确处理死锁问题</span><br><span class="line">wsrep_node_address：本节点IP</span><br><span class="line">wsrep_cluster_name：集群名称</span><br><span class="line">wsrep_node_name：本节点hostname</span><br><span class="line">pxc_strict_mode：是否限制pxc启动正在试用阶段的功能，默认值ENFORCING，表示不启用</span><br><span class="line">wsrep_sst_method：全量传输SST，可用方法有mysqldump、rsync和xtrabackup，前2者在传输时都需要对Donor加全局只读锁，xtrabackup不需要，推荐使用xtrabackup</span><br><span class="line">wsrep_sst_auth：在SST传输时需要用到的认证凭据，格式为：<span class="string">&quot;用户:密码&quot;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件都放在/etc/percona-xtradb-cluster.conf.d目录里，包括mysqld.cnf，mysqld_safe.cnf，wsrep.cnf 三个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat mysqld.cnf </span></span><br><span class="line"><span class="comment"># Template my.cnf for PXC</span></span><br><span class="line"><span class="comment"># Edit to your requirements.</span></span><br><span class="line">[client]</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#server-id必须保证不一样</span></span><br><span class="line">server-id=3</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"><span class="built_in">log</span>-bin</span><br><span class="line">log_slave_updates</span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat mysqld_safe.cnf </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Percona Server 5.7 configuration file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># One can use all long options that the program supports.</span></span><br><span class="line"><span class="comment"># Run program with --help to get a list of available options and with</span></span><br><span class="line"><span class="comment"># --print-defaults to see which it would actually understand and use.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For explanations see</span></span><br><span class="line"><span class="comment"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span></span><br><span class="line"><span class="comment">#不需要改变</span></span><br><span class="line">[mysqld_safe]</span><br><span class="line">pid-file = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket   = /var/lib/mysql/mysql.sock</span><br><span class="line">nice     = 0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># Path to Galera library</span></span><br><span class="line">wsrep_provider=/usr/lib64/galera3/libgalera_smm.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster connection URL contains IPs of nodes</span></span><br><span class="line"><span class="comment">#If no IP is found, this implies that a new cluster needs to be created,</span></span><br><span class="line"><span class="comment">#in order to do that you need to bootstrap this node</span></span><br><span class="line"><span class="comment">#集群内所有节点IP，保证本地节点IP在最后</span></span><br><span class="line">wsrep_cluster_address=gcomm://192.168.37.142,192.168.37.143,192.168.37.144</span><br><span class="line"></span><br><span class="line"><span class="comment"># In order for Galera to work correctly binlog format should be ROW</span></span><br><span class="line">binlog_format=ROW</span><br><span class="line"></span><br><span class="line"><span class="comment"># MyISAM storage engine has only experimental support</span></span><br><span class="line">default_storage_engine=InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slave thread to use</span></span><br><span class="line">wsrep_slave_threads= 8</span><br><span class="line"></span><br><span class="line">wsrep_log_conflicts</span><br><span class="line"></span><br><span class="line"><span class="comment"># This changes how InnoDB autoincrement locks are managed and is a requirement for Galera</span></span><br><span class="line">innodb_autoinc_lock_mode=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Node IP address</span></span><br><span class="line"><span class="comment">#指定自己节点的IP</span></span><br><span class="line">wsrep_node_address=192.168.37.144</span><br><span class="line"><span class="comment"># Cluster name</span></span><br><span class="line"><span class="comment">#集群名称，三台一样</span></span><br><span class="line">wsrep_cluster_name=pxc-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment">#If wsrep_node_name is not specified,  then system hostname will be used</span></span><br><span class="line"><span class="comment">#每台机器对应的hostname</span></span><br><span class="line">wsrep_node_name=node3</span><br><span class="line"></span><br><span class="line"><span class="comment">#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER</span></span><br><span class="line">pxc_strict_mode=ENFORCING</span><br><span class="line"></span><br><span class="line"><span class="comment"># SST method</span></span><br><span class="line"><span class="comment">#推荐使用xtrabackup</span></span><br><span class="line">wsrep_sst_method=xtrabackup-v2</span><br><span class="line"></span><br><span class="line"><span class="comment">#Authentication for SST method</span></span><br><span class="line"><span class="comment">#SST复制所需要使用的mysql用户名和密码</span></span><br><span class="line">wsrep_sst_auth=<span class="string">&quot;admin:admin&quot;</span></span><br></pre></td></tr></table></figure><h2 id="启动PXC集群第一个节点"><a href="#启动PXC集群第一个节点" class="headerlink" title="启动PXC集群第一个节点"></a>启动PXC集群第一个节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl  start  mysql@bootstrap.service</span><br><span class="line"><span class="comment">#获取初始密码</span></span><br><span class="line">grep <span class="string">&quot;temporary password&quot;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment">#登录mysql</span></span><br><span class="line">mysql -uroot -p<span class="string">&#x27;密码&#x27;</span></span><br><span class="line"><span class="comment">#修改密码</span></span><br><span class="line">ALTER user root@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment">#授予远程登录权限</span></span><br><span class="line">use mysql;</span><br><span class="line">update mysql.user <span class="built_in">set</span> host=<span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建SST传输需要的用户</span></span><br><span class="line">CREATE user admin@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">GRANT RELOAD, LOCK TABLES, PROCESS, REPLICATION CLIENT ON *.* TO admin@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">//刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h2 id="启动其他节点"><a href="#启动其他节点" class="headerlink" title="启动其他节点"></a>启动其他节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动其他PXC节点与第一个节点命令不同</span></span><br><span class="line">service mysql start</span><br></pre></td></tr></table></figure><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show status like <span class="string">&#x27;%wsrep%&#x27;</span></span><br><span class="line"></span><br><span class="line">wsrep_cluster_size表示集群节点数量</span><br><span class="line"><span class="comment">#当wsrep_local_state 为4，wsrep_local_state_comment为Synced 时，表示数据同步完成     </span></span><br><span class="line">wsrep_local_state  <span class="comment">#本地状态</span></span><br><span class="line">wsrep_local_state_comment <span class="comment">#本地状态评论</span></span><br><span class="line"><span class="comment">#当wsrep_cluster_status为Primary表示当前节点已经完成连接并准备好</span></span><br><span class="line">wsrep_cluster_status</span><br></pre></td></tr></table></figure><h2 id="验证集群是否成功"><a href="#验证集群是否成功" class="headerlink" title="验证集群是否成功"></a>验证集群是否成功</h2><p>使用navicat连接三个节点<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/12/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8PXC%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/a1.png"><br>在其中一个节点创建数据库staff，刷新下其他节点<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/12/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8PXC%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/a2.png"><br>可以发现其他节点也创建了staff数据库，整个集群状态是正常的</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitLab的webhook来实现触发Jenkins自动操作</title>
      <link href="2020/08/11/%E5%88%A9%E7%94%A8GitLab%E7%9A%84webhook%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%8F%91Jenkins%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2020/08/11/%E5%88%A9%E7%94%A8GitLab%E7%9A%84webhook%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%8F%91Jenkins%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文主要介绍GitLab、jenkins配置，以实现当GitLab提交事务时触发jenkins相应的操作</p><a id="more"></a><h2 id="下载jenkins插件"><a href="#下载jenkins插件" class="headerlink" title="下载jenkins插件"></a>下载jenkins插件</h2><p>在jenkins插件中心下载Gitlab Hook、GitLab、Gitlab Authentication 插件</p><h2 id="配置jenkins触发器"><a href="#配置jenkins触发器" class="headerlink" title="配置jenkins触发器"></a>配置jenkins触发器</h2><p>首先记录图片上面的地址，点击Generate生成Secret token并记录<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/11/%E5%88%A9%E7%94%A8GitLab%E7%9A%84webhook%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%8F%91Jenkins%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/a1.png"></p><h2 id="配置GitLab"><a href="#配置GitLab" class="headerlink" title="配置GitLab"></a>配置GitLab</h2><p>找到对应的仓库，点击Settings - Integrations 粘贴刚刚记录的 URL 和Secret token，点击Add webhook<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/11/%E5%88%A9%E7%94%A8GitLab%E7%9A%84webhook%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%8F%91Jenkins%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/a2.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/11/%E5%88%A9%E7%94%A8GitLab%E7%9A%84webhook%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%8F%91Jenkins%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/08/11/%E5%88%A9%E7%94%A8GitLab%E7%9A%84webhook%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%8F%91Jenkins%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/a4.png"></p>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins配置邮件通知</title>
      <link href="2020/08/11/Jenkins%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/"/>
      <url>2020/08/11/Jenkins%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要介绍通过Extreme Notification Plugin插件来配置邮件通知功能</p><a id="more"></a><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>在插件市场下载安装 Extreme Notification Plugin</p><h2 id="配置邮件服务"><a href="#配置邮件服务" class="headerlink" title="配置邮件服务"></a>配置邮件服务</h2><p>在系统管理 - 系统配置里面找到 Extended E-mail Notification<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/11/Jenkins%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/a1.png"></p><h2 id="pipeline发送邮件"><a href="#pipeline发送邮件" class="headerlink" title="pipeline发送邮件"></a>pipeline发送邮件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post&#123;</span><br><span class="line">  always &#123;</span><br><span class="line">    script &#123;</span><br><span class="line">      emailext body: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;&lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;</span></span><br><span class="line"><span class="string">          offset=&quot;0&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;</span></span><br><span class="line"><span class="string">              style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;tr&gt;</span></span><br><span class="line"><span class="string">                  &lt;td&gt;&lt;br /&gt;</span></span><br><span class="line"><span class="string">                  &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="string">                  &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">              &lt;/tr&gt;</span></span><br><span class="line"><span class="string">              &lt;tr&gt;</span></span><br><span class="line"><span class="string">                  &lt;td&gt;</span></span><br><span class="line"><span class="string">                      &lt;ul&gt;</span></span><br><span class="line"><span class="string">                          &lt;li&gt;构建名称：$&#123;JOB_NAME&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                          &lt;li&gt;构建结果: &lt;span style=&quot;color:green&quot;&gt; $&#123;BUILD_STATUS&#125;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                          &lt;li&gt;构建编号：$&#123;BUILD_NUMBER&#125;  &lt;/li&gt;</span></span><br><span class="line"><span class="string">                          &lt;li&gt;构建者: $&#123;CAUSE&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                          &lt;li&gt;变更记录: $&#123;CHANGES,showPaths=true,showDependencies=true,format=&quot;&lt;pre&gt;&lt;ul&gt;&lt;li&gt;提交ID: %r&lt;/li&gt;&lt;li&gt;提交人：%a&lt;/li&gt;&lt;li&gt;提交时间：%d&lt;/li&gt;&lt;li&gt;提交信息：%m&lt;/li&gt;&lt;li&gt;提交文件：&lt;br /&gt;%p&lt;/li&gt;&lt;/ul&gt;&lt;/pre&gt;&quot;,pathFormat=&quot;         %p &lt;br /&gt;&quot;&#125;</span></span><br><span class="line"><span class="string">                      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">                  &lt;/td&gt;</span></span><br><span class="line"><span class="string">              &lt;/tr&gt;</span></span><br><span class="line"><span class="string">          &lt;/table&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;/html&gt;&#x27;</span><span class="string">&#x27;&#x27;</span>, subject: <span class="string">&#x27;$&#123;PROJECT_NAME&#125;&#x27;</span>, to: <span class="string">&#x27;xxxxxx@qq.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL如何通过binlog日志排查问题</title>
      <link href="2020/08/09/MySQL%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87binlog%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/"/>
      <url>2020/08/09/MySQL%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87binlog%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>binary log中记录了数据库内容的变化,这些变化是以二进制的方式存储到</p><a id="more"></a><p>1.通过mysqlbinlog工具，将binlog日志以文本形式显示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog mysql-bin.000183 &gt; mysql-bin.000183.txt</span><br></pre></td></tr></table></figure><p>2.这边转成文本后，里面记录的sql语句是经过64位编码转换后的内容，使用mysqlbinlog对应的参数即可查看具体sql内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog --base64-output=decode-rows -v --start-datetime=<span class="string">&quot;2017-08-12 15:00:19&quot;</span> --stop-datetime=<span class="string">&quot;2017-08-12 15:30:19&quot;</span> mysql-bin.000183 &gt; mysql-bin.000183.txt</span><br></pre></td></tr></table></figure><p>经过解码后，在mysql-bin.000183.txt文件中，以 ### 开头的就是具体的sql语句</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RDS全量数据恢复至本地MySQL</title>
      <link href="2020/08/09/RDS%E5%85%A8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E8%87%B3%E6%9C%AC%E5%9C%B0MySQL/"/>
      <url>2020/08/09/RDS%E5%85%A8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E8%87%B3%E6%9C%AC%E5%9C%B0MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从RDS备份与恢复下载需要恢复的数据（_qp.xb 后缀）</p><a id="more"></a><h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><p>MySQL 5.6及之前的版本需要安装 Percona XtraBackup 2.3<br>MySQL 5.7版本需要安装 Percona XtraBackup 2.4<br>MySQL 8.0版本需要安装 Percona XtraBackup 8.0</p><h2 id="安装innobackupex"><a href="#安装innobackupex" class="headerlink" title="安装innobackupex"></a>安装innobackupex</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装依赖库</span></span><br><span class="line">yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL libev-devel</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span><br><span class="line">yum -y install percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>恢复前，停止本地mysql服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解包</span></span><br><span class="line">cat &lt;数据备份文件名&gt;_qp.xb | xbstream -x -v -C /usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">innobackupex --decompress --remove-original /usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></table></figure><p>如果出现这个报错 sh: qpress: 未找到命令，请到<a href="http://www.quicklz.com/">http://www.quicklz.com/</a> 这里下载 qpress-11-linux-x64.tar</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf qpress-11-linux-x64.tar</span><br><span class="line">cp qpress /usr/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/data/backup-my.cnf --apply-log /usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></table></figure><p>当出现 innobackupex: completed OK！ 代表恢复成功<br>记得授权</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></table></figure><p>最后启动mysql即可</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins集成SonarQube</title>
      <link href="2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/"/>
      <url>2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文主要介绍jenkins与sonarQube的集成，以及使用pipeline去调用sonarqube检测我们的代码质量</p><a id="more"></a><h2 id="sonarqube设置"><a href="#sonarqube设置" class="headerlink" title="sonarqube设置"></a>sonarqube设置</h2><p>1.打开Force user authentication<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/a1.png"><br>2.创建token，并复制下来<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/a2.png"><br>3.添加Webhooks(格式 http://[ip]:[port]/sonarqube-webhook/)，注意地址最后面要有 /<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/a3.png"></p><h2 id="jenkins设置"><a href="#jenkins设置" class="headerlink" title="jenkins设置"></a>jenkins设置</h2><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在插件中心下载安装 SonarQube Scanner for Jenkins</p><h3 id="配置凭据"><a href="#配置凭据" class="headerlink" title="配置凭据"></a>配置凭据</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/a4.png"></p><h3 id="配置sonarqube-servers"><a href="#配置sonarqube-servers" class="headerlink" title="配置sonarqube servers"></a>配置sonarqube servers</h3><p>在 系统配置 里找到 SonarQube servers，Server authentication token选择刚刚添加的凭据<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/a5.png"></p><h3 id="配置sonarqube-scanner"><a href="#配置sonarqube-scanner" class="headerlink" title="配置sonarqube scanner"></a>配置sonarqube scanner</h3><p>在 全局工具配置 中配置sonarqube scanner<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/09/Jenkins%E9%9B%86%E6%88%90SonarQube/a6.png"></p><h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&#x27;tomcatVM&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        //git仓库地址</span><br><span class="line">        git_url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        //git凭据id</span><br><span class="line">        credentialsId = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        //分支</span><br><span class="line">        git_branch = <span class="string">&#x27;master&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        //清理工作空间</span><br><span class="line">        stage(<span class="string">&#x27;clean workspace&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                cleanWs()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //拉取代码</span><br><span class="line">        stage(<span class="string">&#x27;push git code&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                git credentialsId:<span class="string">&quot;<span class="variable">$&#123;credentialsId&#125;</span>&quot;</span>,url:<span class="string">&quot;<span class="variable">$&#123;git_url&#125;</span>&quot;</span>,branch: <span class="string">&quot;<span class="variable">$&#123;git_branch&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //打包</span><br><span class="line">        stage(<span class="string">&#x27;mvn build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;/usr/local/maven/bin/mvn clean install&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sonarqube分析代码</span><br><span class="line">        stage(<span class="string">&#x27;sonarqube analysis&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                //这边withSonarQubeEnv的参数就是系统配置sonarqube servers中配置的name</span><br><span class="line">                withSonarQubeEnv(<span class="string">&#x27;sonarServer&#x27;</span>) &#123;</span><br><span class="line">                    sh <span class="string">&quot;/usr/local/sonar-scanner-4.4.0.2170-linux/bin/sonar-scanner &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.projectKey=myproject &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.projectName=myproject &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.projectVersion=1.0 &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.sources=. &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.java.binaries=target/classes &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.login=admin &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.password=admin &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.pdf.username=admin &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.pdf.password=admin &quot;</span>+</span><br><span class="line">                       <span class="string">&quot;-Dsonar.pdf.skip=false&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                script &#123;</span><br><span class="line">                    //等待webhook返回代码检查结果</span><br><span class="line">                    //这里设置超时时间1分钟</span><br><span class="line">                    timeout(1) &#123;</span><br><span class="line">                        //获取结果，waitForQualityGate()中的参数也要与之前SonarQube servers中Name的配置相同</span><br><span class="line">                        def qg = waitForQualityGate(<span class="string">&#x27;sonarServer&#x27;</span>)</span><br><span class="line">                        <span class="keyword">if</span> (qg.status != <span class="string">&#x27;OK&#x27;</span>) &#123;</span><br><span class="line">                            error <span class="string">&quot;未通过Sonarqube的代码质量阈检查，请及时修改！failure: <span class="variable">$&#123;qg.status&#125;</span>&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;copy war to tomcat&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;cp target/myproject.war /usr/local/apache-tomcat-9.0.36/webapps/ROOT.war&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;excute shell&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;/usr/local/apache-tomcat-9.0.36/bin/startup.sh&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post&#123;</span><br><span class="line">          success &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                cleanWs()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          always &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">              emailext body: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;&lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;</span></span><br><span class="line"><span class="string">                  offset=&quot;0&quot;&gt;</span></span><br><span class="line"><span class="string">                  &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;</span></span><br><span class="line"><span class="string">                      style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;</span></span><br><span class="line"><span class="string">                      &lt;tr&gt;</span></span><br><span class="line"><span class="string">                          &lt;td&gt;&lt;br /&gt;</span></span><br><span class="line"><span class="string">                          &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="string">                          &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                      &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                      &lt;tr&gt;</span></span><br><span class="line"><span class="string">                          &lt;td&gt;</span></span><br><span class="line"><span class="string">                              &lt;ul&gt;</span></span><br><span class="line"><span class="string">                                  &lt;li&gt;构建名称：$&#123;JOB_NAME&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                                  &lt;li&gt;构建结果: &lt;span style=&quot;color:green&quot;&gt; $&#123;BUILD_STATUS&#125;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                                  &lt;li&gt;构建编号：$&#123;BUILD_NUMBER&#125;  &lt;/li&gt;</span></span><br><span class="line"><span class="string">                                  &lt;li&gt;构建者: $&#123;CAUSE&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                                  &lt;li&gt;变更记录: $&#123;CHANGES,showPaths=true,showDependencies=true,format=&quot;&lt;pre&gt;&lt;ul&gt;&lt;li&gt;提交ID: %r&lt;/li&gt;&lt;li&gt;提交人：%a&lt;/li&gt;&lt;li&gt;提交时间：%d&lt;/li&gt;&lt;li&gt;提交信息：%m&lt;/li&gt;&lt;li&gt;提交文件：&lt;br /&gt;%p&lt;/li&gt;&lt;/ul&gt;&lt;/pre&gt;&quot;,pathFormat=&quot;         %p &lt;br /&gt;&quot;&#125;</span></span><br><span class="line"><span class="string">                              &lt;/ul&gt;</span></span><br><span class="line"><span class="string">                          &lt;/td&gt;</span></span><br><span class="line"><span class="string">                      &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                  &lt;/table&gt;</span></span><br><span class="line"><span class="string">                &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;&#x27;</span><span class="string">&#x27;&#x27;</span>, subject: <span class="string">&#x27;$&#123;PROJECT_NAME&#125;&#x27;</span>, to: <span class="string">&#x27;xxxxxx@qq.com&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
          <category> SonarQube </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装SonarQube</title>
      <link href="2020/08/09/Linux%E4%B8%8B%E5%AE%89%E8%A3%85SonarQube/"/>
      <url>2020/08/09/Linux%E4%B8%8B%E5%AE%89%E8%A3%85SonarQube/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>SonarQube是管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载sonar：<a href="https://www.sonarqube.org/downloads/%EF%BC%8C%E6%88%91%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF7.0%E7%89%88%E6%9C%AC">https://www.sonarqube.org/downloads/，我使用的是7.0版本</a></p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>需要事先装好mysql，需要5.6以上版本，我这边安装的是5.7.30</p><h2 id="创建sonar用户"><a href="#创建sonar用户" class="headerlink" title="创建sonar用户"></a>创建sonar用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;sonar&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;sonar&#x27;</span>;</span><br><span class="line">CREATE DATABASE sonar CHARACTER SET UTF8;</span><br><span class="line">GRANT ALL PRIVILEGES ON sonar.* TO <span class="string">&#x27;sonar&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="创建sonar系统用户"><a href="#创建sonar系统用户" class="headerlink" title="创建sonar系统用户"></a>创建sonar系统用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd sonar</span><br><span class="line">passwd sonar</span><br></pre></td></tr></table></figure><h2 id="安装sonar"><a href="#安装sonar" class="headerlink" title="安装sonar"></a>安装sonar</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">unzip sonarqube-7.0.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置文件conf/sonar.properties</span></span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://192.168.37.137:3306/sonar?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=<span class="literal">true</span>&amp;useConfigs=maxPerformance&amp;useSSL=<span class="literal">false</span></span><br><span class="line">sonar.web.host=0.0.0.0</span><br><span class="line">sonar.web.context=</span><br></pre></td></tr></table></figure><h2 id="启动sonar"><a href="#启动sonar" class="headerlink" title="启动sonar"></a>启动sonar</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改变权限</span></span><br><span class="line">chown -R sonar:sonar /usr/<span class="built_in">local</span>/sonarqube-7.0</span><br><span class="line">su sonar</span><br><span class="line">/usr/<span class="built_in">local</span>/sonarqube-7.0/bin/linux-x86-64/sonar.sh start</span><br></pre></td></tr></table></figure><p>最后通过ip:9000访问，默认用户名admin，密码admin</p><h2 id="安装中文插件"><a href="#安装中文插件" class="headerlink" title="安装中文插件"></a>安装中文插件</h2><p>下载sonar-l10n-zh-plugin-1.16.jar插件 <a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/tag/sonar-l10n-zh-plugin-1.16">https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/tag/sonar-l10n-zh-plugin-1.16</a><br>将插件放到/usr/local/sonarqube-7.0/extensions/plugins目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/sonarqube-7.0/bin/linux-x86-64/sonar.sh restart</span><br></pre></td></tr></table></figure><h2 id="安装SonarScanner"><a href="#安装SonarScanner" class="headerlink" title="安装SonarScanner"></a>安装SonarScanner</h2><p>下载 <a href="https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/">https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip sonar-scanner-cli-4.4.0.2170-linux.zip</span><br><span class="line"><span class="comment">#/etc/profile 配置环境变量</span></span><br><span class="line"><span class="built_in">export</span> SONAR_SCANNER_HOME=/usr/<span class="built_in">local</span>/sonar-scanner-4.4.0.2170-linux</span><br><span class="line">PATH=<span class="variable">$&#123;SONAR_SCANNER_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="comment">#使生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">sonar-scanner -v</span><br></pre></td></tr></table></figure><h2 id="配置sonar-scanner，关联sonarqube"><a href="#配置sonar-scanner，关联sonarqube" class="headerlink" title="配置sonar-scanner，关联sonarqube"></a>配置sonar-scanner，关联sonarqube</h2><p>在/usr/local/sonar-scanner-4.4.0.2170-linux/conf/sonar-scanner.properties中添加如下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar.host.url=http://127.0.0.1:9000</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://192.168.37.137:3306/sonar?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8</span><br></pre></td></tr></table></figure><h2 id="扫描代码"><a href="#扫描代码" class="headerlink" title="扫描代码"></a>扫描代码</h2><p>在此之前需要安装需要的插件，例如sonar-java-plugin、sonar-findbugs-plugin、sonar-pdfreport-plugin-3.0.2等<br>在需要扫描的项目根目录下创建sonar-project.properties</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># must be unique in a given SonarQube instance</span></span><br><span class="line">sonar.projectKey=myproject</span><br><span class="line"><span class="comment"># this is the name displayed in the SonarQube UI</span></span><br><span class="line">sonar.projectName=myproject</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.</span></span><br><span class="line"><span class="comment"># Since SonarQube 4.2, this property is optional if sonar.modules is set. </span></span><br><span class="line"><span class="comment"># If not set, SonarQube starts looking for source code from the directory containing </span></span><br><span class="line"><span class="comment"># the sonar-project.properties file.</span></span><br><span class="line">sonar.sources=.</span><br><span class="line">sonar.java.binaries=target/classes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding of the source code. Default is default system encoding</span></span><br><span class="line"><span class="comment">#sonar.sourceEncoding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pdf</span></span><br><span class="line"><span class="comment">#sonar.pdf.username=admin</span></span><br><span class="line"><span class="comment">#sonar.pdf.password=admin</span></span><br><span class="line"><span class="comment">#sonar.pdf.skip=false</span></span><br></pre></td></tr></table></figure><p>执行sonar-scanner，完成后在sonarqube的web界面查看</p>]]></content>
      
      
      <categories>
          
          <category> SonarQube </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置阿里云yum源</title>
      <link href="2020/08/09/CentOS7%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91yum%E6%BA%90/"/>
      <url>2020/08/09/CentOS7%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91yum%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#永久关闭，将SELINUX=disabled ，需要重启后生效</span></span><br><span class="line">vi /etc/selinux/config</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次生产内存泄漏问题</title>
      <link href="2020/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
      <url>2020/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>早上收到生产服务器JVM堆内存占用率达到80%的邮件报警,来到公司用Java VisualVM分析。</p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/a1.png"><br>从图上可以看到有个idle_connection_reaper的线程占用内存达到79%<br>然后我们dump下hprof文件分析看看<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/a2.png"><br>这个线程应该跟阿里云oss代码相关</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/a3.png"><br>用MemoryAnalyzer工具再次分析一下hprof文件<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/a4.png"><br>这个org.apache.http.impl.conn.PoolingHttpClientConnectionManager实例占用过多的内存<br>从com.aliyun.oss.ClientBuilderConfiguration可以判断跟oss连接有关，找了oss相关的连接代码<br>果然开发在new OSSClient的时候，没有调用ossClient.shutdown,造成内存泄漏</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mailx通过465端口发送邮件</title>
      <link href="2020/08/05/Mailx%E9%80%9A%E8%BF%87465%E7%AB%AF%E5%8F%A3%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>2020/08/05/Mailx%E9%80%9A%E8%BF%87465%E7%AB%AF%E5%8F%A3%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于阿里云关闭了25端口，所以需要修改mailx端口改为465发送邮件</p><a id="more"></a><h2 id="安装Mailx"><a href="#安装Mailx" class="headerlink" title="安装Mailx"></a>安装Mailx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y mailx</span><br></pre></td></tr></table></figure><h2 id="开启SMTP服务并获取授权码"><a href="#开启SMTP服务并获取授权码" class="headerlink" title="开启SMTP服务并获取授权码"></a>开启SMTP服务并获取授权码</h2><p>登录邮箱-设置-账户<br>1、开启SMTP服务<br>2、获取授权码</p><h2 id="设置mail-rc"><a href="#设置mail-rc" class="headerlink" title="设置mail.rc"></a>设置mail.rc</h2><p>在/etc/mailx.rc最后一行添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> from=XXXXXXXX@qq.com</span><br><span class="line"><span class="built_in">set</span> smtp=smtps://smtp.qq.com:465</span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=XXXXXXXXX@qq.com</span><br><span class="line"><span class="comment">#邮箱SMTP授权码</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=*********</span><br><span class="line"><span class="built_in">set</span> smtp-auth-login</span><br><span class="line"><span class="built_in">set</span> ssl-verify=ignore</span><br><span class="line"><span class="built_in">set</span> nss-config-dir=/tmp/.certs</span><br></pre></td></tr></table></figure><h2 id="设置证书"><a href="#设置证书" class="headerlink" title="设置证书"></a>设置证书</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/.certs/</span><br><span class="line"><span class="built_in">echo</span> -n | openssl s_client -connect smtp.qq.com:465 | sed -ne <span class="string">&#x27;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&#x27;</span> &gt; ~/.certs/qq.crt</span><br><span class="line">certutil -A -n <span class="string">&quot;GeoTrust SSL CA&quot;</span> -t <span class="string">&quot;C,,&quot;</span> -d ~/.certs -i ~/.certs/qq.crt</span><br><span class="line">certutil -A -n <span class="string">&quot;GeoTrust Global CA&quot;</span> -t <span class="string">&quot;C,,&quot;</span> -d ~/.certs -i ~/.certs/qq.crt</span><br><span class="line"><span class="built_in">cd</span>  /root/.certs/</span><br><span class="line">certutil -A -n <span class="string">&quot;GeoTrust SSL CA - G3&quot;</span> -t <span class="string">&quot;Pu,Pu,Pu&quot;</span> -d ~/.certs/./ -i qq.crt</span><br><span class="line">certutil -L -d /root/.certs</span><br><span class="line">cp -a /root/.certs/ /tmp/</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;content&quot;</span> | mail -s <span class="string">&quot;title&quot;</span> XXXXXXXX@qq.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mailx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab配置邮箱</title>
      <link href="2020/07/13/GitLab%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/"/>
      <url>2020/07/13/GitLab%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="开启相应的邮箱服务"><a href="#开启相应的邮箱服务" class="headerlink" title="开启相应的邮箱服务"></a>开启相应的邮箱服务</h2><p>我这边使用的qq邮箱，获取授权码</p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="/2020/07/13/GitLab%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/a1.png"></p><h2 id="配置gitlab-rb"><a href="#配置gitlab-rb" class="headerlink" title="配置gitlab.rb"></a>配置gitlab.rb</h2><p>vim /etc/gitlab/gitlab.rb</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一处</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_enable&#x27;</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_address&#x27;</span>] = <span class="string">&quot;smtp.qq.com&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_port&#x27;</span>] = 465</span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_user_name&#x27;</span>] = <span class="string">&quot;你的邮箱@qq.com&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_password&#x27;</span>] = <span class="string">&quot;授权码&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_domain&#x27;</span>] = <span class="string">&quot;qq.com&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_authentication&#x27;</span>] = <span class="string">&quot;login&quot;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_enable_starttls_auto&#x27;</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_tls&#x27;</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二处</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_enabled&#x27;</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_from&#x27;</span>] = <span class="string">&#x27;你的邮箱@qq.com&#x27;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_display_name&#x27;</span>] = <span class="string">&#x27;gitlab server&#x27;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_reply_to&#x27;</span>] = <span class="string">&#x27;你的邮箱@qq.com&#x27;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_subject_suffix&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>配置完成后</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitlab-ctl stop</span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输入 gitlab-rails console 进入控制台</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Notify.test_email(<span class="string">&#x27;接收方邮件地址&#x27;</span>,<span class="string">&#x27;邮件标题&#x27;</span>,<span class="string">&#x27;邮件内容&#x27;</span>).deliver_now</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR Maven JVM terminated unexpectedly with exit code 137</title>
      <link href="2020/07/13/ERROR-Maven-JVM-terminated-unexpectedly-with-exit-code-137/"/>
      <url>2020/07/13/ERROR-Maven-JVM-terminated-unexpectedly-with-exit-code-137/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>jenkins利用maven打包，job控制台出现ERROR Maven JVM terminated unexpectedly with exit code 137<br>这是由于机器内存不足导致的</p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云PTS压测大量请求出现502、503</title>
      <link href="2020/07/13/%E9%98%BF%E9%87%8C%E4%BA%91PTS%E5%8E%8B%E6%B5%8B%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E5%87%BA%E7%8E%B0502%E3%80%81503/"/>
      <url>2020/07/13/%E9%98%BF%E9%87%8C%E4%BA%91PTS%E5%8E%8B%E6%B5%8B%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E5%87%BA%E7%8E%B0502%E3%80%81503/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在阿里云文档那边找到了一篇类似的文档说这种情况可能是由于SLB单IP限流导致的，我在压测的时候来源IP大概有5个，然后提了工单问了技术，看看是不是SLB限流导致的，但阿里云那边说不是SLB导致的。接着我就一边压测一边看后端应用服务器日志，我的整个项目是SLB分发到ECS服务器的tomcat上。</p><a id="more"></a><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>压测的时候发现日志输出错误日志了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javax.servlet.ServletException: org.springframework.data.redis.RedisConnectionFailureException: Cannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisExhaustedPoolException: Could not get a resource since the pool is exhausted</span><br><span class="line">    at org.apache.jsp.api.cand.intv.ajaxHandInInfo_jsp._jspService(ajaxHandInInfo_jsp.java:651)</span><br><span class="line">    at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:71)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)</span><br><span class="line">    at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:477)</span><br><span class="line">    at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:385)</span><br><span class="line">    at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:329)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at com.up72.filter.ParamFilter.doFilter(ParamFilter.java:25)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:176)</span><br><span class="line">    at org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)</span><br><span class="line">    at org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)</span><br><span class="line">    at org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:389)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200)</span><br><span class="line">    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:151)</span><br><span class="line">    at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:81)</span><br><span class="line">    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357)</span><br><span class="line">    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)</span><br><span class="line">    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)</span><br><span class="line">    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)</span><br><span class="line">    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)</span><br><span class="line">    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)</span><br><span class="line">    at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:690)</span><br><span class="line">    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)</span><br><span class="line">    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)</span><br><span class="line">    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)</span><br><span class="line">    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)</span><br><span class="line">    at org.apache.coyote.AbstractProtocol<span class="variable">$ConnectionHandler</span>.process(AbstractProtocol.java:868)</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint<span class="variable">$SocketProcessor</span>.doRun(NioEndpoint.java:1590)</span><br><span class="line">    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class="line">    at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>大概从第一行就可以看出jedis在连接redis的时候获取不到资源。然后我看了一下阿里云redis连接数远远没有达到最大连接数的上限，有很长一段时间停留在1000，基本可以判断是代码那边设置了最大连接数。<br>找了redis配置，redis.pool.maxTotal=1000是这个配置导致的</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes笔记二(pod控制器的创建与管理)</title>
      <link href="2020/06/03/Kubernetes%E7%AC%94%E8%AE%B0%E4%BA%8C-pod%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
      <url>2020/06/03/Kubernetes%E7%AC%94%E8%AE%B0%E4%BA%8C-pod%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>pod控制器由控制器管理器kube-controller-manager组件提供，pod控制器主要用于对pod创建、修改、删除等操作。常见的pod控制器有Replication Controller、ReplicaSet、Deployment、DaemonSet、StatefulSet、Job、CronJob。</p><a id="more"></a><h2 id="ReplicaSet控制器"><a href="#ReplicaSet控制器" class="headerlink" title="ReplicaSet控制器"></a>ReplicaSet控制器</h2><p>ReplicaSet控制器主要用于保证pod的副本数在任何时候都能精确满足我们的期望值<br>（1）ReplicaSet控制器主要功能<br>    1）保证pod的副本数满足期望值<br>    2）保证pod健康运行<br>    3）弹性伸缩<br>（2）资源清单<br>ReplicaSet控制器资源定义与pod相似，其spec字段嵌套的子字段及作用如下<br>    replicas：期望的pod副本数目<br>    selector：当前控制器匹配pod对象的标签选择器，支持matchLabels和matchExpressions两种匹配机制<br>    template：用于创建pod时使用的pod资源模版<br>    minReadySeconds：新建的pod在启动多长时间后，容器未发生崩溃等异常情况，则视为就绪，默认为0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-replicaset</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: twf/nginx:v1</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br></pre></td></tr></table></figure><p>（3）维护期望的pod副本数目<br>修改一个pod的label后，ReplicaSet发现pod副本数目减上了，会重新再创建一个</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改期望数</span></span><br><span class="line">kubectl scale rs <span class="built_in">test</span>-replicaset --replicas=3</span><br><span class="line">kubectl label pods <span class="built_in">test</span>-replicaset-t6lr6 app=twf --overwrite</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>（4）删除replicaset控制器资源<br>使用“kubectl delete”命令删除replicaset对象时默认会一并删除其管控的pod对象，有时，这些pod资源可能不是replicaset控制器创建的，此时可以使用“–cascade=false”选项，取消级联，删除相关的pod对象。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除名称为test-replicaset的replicaset控制器，并取消与pod的级联</span></span><br><span class="line">kubectl delete replicaset <span class="built_in">test</span>-replicaset --cascade=<span class="literal">false</span></span><br><span class="line"><span class="comment">#kubectl get pods -l app=test-rep</span></span><br></pre></td></tr></table></figure><h2 id="Deployment控制器"><a href="#Deployment控制器" class="headerlink" title="Deployment控制器"></a>Deployment控制器</h2><p>Deployment是在RS控制器之上的，可为Pod和ReplicaSet资源提供声明式更新的一种控制器；Deployment控制器的主要作用还是为了Pod资源的健康运行，但大部分功能可以通过调节ReplicaSet控制器来实现，同时还添加了事件和状态查看、回滚、版本记录、暂停和启动、多种自动更新方案等特性。<br>（1）创建Deployment控制器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: twf/nginx:v2</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br></pre></td></tr></table></figure><p>（2）Deployment控制器更新策略<br>相对于RS控制器，Deployment控制器更新只需要用于指定在pod模版中需要修改的内容，剩下的步骤由其自动完成<br>Deployment控制器也支持两种更新策略，重新创建和滚动更新，默认更新策略是滚动更新<br>    1）重新创建（recreate）：重新创建是先删除现有的pod对象，然后由控制器基于新模版重新创建出新版本的资源对象<br>    2）滚动更新（rolling update）：在删除一部分旧版本pod的同时。补充新建一部分新版本的pod对象。<br>（3）更新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更新镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment <span class="built_in">test</span>-deployment nginx=twf/nginx:v1 --record</span><br><span class="line"><span class="comment">#暂停更新</span></span><br><span class="line">kubectl rollout pause deployments <span class="built_in">test</span>-deployment</span><br><span class="line"><span class="comment">#查看更新过程中的状态信息</span></span><br><span class="line">kubectl rollout status deployments <span class="built_in">test</span>-deployment</span><br><span class="line"><span class="comment">#继续之前的更新</span></span><br><span class="line">kubectl rollout resume deployments <span class="built_in">test</span>-deployment</span><br></pre></td></tr></table></figure><p>（4）回滚<br>在更新过程中，如果更新失败时，可能需要回滚到之前的版本或者指定的版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#回滚到上个版本</span></span><br><span class="line">kubectl rollout undo deployments <span class="built_in">test</span>-deployment</span><br><span class="line"><span class="comment">#查看历史版本</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployments <span class="built_in">test</span>-deployment</span><br><span class="line"><span class="comment">#回退指定版本</span></span><br><span class="line">kubectl rollout undo deployments <span class="built_in">test</span>-deployment --to-revision=1</span><br></pre></td></tr></table></figure><h2 id="DaemonSet控制器"><a href="#DaemonSet控制器" class="headerlink" title="DaemonSet控制器"></a>DaemonSet控制器</h2><p>DaemonSet确保全部（或者一些）Node上运行一个pod副本，当有Node加入集群时，也会为他们新增一个pod，当Node从集群中剔除时，也会回收这些pod。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-daemonset</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: twf/nginx:v1</span><br></pre></td></tr></table></figure><h2 id="Job控制器"><a href="#Job控制器" class="headerlink" title="Job控制器"></a>Job控制器</h2><p>job负责处理任务，即仅执行一次的任务，它保证处理任务的一个或多个pod成功结束<br>job的RestartPolicy仅支持Never和OnFailure两种</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-job</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: job-demo</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: Never</span><br><span class="line">      containers:</span><br><span class="line">      - name: busybox</span><br><span class="line">        image: busybox</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="string">&quot;bin/sh&quot;</span></span><br><span class="line">        - <span class="string">&quot;-c&quot;</span></span><br><span class="line">        - <span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo <span class="variable">$1</span>; done&quot;</span></span><br></pre></td></tr></table></figure><h2 id="CronJob控制器"><a href="#CronJob控制器" class="headerlink" title="CronJob控制器"></a>CronJob控制器</h2><p>CronJob其实就是在Job的基础上加了时间调度，也就是周期性的在给定时间执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-cronjob</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  successfulJobsHistoryLimit: 2</span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          restartPolicy: OnFailure</span><br><span class="line">          containers:</span><br><span class="line">          - name: busybox</span><br><span class="line">            image: busybox</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - <span class="string">&quot;bin/sh&quot;</span></span><br><span class="line">            - <span class="string">&quot;-c&quot;</span></span><br><span class="line">            - <span class="string">&quot;for i in 9 8 7 ; do echo <span class="variable">$i</span>; done&quot;</span></span><br></pre></td></tr></table></figure><p>spec.successfulJobsHistoryLimit和spec.failedJobHistoryLimit表示历史限制，可选字段，它们指定了可以保留多少完成和失败的Job，默认没有限制，建议设置</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes笔记一(pod资源创建与管理)</title>
      <link href="2020/05/30/Kubernetes%E7%AC%94%E8%AE%B0%E4%B8%80-pod%E8%B5%84%E6%BA%90%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
      <url>2020/05/30/Kubernetes%E7%AC%94%E8%AE%B0%E4%B8%80-pod%E8%B5%84%E6%BA%90%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>  pod是kubernetes最重要的基本概念，它是kubernetes系统中最小的调度单位。每一个pod都有一个特殊的pause根容器，kubernetes为每个pod都提供了一个根容器，如果单独对一组容器进行管理，那么一个容器死亡，到底算不算整体死亡，为了解决这个难题，巧妙的设计了pause根容器对业务容器进行管理，所有的业务容器共享pause容器的IP、挂载的volume，简化了容器之间的通信问题。<br>  pod分为普通的pod和静态pod。普通pod一旦被创建，就会被放入etcd中存储，随后被kubernetes master调度到node上进行绑定，接着pod被node上的kubelet进程实例化成一组相关的docker容器并启动。静态pod比较特殊，它并不存储在etcd里，而是被保存在某个具体node上的一个具体文件中。</p><a id="more"></a><h2 id="pod管理"><a href="#pod管理" class="headerlink" title="pod管理"></a>pod管理</h2><p>Pod在kubernetes中也是一种资源，pod资源的定义是通过“apiVersion”、“kind”、“metadata”、“spec”、“status”五个部分组成，除了“status”字段中的信息是系统自动生成外，其余各字段都需要管理员定义。<br>（1）Containers中关于容器的字段常用字段有：<br>    1）name：必选字段，用于指定容器名称<br>    2）image：可选字段，定义容器运行时的镜像，但是自助式pod不能省略此字段<br>    3）imagePullPolicy：用于指定镜像的获取策略，主要的值有：<br>        Always：当镜像不存在或不是最新镜像时，则从指定仓库中拉取镜像<br>        IfNotPresent：当需要运行的镜像在本地不存在时，则从指定的仓库中下载镜像<br>        Nerver：仅使用本地镜像，不去仓库中下载镜像<br>（2）暴露pod中服务的端口<br>    Containers字段中的ports字段用于暴露容器的端口，容器的ports字段的值是一个列表，由一到多个端口对象组成，常用的嵌套字段如下：<br>        1）containerPort：必选字段，指定在Pod对象的ip地址上暴露的容器端口<br>        2）name：当前容器端口的名称，需在当前pod中唯一，此端口可以被Service资源调用<br>        3）protocol：端口相关的协议，值为tcp或udp<br>    Pod对象的ip地址仅可在当前集群内可达，集群外是无法访问的，当集群外需要访问pod中的服务时，可定义node节点的IP地址及端口，将pod中的服务端口映射到node上，外部通过node节点访问，一般都不建议这样做，常用的做法是通过service的NodePort模式访问pod内的服务<br>        4）hostPort：主机端口<br>        5）hostIP：主机端口要绑定主机ip</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: twf/nginx:v1</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">      protocol: TCP</span><br></pre></td></tr></table></figure><p>（3）为pod的容器定义环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: env-test</span><br><span class="line">  labels:</span><br><span class="line">    app: env</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-env</span><br><span class="line">    image: twf/nginx:v1</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    env:</span><br><span class="line">    - name: NGINX_ENV</span><br><span class="line">      value: <span class="string">&#x27;twf-v1&#x27;</span></span><br><span class="line">    - name: NGINX_PORT</span><br><span class="line">      value: <span class="string">&#x27;80&#x27;</span></span><br></pre></td></tr></table></figure><p>（4）为pod容器共享节点的网络名称空间<br>通过hostNetwork设置true</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostnetwork</span><br><span class="line">  labels:</span><br><span class="line">    app: hostnetwork</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-hostnetwork</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">  hostNetwork: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#node节点查看暴露的服务</span></span><br><span class="line">netstat -anpt |grep 80</span><br></pre></td></tr></table></figure><p>（5）pod资源中安全设置<br>Pod对象的安全定义在spec.securityContext字段中，容器的安全定义在spec.containers.securityContext字段中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-busybox</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 3600&quot;</span>]</span><br><span class="line">    securityContext:</span><br><span class="line">      runAsNonRoot: <span class="literal">true</span></span><br><span class="line">      runAsUser: 1000</span><br><span class="line">      allowPrivilegeEscalation: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">kubectl <span class="built_in">exec</span> <span class="built_in">test</span>-busybox -it -- ps</span><br></pre></td></tr></table></figure><h2 id="pod中标签与标签选择器的定义与管理"><a href="#pod中标签与标签选择器的定义与管理" class="headerlink" title="pod中标签与标签选择器的定义与管理"></a>pod中标签与标签选择器的定义与管理</h2><p>Pod中标签（label）的主要功能就是对pod进行分类管理，从而提升运维及管理效率；而标签选择器（label selector）则可以挑选出符合过滤条件的资源完成需要的操作。<br>标签是键值类型的数据，能够附加于kubernetes的任何资源对象上，标签可以在创建资源时指定也可以按需添加，一个对象可以拥有多个标签。<br>（1）pod资源的标签管理<br>Pod资源的标签在metadata.labels中定义</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在pod资源中定义标签</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: dev</span><br><span class="line">    version: v1.0</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"><span class="comment">#查看所有的标签</span></span><br><span class="line">kubectl get pods --show-labels</span><br><span class="line"><span class="comment">#列出有指定标签的资源信息</span></span><br><span class="line">kubectl get pods -L env</span><br></pre></td></tr></table></figure><p>当pod创建好之后，也可以通过“kubectl label”命令为pod资源添加标签，如果pod中已经有了指定键名的标签，可以通过“–overwrite”命令强制覆盖原有标签</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为指定pod资源添加标签</span></span><br><span class="line">kubectl label pods <span class="built_in">test</span>-nginx app=cache</span><br><span class="line"><span class="comment">#修改指定pod资源标签</span></span><br><span class="line">kubectl label pods <span class="built_in">test</span>-nginx env=pro --overwrite</span><br></pre></td></tr></table></figure><p>（2）标签选择器的使用<br>标签选择器用于表达标签的查询条件或选择标准，在使用标签选择器时，要注意多个选择器之间的关系为“与”操作，使用空值的标签选择器意味着每个资源对象都被选中，空的标签选择器无法选出任何内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出app不等于cache的资源</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;app!=cache&quot;</span> --show-labels</span><br><span class="line"><span class="comment">#列出标签app不等于cache且run等于nginx-deploy的pod资源</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;app!=cache,run=nginx-deploy&quot;</span> -L run,app</span><br></pre></td></tr></table></figure><p>kubernetes api支持基于等值关系和集合关系的选择器，基于集合关系的标签选择器支持in、notin、exists三种操作符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出标签app为cache或者backend的pod资源</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;app in (cache,backend)&quot;</span> -L app</span><br><span class="line"><span class="comment">#列出不等于env标签的pod资源</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;!env&quot;</span> --show-labels</span><br></pre></td></tr></table></figure><h2 id="Pod节点选择器"><a href="#Pod节点选择器" class="headerlink" title="Pod节点选择器"></a>Pod节点选择器</h2><p>Pod节点选择器nodeSelector能够让pod对象基于集群中的工作节点的标签来挑选运行pod的node节点。在使用pod节点选择器之前，需要为node资源添加标签，添加标签的方法同为pod资源添加标签方法相同。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为两个node节点分别添加标签</span></span><br><span class="line">kubectl label nodes k8s-node1 server=nginx</span><br></pre></td></tr></table></figure><p>Pod资源中定义节点选择器时通过spec.nodeSelector字段定义</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个pod资源，让其运行在node1节点上</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata: </span><br><span class="line">  name: <span class="built_in">test</span>-nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.12</span><br><span class="line">  nodeSelector:</span><br><span class="line">    server: nginx</span><br></pre></td></tr></table></figure><h2 id="Pod资源注解"><a href="#Pod资源注解" class="headerlink" title="Pod资源注解"></a>Pod资源注解</h2><p>除了标签之外，Pod与其他各种资源还能使用资源注解（annotation）；与标签类似，注解也是通过键值类型的数据，注解仅用于为资源提供元数据信息。而资源的注解可由用户手动添加，也可由工具程序自动附加使用。<br>（1）管理资源注解<br>资源注解的创建可在定义资源时使用metadata.annotations字段指定，也可在资源创建后通过“kubectl annotate”命令进行附加。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义资源时添加资源注解</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-annotation</span><br><span class="line">  labels:</span><br><span class="line">    env: dev</span><br><span class="line">  annotations:</span><br><span class="line">    server-explain: nginx server is node1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.12</span><br><span class="line">  nodeSelector:</span><br><span class="line">    server: nginx</span><br><span class="line">    </span><br><span class="line"><span class="comment">#为创建好的资源添加资源注解</span></span><br><span class="line">kubectl annotate pods <span class="built_in">test</span>-annotation auth=<span class="string">&quot;123&quot;</span> </span><br></pre></td></tr></table></figure><p>（2）查看资源注解<br>资源注解的查看可以通过“kubectl describe”查看，或者pod导出为yaml格式查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看资源注解</span></span><br><span class="line">kubectl describe pods <span class="built_in">test</span>-annotation</span><br></pre></td></tr></table></figure><h2 id="Pod资源存活性检测"><a href="#Pod资源存活性检测" class="headerlink" title="Pod资源存活性检测"></a>Pod资源存活性检测</h2><p>kubernetes对容器的存活性检测能够发现不可能用状态的容器，并对该容器进行重启等操作。jubernetes存活性探测的主要方法有ExecAction、TCPSocketAction、HTTPGetAction。<br>（1）使用exec探针检测容器的存活性<br>Exec探针通过在目标容器中执行由用户自定义的命令来判断容器的健康状态，exec探针由“spec.containers.livenessProbe.exec”字段组成，该字段只有一个“command”属性来定义要执行的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    args: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tem/test123;sleep 60;rm -rf /tem/test123;sleep 300&quot;</span>]</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;/tem/test123&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#一段时间后查看pod重启情况</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>（2）使用http探针<br>基于http的探测是向目标容器发起一个http请求，根据其相应码进行结果的判定，该字段通过“spec.containers.livenessProbe.httpGet”字段定义，相关的字段有：<br>    1）port：必选字段，用于定义请求的端口<br>    2）httpHeaders：自定义的请求报文首部<br>    3）path：请求http资源的路径<br>    4）scheme：建立连接使用的协议，默认为http</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-http</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    lifecycle:</span><br><span class="line">      portStart:</span><br><span class="line">        <span class="built_in">exec</span>:</span><br><span class="line">          <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo testhttp &gt; /usr/share/nginx/html/testhttp&quot;</span>]</span><br><span class="line">  livenessProbe:</span><br><span class="line">    httpGet:</span><br><span class="line">      port: http</span><br><span class="line">      path: /testhttp</span><br><span class="line">      scheme: HTTP</span><br></pre></td></tr></table></figure><p>（3）使用TCP探针<br>基于TCP的存活性探测是用于向容器的特定端口发起TCP请求并尝试建立连接建立结果判定。该探针的使用主要是通过“spec.containers.livenessProbe.tcpSocket”字段来定义。主要字段有：<br>    1）host：请求连接的目标IP地址，默认为Pod ip<br>    2）port：必选字段，请求连接的目标端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 15</span><br><span class="line">      periodSeconds: 20</span><br></pre></td></tr></table></figure><p>（4）存活性探测的行为属性<br>除了探测器自身字段属性行为，还可以配置一些其他的行为属性，其他的行为属性字段在“spec.containers.livenessProbe”字段下设置，主要有：<br>    1）initialDelySeconds：设置存活性探测的延迟时长，即容器启动多久之后开始第一次探测，默认为0。<br>    2）timeoutSeconds：存活性探测的超时时长，默认为1s，最小值也为1s。<br>    3）periodSeconds：存活性探测的频度，默认为10s，最小值可设置为1s。<br>    4）successThreshold：处于失败状态时，探测器操作连续多少次的成功才被认为是通过检测，默认为1。<br>    5）failureThreshold：处于成功状态时，探测器操作至少连续多少次的失败才被视为是检测不通过。默认为3。<br>这些属性设置后都可以通过“kubectl describe”命令查看，各项设置在命令输出的liveness字段中，delay为存活性探测的延迟时长，timeout为存活性探测的超时时长，period为存活性探测的频率，success为失败状态转为成功状态的探测成功次数，failure为成功状态转为失败状态时的探测失败次数。</p><h2 id="Pod的就绪性探测"><a href="#Pod的就绪性探测" class="headerlink" title="Pod的就绪性探测"></a>Pod的就绪性探测</h2><p>Pod的就绪性探测主要用于在探测到容器尚未就绪时，触发依赖于其就绪状态的操作，确保不会有客户端请求接入此pod操作。就绪性探测也支持Exec、HTTP GET和TCP Socket三种探测方式。就绪性探测的使用方法同存活性探测使用方法基本相同，就绪性探测主要通过“pod.spec.containers.readinessProbe”字段设置<br>在未定义就绪性的Pod对象在Pod进入Running状态后将立即就绪</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 15</span><br><span class="line">      periodSeconds: 20</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logrotate使用简介</title>
      <link href="2020/05/29/logrotate%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
      <url>2020/05/29/logrotate%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>  随着时间的增长和业务的扩张，对于忙碌的服务器来说，日志文件的大小会增长极快，服务器会很快消耗磁盘空间，而且系统人员查看单个庞大的文件也及其困难。<br>  logrotate是一个日志管理工具，它可以对日志进行切割、轮替、压缩等。</p><a id="more"></a><h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><p>1）/etc/logrotate.conf<br>logrotate主要配置文件<br>2)/etc/logrotate.d<br>是个目录，我们可以将自己需要滚动的日志配置放到这个下面<br>3)/var/lib/logrotate/logrotate.status<br>记录logrotate滚动状态的信息</p><h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><table><thead><tr><th align="left">配置参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">monthly</td><td align="left">指定日志按月轮替，可选”daily”,”weekly”,”yearly”</td></tr><tr><td align="left">rotate 5</td><td align="left">一次将存储5个归档日志，当出现第6个日志，删除时间最久的归档日志</td></tr><tr><td align="left">compress</td><td align="left">在轮替完成后，将以轮替的归档日志进行压缩</td></tr><tr><td align="left">delaycompress</td><td align="left">经常与compress一起使用，delaycompress指示logrotate不要将最近的归档压缩，压缩将在下一次轮替周期进行</td></tr><tr><td align="left">missingok</td><td align="left">日志轮替期间，任何错误都被忽略</td></tr><tr><td align="left">notifempty</td><td align="left">如果日志为空，轮替不进行</td></tr><tr><td align="left">create 644 root root</td><td align="left">指定新创建日志的权限，同时logrotate也会重命名原始文件</td></tr><tr><td align="left">postrotate/endscript</td><td align="left">在所有指令完成后，postrotate和endscript里面指定的命令将被执行</td></tr></tbody></table><h2 id="对redis日志进行切割、轮替"><a href="#对redis日志进行切割、轮替" class="headerlink" title="对redis日志进行切割、轮替"></a>对redis日志进行切割、轮替</h2><p>vim /etc/logrotate.d/redis</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/src/redis-5.0.3/logs/redis.log &#123;</span><br><span class="line">        rotate 5</span><br><span class="line">        create</span><br><span class="line">        daily</span><br><span class="line">        dateext</span><br><span class="line">        postrotate</span><br><span class="line">                /bin/<span class="built_in">kill</span> -HUP `cat /var/run/redis_6379.pid`</span><br><span class="line">        endscript</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#手动强制切割</span></span><br><span class="line">logrotate -v -f /etc/logrotate.d/redis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logrotate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVM逻辑卷管理</title>
      <link href="2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/"/>
      <url>2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是LVM"><a href="#什么是LVM" class="headerlink" title="什么是LVM"></a>什么是LVM</h2><p>  LVM是逻辑卷管理的简称，它可以对linux下的磁盘进行管理，LVM是建立在硬盘分区之上的一个逻辑层，主要可以对分区进行灵活的扩容、缩减等管理。</p><a id="more"></a><h2 id="为什么要使用LVM"><a href="#为什么要使用LVM" class="headerlink" title="为什么要使用LVM"></a>为什么要使用LVM</h2><p>  在日常工作和学习中，随着时间的增长和业务的扩展，我们的磁盘空间会越来越小，如果是普通分区，是不支持进行扩容的，一些扩容手段即使达到扩容效果，也是有潜在风险的。这时候我们就可以使用LVM，LVM将存储虚拟化，使用逻辑卷，你不会受限于物理磁盘的大小，即使后面磁盘剩余空间快不够了，也可以添加新的硬盘，进行在分区。</p><h2 id="LVM示意图"><a href="#LVM示意图" class="headerlink" title="LVM示意图"></a>LVM示意图</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a1.png"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>（1）准备添加一块20G硬盘<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a2.png"><br>（2）分3个分区<br>默认分区要改成LVM（8e）<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a3.png"><br>（3）物理卷管理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建物理卷</span></span><br><span class="line">pvcreate /dev/sdb5</span><br><span class="line">pvcreate /dev/sdb6</span><br><span class="line">pvcreate /dev/sdb7</span><br><span class="line"><span class="comment">#查看物理卷</span></span><br><span class="line">pvscan</span><br><span class="line">pvdisplay</span><br><span class="line"><span class="comment">#删除物理卷</span></span><br><span class="line">pvremove /dev/sdb5</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a4.png"><br>（4）卷组管理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立卷组,名称是scvg,将/dev/sdb5 /dev/sdb6 加入卷组</span></span><br><span class="line">vgcreate scvg /dev/sdb5 /dev/sdb6</span><br><span class="line"><span class="comment">#查看卷组</span></span><br><span class="line">vgdisplay</span><br><span class="line"><span class="comment">#扩容，将/dev/sdb7加入scvg卷组</span></span><br><span class="line">vgextend scvg /dev/sdb7</span><br><span class="line"><span class="comment">#缩减（不推荐）</span></span><br><span class="line">vgreduce scvg /dev/sdb7</span><br><span class="line"><span class="comment">#删除卷组</span></span><br><span class="line">vgremove scvg</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a5.png"><br>（5）逻辑卷管理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建逻辑卷，-L指定大小，-n指定逻辑卷名称</span></span><br><span class="line">lvcreate -L 3G -n sclv scvg</span><br><span class="line">lvcreate -L 2G -n sclv2 scvg</span><br><span class="line"><span class="comment">#查看lv</span></span><br><span class="line">lvdisplay</span><br><span class="line"><span class="comment">#调整逻辑卷大小</span></span><br><span class="line">lvresize -L 5G -n /dev/scvg/sclv</span><br></pre></td></tr></table></figure><p>（6）挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式化</span></span><br><span class="line">mkfs -t ext4 /dev/scvg/sclv</span><br><span class="line">mkfs -t ext4 /dev/scvg/sclv2</span><br><span class="line"><span class="comment">#创建文件，挂载</span></span><br><span class="line">mount /dev/scvg/sclv lv1</span><br><span class="line">mount /dev/scvg/sclv2 lv2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a6.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a7.png"><br>注意：如果分区已经挂载好了,LVM不需要卸载就可以进行扩展分区，使用lvresize调整逻辑卷大小后，使用resize2fs /dev/scvg/sclv2就可以使扩展的分区生效<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/27/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/a7.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘配额</title>
      <link href="2020/05/25/%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D/"/>
      <url>2020/05/25/%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是磁盘配额"><a href="#什么是磁盘配额" class="headerlink" title="什么是磁盘配额"></a>什么是磁盘配额</h2><p>  磁盘配额是用来限制用户和用户组的磁盘使用额度，简单的说就是可以限制用户、用户组在该分区下使用的文件大小和文件数量。<br>  注意：磁盘配额无法限制root用户</p><a id="more"></a><h2 id="磁盘配额相关术语"><a href="#磁盘配额相关术语" class="headerlink" title="磁盘配额相关术语"></a>磁盘配额相关术语</h2><p>blocks限制：限制用户、用户组在该分区下使用的文件大小<br>inode限制：限制用户、用户组在该分区下创建的最大文件数量<br>软限制：超出此范围会被警告，但仍可以继续使用和创建，超出部分会保存到宽限时间期<br>硬限制：最高限制，用户使用容量不能超过这个限制<br>宽限时间：当你的磁盘用量处于soft和hard之间时，系统会给予警告，但也会给一段时间让用户自行管理磁盘，这段时间就是宽限时间，如果到了宽限时间，用户没有进行任何磁盘管理，soft限值会被hard限值取代进行限制</p><h2 id="配置磁盘配额"><a href="#配置磁盘配额" class="headerlink" title="配置磁盘配额"></a>配置磁盘配额</h2><p>  我们现在对/dev/sdb5分区进行磁盘配额，对test1用户进行限制，一般对用户组限制的情况并不常见。<br>（1）关闭selinux</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><p>（2）查看系统是否启用了quota</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep CONFIG_QUOTA /boot/config-3.10.0-957.el7.x86_64</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/25/%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D/a1.png"><br>（3）查看系统是否安装了quota服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep quota</span><br><span class="line"><span class="comment">#没有的话，yum安装一下</span></span><br><span class="line">yum install -y quota</span><br></pre></td></tr></table></figure><p>（4）在分区上开启磁盘配额功能</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#临时生效</span></span><br><span class="line">mount -o remount,usrquota,grpquota /disk5</span><br><span class="line"><span class="comment">#永久生效，vim /etc/fstab 添加一行,需要重启系统</span></span><br><span class="line">/dev/sdb5  /disk5  ext4  defaults,usrquota,grpquota  0 0</span><br></pre></td></tr></table></figure><p>（5）建立磁盘配额配置文件<br>| 选项 | 说明 |<br>| :—- | :—- |<br>| -a | 扫描/etc/mtab文件中所有启动磁盘配额的分区，如果加入此参数，命令就不需要加入分区名 |<br>| -c | 不管原有的配置文件，重新扫描创建新的配置文件 |<br>| -u | 建立用户配额的配置文件 |<br>| -g | 建立组配额的配置文件 |<br>| -v | 显示扫描过程 |<br>| -m | 强制以读写方式扫描文件系统，一般扫描根分区时使用 |<br>| -f | 强制扫描文件系统，并写入新的配置文件，一般扫描新添加的硬盘分区时使用 |</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">quotacheck -avug</span><br></pre></td></tr></table></figure><p>（6）设置用户的磁盘配置<br>| 选项 | 说明 |<br>| :—- | :—- |<br>| -u | 指定用户 |<br>| -g | 指定组 |<br>| -t | 设置宽限时间 |<br>| -p | 复制配额限制 |</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">edquota -u test1</span><br></pre></td></tr></table></figure><p>（7）测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#记得给test1用户disk5权限</span></span><br><span class="line">chown test1 disk5</span><br><span class="line">切换到test1用户，写入数据</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/disk5/<span class="built_in">test</span> bs=1M count=10</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/25/%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D/a2.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/25/%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D/a3.png"><br>（7）其他命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询用户限额</span></span><br><span class="line">quota -vus test1</span><br><span class="line"><span class="comment">#复制配额,将test1的配额复制给test2</span></span><br><span class="line">edquota -p test1 -u test2</span><br><span class="line"><span class="comment">#设置宽限期间</span></span><br><span class="line">edquota -t</span><br><span class="line"><span class="comment">#非交互设定用户配额</span></span><br><span class="line">setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux增加swap分区</title>
      <link href="2020/05/25/Linux%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA/"/>
      <url>2020/05/25/Linux%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="准备前工作"><a href="#准备前工作" class="headerlink" title="准备前工作"></a>准备前工作</h2><p>准备好未分配的磁盘空间，由于swap分区必须是主分区，然后使用fdisk命令创建一个主分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line"><span class="comment">#使用n创建一个主分区，使用t将它改为swap类型，最后w保存</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="格式化swap分区"><a href="#格式化swap分区" class="headerlink" title="格式化swap分区"></a>格式化swap分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="使用swap分区"><a href="#使用swap分区" class="headerlink" title="使用swap分区"></a>使用swap分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon /dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="查看swap空间"><a href="#查看swap空间" class="headerlink" title="查看swap空间"></a>查看swap空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#发现swap变多了</span></span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><h2 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim /etc/fstab 添加以下一行</span></span><br><span class="line">/dev/sdb1  swap  swap  defaults  0  0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之SSH服务介绍</title>
      <link href="2020/05/23/Linux%E4%B9%8BSSH%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/05/23/Linux%E4%B9%8BSSH%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h2><p>SSH（Secure Shell Protocol）是一种网络协议，用于计算机之间的加密登录。在默认状态下，SSH服务提供两个服务，一个是类似于telnet远程联机的服务，另一个类似于FTP服务的sftp-server。</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不指定用户，默认root用户</span></span><br><span class="line">ssh 192.168.186.100</span><br><span class="line"><span class="comment">#指定用户登录</span></span><br><span class="line">ssh root@192.168.186.100</span><br><span class="line"><span class="comment">#修改过端口，指定端口登录</span></span><br><span class="line">ssh -p 520 192.168.186.100</span><br><span class="line">ssh -p 520 root@192.168.186.100</span><br></pre></td></tr></table></figure><h2 id="SSH登录原理"><a href="#SSH登录原理" class="headerlink" title="SSH登录原理"></a>SSH登录原理</h2><h3 id="密码登录"><a href="#密码登录" class="headerlink" title="密码登录"></a>密码登录</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/Linux%E4%B9%8BSSH%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/a1.png"></p><h3 id="密钥对登录"><a href="#密钥对登录" class="headerlink" title="密钥对登录"></a>密钥对登录</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/Linux%E4%B9%8BSSH%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/a2.png"></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>ssh主要配置文件是/etc/ssh/sshd_config</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认监听的端口</span></span><br><span class="line">Port 22</span><br><span class="line"><span class="comment">#默认监听的IP</span></span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line"><span class="comment">#允许root登录</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"><span class="comment">#客户端登录失败尝试次数</span></span><br><span class="line">MaxAuthTries 6</span><br><span class="line"><span class="comment">#是否进行DNS检测</span></span><br><span class="line">UseDNS no</span><br><span class="line"><span class="comment">#是否允许使用基于GSSAPI的用户认证</span></span><br><span class="line">GSSAPIAuthentication no</span><br><span class="line"><span class="comment">#限制可登录用户的办法</span></span><br><span class="line">AllowUsers user1 user2 user3</span><br><span class="line">DenyUsers user1 user2 user3</span><br><span class="line">AllowGroups user1 user2 user3</span><br><span class="line">DenyGroups user1 user2 user3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机添加硬盘</title>
      <link href="2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/"/>
      <url>2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="添加硬盘"><a href="#添加硬盘" class="headerlink" title="添加硬盘"></a>添加硬盘</h2><p>找到对应的虚拟机，编辑虚拟机，添加新的硬盘,然后开机</p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a1.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a2.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a4.png"></p><h2 id="对硬盘进行分区"><a href="#对硬盘进行分区" class="headerlink" title="对硬盘进行分区"></a>对硬盘进行分区</h2><p>（1）查看分区情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a5.png"><br>（2）对/dev/sdb进行分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a6.png"><br>（3）输入m，列出fdisk帮助<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a7.png"><br>（4）输入n进行分区<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a8.png"><br>先分主分区，选择p<br>分区号建议从前往后分，选择1<br>起始柱面从前往后，选择默认<br>柱面大小使用大小分，输入+2G，注意单位一定要加<br>这样主分区就分好了<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a9.png"><br>（5）继续输入n进行分区<br>进行扩展分区，选择e<br>分区号选择2<br>起始柱面选择默认<br>我们把剩余空间全分给扩展分区，柱面大小选择默认即可<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a10.png"><br>（6）继续输入n，进行分区<br>这时候选项就变了，输入l，对扩展分区进行分区<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a11.png"><br>把扩展分区的10G分给sdb5<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a12.png"><br>（7）输入p，查看分区情况<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a13.png"><br>（8）输入w，保存并退出<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a14.png"></p><h2 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs -t xfs /dev/sdb1</span><br><span class="line">mkfs -t xfs /dev/sdb5</span><br></pre></td></tr></table></figure><h2 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h2><p>先在根目录下创建2个目录，disk1和disk5，然后执行挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sdb1 /disk1</span><br><span class="line">mount /dev/sdb5 /disk5</span><br></pre></td></tr></table></figure><p>查看磁盘</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -hT</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a15.png"></p><h2 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h2><p>vim /ect/fstab</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分区            #挂载的目录                        #文件系统 #挂载选项      #是否备份      #是否使用fsck进行检测</span></span><br><span class="line">/dev/sdb1       /disk1                          xfs     defaults        1             0</span><br><span class="line">/dev/sdb5       /disk5                          xfs     defaults        1             0</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%A1%AC%E7%9B%98/a15.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keepalived简介</title>
      <link href="2020/05/05/Keepalived%E7%AE%80%E4%BB%8B/"/>
      <url>2020/05/05/Keepalived%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  keepalived是linux下的一个轻量级的高可用解决方案，高可用说的是通过专门的设计，从而减少停工时间，保证了系统的高度可用性。keepalived通过VRRP协议(虚拟路由冗余协议)实现系统的高可用，他的配置非常简单。</p><a id="more"></a><h2 id="VRRP协议工作原理"><a href="#VRRP协议工作原理" class="headerlink" title="VRRP协议工作原理"></a>VRRP协议工作原理</h2><p>  在网络环境中，主机间的通信都是通过静态路由或者网关来完成的，而主机之间的路由器一旦发生故障，通信就会断开，为了解决这个问题，就引入了CRRP协议。<br>  VRRP可以将两台或者多台物理路由器虚拟成一个虚拟路由，这个虚拟路由器通过虚拟ip对外提供服务。在虚拟路由内部多个路由器协同工作，同一时间只有一个路由器对外提供服务。对外提供服务的路由器被称为MASTER，其他路由器是BACKUP，当MASTER发生故障时，通过选举算法选出一个BACKUP成为新的MASTER，继续对外提供服务，整个故障切换对用户来说完全是透明的。<br>  每个虚拟路由器都有一个唯一的标识号VRID，在VRRP协议中，MASTER会通过广播方式发送VRRP数据包，BACKUP都会接受数据包信息，用来监控MASTER的监控状态，当MASTER发生故障时，BACKUP就无法接受到MASTER发过来的信息，于是就认定MASTER出现故障，然后多台BACKUP就会进行选举，优先级高的BACKUP就会成为新的MASTER，继续对外提供服务，保证系统的高可用。</p><h2 id="keepalived工作原理"><a href="#keepalived工作原理" class="headerlink" title="keepalived工作原理"></a>keepalived工作原理</h2><p>  在网络层，keepalived通过ICMP协议（互联网可控制报文协议）向服务器集群中的每个节点发送ICMP数据包（类似ping功能），如果某个节点没有返回响应数据包，那么就认为该节点发生了故障，keepalived就会报告这个节点失效，并且从集群中剔除故障节点。<br>  在传输层，keepalived利用TCP协议端口连接和扫描来判断集群节点是否正常，一旦在传输层发现这些端口没有数据响应，就认为这些端口发生异常，强制将这些端口对应的服务从集群中剔除。<br>  在应用层，用户可以自定义脚本来检测服务是否正常运行，如果keepalived的检测结果和用户设定的不一致时，keepalived将对应的服务从集群中剔除。  </p><h2 id="keepalived常用配置"><a href="#keepalived常用配置" class="headerlink" title="keepalived常用配置"></a>keepalived常用配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    notification_email &#123;  <span class="comment">#设置报警邮件地址，可配置多个</span></span><br><span class="line">        acassen@firewall.loc  <span class="comment">#接收通知的邮件</span></span><br><span class="line">        failover@firewall.loc</span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from <span class="built_in">test</span>@163.com  <span class="comment">#设置发送通知的邮件地址</span></span><br><span class="line">    smtp_server smtp.163.com  <span class="comment">#设置smtp server地址</span></span><br><span class="line">    smtp_connect_timeout 30  <span class="comment">#设置连接smtp server超时时间</span></span><br><span class="line">    router_id LVS_DEVEL  <span class="comment">#主机标识，用于邮件通知</span></span><br><span class="line">    vrrp_strict  <span class="comment">#严格执行VRRP协议规范，此模式不支持节点单播</span></span><br><span class="line">    script_user keepalived_script  <span class="comment">#指定运行脚本的用户名和组。默认使用用户的默认组。如未指定，默认为keepalived_script 用户，如无此用户，则使用root</span></span><br><span class="line">    enable_script_security  <span class="comment">#如果脚本路径为非root可写，不要配置脚本为root用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VRRPD配置"><a href="#VRRPD配置" class="headerlink" title="VRRPD配置"></a>VRRPD配置</h3><p>（1）vrrp_script常用配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_script chk_nginx  &#123;  <span class="comment">#脚本名称是chk_nginx</span></span><br><span class="line">    script <span class="string">&quot;/usr/local/sbin/check_ng.sh&quot;</span>  <span class="comment">#自定义脚本，指定脚本路径</span></span><br><span class="line">    interval 3  <span class="comment">#指定脚本执行间隔，单位秒，默认1s     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）vrrp_instance常用配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER  <span class="comment">#指定实例初始化状态，MASTER和BACKUP</span></span><br><span class="line">    interface ens33  <span class="comment">#指定实例绑定的网卡</span></span><br><span class="line">    virtual_router_id 51  <span class="comment">#设置VRID标记，多个集群不可重复，同一集群相同</span></span><br><span class="line">    priority 100  <span class="comment">#设定优先级，优先级越高会被竞选MASTER</span></span><br><span class="line">    advert_int 1  <span class="comment">#检查的时间间隔，默认1s</span></span><br><span class="line">    authentication &#123;  <span class="comment">#设置认证</span></span><br><span class="line">        auth_type PASS  <span class="comment">#认证方式，支持PASS和AH，官方建议PASS</span></span><br><span class="line">        auth_pass 1111  <span class="comment">#认证的密码</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_address &#123;  <span class="comment">#设置VIP</span></span><br><span class="line">        192.168.186.100/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lvs配置"><a href="#lvs配置" class="headerlink" title="lvs配置"></a>lvs配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtual_server 192.168.186.100 80 &#123;</span><br><span class="line">    delay_loop 6  <span class="comment">#健康检查时间间隔</span></span><br><span class="line">    lb_algo rr  <span class="comment">#设置lvs采用轮询算法</span></span><br><span class="line">    lb_kind DR  <span class="comment">#设置lvs采用直接路由模式</span></span><br><span class="line">    protocol TCP  <span class="comment">#使用的协议</span></span><br><span class="line">    real_server 192.168.186.137 80 &#123;  <span class="comment">#真实服务器地址，可配置多个</span></span><br><span class="line">        weight 1  <span class="comment">#权重，默认为1，0为失效</span></span><br><span class="line">        inhibit_on_failure  <span class="comment">#在服务健康检查失效时，将其设为0，而不是直接剔除</span></span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3  <span class="comment">#连接超时时间</span></span><br><span class="line">            nb_get_retry 3  <span class="comment">#重连次数</span></span><br><span class="line">            delay_before_retry 3  <span class="comment">#重连间隔</span></span><br><span class="line">            connect_port 80  <span class="comment">#健康检查的端口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Keepalived </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keepalived </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins打包GitHub项目</title>
      <link href="2020/05/05/Jenkins%E6%89%93%E5%8C%85GitHub%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/05/05/Jenkins%E6%89%93%E5%8C%85GitHub%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>首先先去Manage Jenkins-&gt;Global Tool Configuration配置好安装的maven</p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/05/Jenkins%E6%89%93%E5%8C%85GitHub%E9%A1%B9%E7%9B%AE/a1.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/05/Jenkins%E6%89%93%E5%8C%85GitHub%E9%A1%B9%E7%9B%AE/a2.png"><br>然后创建一个freestyle job,我这边名称是renren-fast,<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/05/Jenkins%E6%89%93%E5%8C%85GitHub%E9%A1%B9%E7%9B%AE/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/05/Jenkins%E6%89%93%E5%8C%85GitHub%E9%A1%B9%E7%9B%AE/a4.png"><br>最后构建成功</p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Jenkins插件下载慢问题</title>
      <link href="2020/05/04/%E8%A7%A3%E5%86%B3Jenkins%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E9%97%AE%E9%A2%98/"/>
      <url>2020/05/04/%E8%A7%A3%E5%86%B3Jenkins%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>jenkins下载的插件可能由于网络的原因下载失败，我们需要配置他插件下载的地址</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到default.json文件</span></span><br><span class="line">find / -name default.json</span><br><span class="line"><span class="comment">#进入default.json目录下，执行</span></span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins集成GitHub</title>
      <link href="2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/"/>
      <url>2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>首先保证jenkins服务器安装git</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><h2 id="创建repositories，添加一个文本"><a href="#创建repositories，添加一个文本" class="headerlink" title="创建repositories，添加一个文本"></a>创建repositories，添加一个文本</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a0.png"></p><h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;root@example.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="复制id-rsa-pub文件内容到GitHub的SSH-keys"><a href="#复制id-rsa-pub文件内容到GitHub的SSH-keys" class="headerlink" title="复制id_rsa.pub文件内容到GitHub的SSH keys"></a>复制id_rsa.pub文件内容到GitHub的SSH keys</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a1.png"></p><h2 id="添加jenkins凭据"><a href="#添加jenkins凭据" class="headerlink" title="添加jenkins凭据"></a>添加jenkins凭据</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a2.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a3.png"></p><h2 id="构建freestyle-job"><a href="#构建freestyle-job" class="headerlink" title="构建freestyle job"></a>构建freestyle job</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a4.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a5.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a6.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a7.png"></p><p>最后点击Build with Parameters进行job构建<br><img src= "/img/loading.gif" data-lazy-src="/2020/05/01/Jenkins%E9%9B%86%E6%88%90GitHub/a8.png"></p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Maven安装</title>
      <link href="2020/04/19/Linux%E4%B8%8BMaven%E5%AE%89%E8%A3%85/"/>
      <url>2020/04/19/Linux%E4%B8%8BMaven%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>去官网下载maven，<a href="http://maven.apache.org/">http://maven.apache.org/</a></p><a id="more"></a><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf apache-maven-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">MAVEN_HOME=/usr/<span class="built_in">local</span>/maven</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH MAVEN_HOME</span><br></pre></td></tr></table></figure><p>如果含有多个PATH环境变量需要配置，使用冒号隔开，比如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/jdk</span><br><span class="line">MAVEN_HOME=/usr/<span class="built_in">local</span>/maven</span><br><span class="line">CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib/</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH JAVA_HOME CLASSPATH MAVEN_HOME</span><br></pre></td></tr></table></figure><h2 id="使环境变量生效"><a href="#使环境变量生效" class="headerlink" title="使环境变量生效"></a>使环境变量生效</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/19/Linux%E4%B8%8BMaven%E5%AE%89%E8%A3%85/a1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL读写分离之Atlas</title>
      <link href="2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/"/>
      <url>2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前言我们已经部署了MySQL高可用MHA架构，本文基于MHA使用Atlas构建mysql读写分离。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们额外选着一台服务器去做Atlas的安装配置<br>下载地址：<a href="https://github.com/Qihoo360/Atlas/releases">https://github.com/Qihoo360/Atlas/releases</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y Atlas*</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>mv test.cnf test.cnf.bak<br>vi test.cnf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysql-proxy]</span><br><span class="line">admin-username = user</span><br><span class="line">admin-password = <span class="built_in">pwd</span></span><br><span class="line">proxy-backend-addresses = 192.168.186.100:3306</span><br><span class="line">proxy-read-only-backend-addresses = 192.168.186.133:3306,192.168.186.135:3306</span><br><span class="line">pwds = twf:JKEfAH2h9U0a8s/oWZlMvQ==,mha:JKEfAH2h9U0a8s/oWZlMvQ==</span><br><span class="line">daemon = <span class="literal">true</span></span><br><span class="line">keepalive = <span class="literal">true</span></span><br><span class="line">event-threads = 8</span><br><span class="line"><span class="built_in">log</span>-level = message</span><br><span class="line"><span class="built_in">log</span>-path = /usr/<span class="built_in">local</span>/mysql-proxy/<span class="built_in">log</span></span><br><span class="line">sql-log=ON</span><br><span class="line">proxy-address = 0.0.0.0:33060</span><br><span class="line">admin-address = 0.0.0.0:2345</span><br><span class="line">charset=utf8</span><br></pre></td></tr></table></figure><p>这边pwds的值都是加密的，可以使用下面命令查看密码加密后的value</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql-proxy/bin/encrypt  tang1611</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动atlas</span><br><span class="line">/usr/<span class="built_in">local</span>/mysql-proxy/bin/mysql-proxyd <span class="built_in">test</span> start</span><br></pre></td></tr></table></figure><p>启动atlas可能会报错<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/a1.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找文件</span></span><br><span class="line">find / -name libcrypto*</span><br><span class="line">做软连接</span><br><span class="line">ln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so.6</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/a2.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找文件</span></span><br><span class="line">find / -name liblemon*</span><br><span class="line">做软连接</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/liblemon_parser.so /usr/lib64/liblemon_parser.so</span><br></pre></td></tr></table></figure><p>最后启动成功，查看服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef |grep proxy</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在另一台机器上执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -umha -p<span class="string">&#x27;tang1611&#x27;</span>  -h 192.168.186.130 -P 33060</span><br><span class="line"><span class="comment">#测试读操作，正常读操作都只会执行在从节点</span></span><br><span class="line">select @@server_id</span><br><span class="line"><span class="comment">#测试写操作</span></span><br><span class="line">begin;select @@server_id;commit;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/a4.png"></p><h2 id="Atlas基本管理"><a href="#Atlas基本管理" class="headerlink" title="Atlas基本管理"></a>Atlas基本管理</h2><h3 id="连接管理接口"><a href="#连接管理接口" class="headerlink" title="连接管理接口"></a>连接管理接口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uuser -ppwd -h192.168.186.130 -P2345</span><br></pre></td></tr></table></figure><h3 id="打印帮助"><a href="#打印帮助" class="headerlink" title="打印帮助"></a>打印帮助</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select * from <span class="built_in">help</span>;</span><br></pre></td></tr></table></figure><h3 id="查询后端所有节点"><a href="#查询后端所有节点" class="headerlink" title="查询后端所有节点"></a>查询后端所有节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select * from backends;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/18/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8BAtlas/a5.png"></p><h3 id="动态添加删除节点"><a href="#动态添加删除节点" class="headerlink" title="动态添加删除节点"></a>动态添加删除节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ADD SLAVE 192.168.186.136:3306;</span><br><span class="line">REMOVE BACKEND 4;</span><br></pre></td></tr></table></figure><h3 id="保存配置文件"><a href="#保存配置文件" class="headerlink" title="保存配置文件"></a>保存配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SAVE CONFIG;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Atlas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atlas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins安装部署</title>
      <link href="2020/04/15/Jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
      <url>2020/04/15/Jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="下载rpm包"><a href="#下载rpm包" class="headerlink" title="下载rpm包"></a>下载rpm包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.204.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="导入jenkins库的key"><a href="#导入jenkins库的key" class="headerlink" title="导入jenkins库的key"></a>导入jenkins库的key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key  </span><br></pre></td></tr></table></figure><h2 id="安装jdk1-8"><a href="#安装jdk1-8" class="headerlink" title="安装jdk1.8"></a>安装jdk1.8</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk-*</span><br></pre></td></tr></table></figure><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y jenkins</span><br></pre></td></tr></table></figure><h2 id="创建jenkins用户"><a href="#创建jenkins用户" class="headerlink" title="创建jenkins用户"></a>创建jenkins用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd deploy</span><br></pre></td></tr></table></figure><h2 id="编辑-etc-sysconfig-jenkins文件"><a href="#编辑-etc-sysconfig-jenkins文件" class="headerlink" title="编辑/etc/sysconfig/jenkins文件"></a>编辑/etc/sysconfig/jenkins文件</h2><p>vim /etc/sysconfig/jenkins</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改以下内容</span></span><br><span class="line">JENKINS_USER=<span class="string">&quot;deploy&quot;</span></span><br><span class="line">JENKINS_PORT=<span class="string">&quot;8080&quot;</span></span><br></pre></td></tr></table></figure><h2 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R deploy:deploy /var/lib/jenkins</span><br><span class="line">chown -R deploy:deploy /var/<span class="built_in">log</span>/jenkins</span><br></pre></td></tr></table></figure><h2 id="启动jenkins"><a href="#启动jenkins" class="headerlink" title="启动jenkins"></a>启动jenkins</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start jenkins &amp;&amp; systemctl <span class="built_in">enable</span> jenkins</span><br></pre></td></tr></table></figure><h2 id="查看是否成功启动"><a href="#查看是否成功启动" class="headerlink" title="查看是否成功启动"></a>查看是否成功启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef |grep jenkins</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>在访问的机器上修改C:\Windows\System32\drivers\etc\hosts文件，最后一行添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.186.138 jenkins.example.com</span><br></pre></td></tr></table></figure><p>最后在浏览器访问jenkins</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://jenkins.example.com:8080</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/15/Jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a1.png"><br>等待一会，查看密码<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/15/Jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a2.png"><br>选择安装推荐的插件，安装后配置admin用户密码、邮箱<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/15/Jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a3.png"><br>登陆成功之后<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/15/Jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab安装部署</title>
      <link href="2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
      <url>2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install curl policycoreutils openssh-server openssh-clients postfix -y</span><br></pre></td></tr></table></figure><h2 id="启动postfix服务，并设置开机启动"><a href="#启动postfix服务，并设置开机启动" class="headerlink" title="启动postfix服务，并设置开机启动"></a>启动postfix服务，并设置开机启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start postfix &amp;&amp; systemctl <span class="built_in">enable</span> postfix</span><br></pre></td></tr></table></figure><h2 id="下载rpm包"><a href="#下载rpm包" class="headerlink" title="下载rpm包"></a>下载rpm包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-10.0.6-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="本地安装gitlab-ce"><a href="#本地安装gitlab-ce" class="headerlink" title="本地安装gitlab-ce"></a>本地安装gitlab-ce</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y localinstall gitlab-ce-10.0.6-ce.0.el7.x86_64.rpm </span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>（1）创建一个ssl目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/gitlab/ssl</span><br></pre></td></tr></table></figure><p>（2）使用openssl创建私有密钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.key&quot;</span> 2048</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a1.png"><br>（3）使用刚刚创建的私有密钥创建csr证书</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -key <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.key&quot;</span> -out <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.csr&quot;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a2.png"><br>（4）创建crt证书</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.csr&quot;</span> -signkey <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.key&quot;</span> -out <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.crt&quot;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a3.png"><br>（5）创建pem证书</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl dhparam -out /etc/gitlab/ssl/dhparams.pem 2048</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a4.png"><br>（6）授权</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 /etc/gitlab/ssl/*</span><br></pre></td></tr></table></figure><p>（7）修改/etc/gitlab/gitlab.rb文件以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#http改为https</span></span><br><span class="line">external_url <span class="string">&#x27;https://gitlab.example.com&#x27;</span></span><br><span class="line"><span class="comment">#将#nginx[&#x27;redirect_http_to_https&#x27;] = false的注释去掉，修改为nginx[&#x27;redirect_http_to_https&#x27;] = true</span></span><br><span class="line">nginx[<span class="string">&#x27;redirect_http_to_https&#x27;</span>] = <span class="literal">true</span></span><br><span class="line"><span class="comment">#将#nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/#&#123;node[&#x27;fqdn&#x27;]&#125;.crt&quot;修改为nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/gitlab.example.com.crt&quot;</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_certificate&#x27;</span>] = <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.crt&quot;</span></span><br><span class="line"><span class="comment">#将#nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/#&#123;node[&#x27;fqdn&#x27;]&#125;.key&quot;修改为nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot;</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_certificate_key&#x27;</span>] = <span class="string">&quot;/etc/gitlab/ssl/gitlab.example.com.key&quot;</span></span><br><span class="line">将<span class="comment">#nginx[&#x27;ssl_dhparam&#x27;] = nil 修改为nginx[&#x27;ssl_dhparam&#x27;] = &quot;/etc/gitlab/ssl/dhparams.pem&quot;</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_dhparam&#x27;</span>] = <span class="string">&quot;/etc/gitlab/ssl/dhparams.pem&quot;</span></span><br></pre></td></tr></table></figure><p>（8）初始化gitlab所有相关配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/13/GitLab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/a5.png"><br>（9）修改gitlab的代理配置文件（/var/opt/gitlab/nginx/conf/gitlab-http.conf）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/opt/gitlab/nginx/conf/gitlab-http.conf</span><br><span class="line"><span class="comment">#修改配置项在找到listen *:8002;</span></span><br><span class="line"><span class="comment">#修改配置项在找到server_name,在server_name下添加如下配置内容：</span></span><br><span class="line">rewrite ^(.*)$ https://<span class="variable">$host</span><span class="variable">$1</span> permanent;</span><br></pre></td></tr></table></figure><p>重启gitlab，使配置生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>（10）在访问的机器上修改C:\Windows\System32\drivers\etc\hosts文件，最后一行添加<br>192.168.186.133 gitlab.example.com<br>将gitlab服务器的地址添加上gitlab.example.com的配置<br>然后访问<a href="https://gitlab.example.com/">https://gitlab.example.com</a></p>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix监控Nginx</title>
      <link href="2020/04/12/Zabbix%E7%9B%91%E6%8E%A7Nginx/"/>
      <url>2020/04/12/Zabbix%E7%9B%91%E6%8E%A7Nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="开启nginx-status配置"><a href="#开启nginx-status配置" class="headerlink" title="开启nginx status配置"></a>开启nginx status配置</h2><p>location /ngx_status {<br>    stub_status on;<br>    access_log off;<br>}</p><a id="more"></a><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h2 id="打开status页面"><a href="#打开status页面" class="headerlink" title="打开status页面"></a>打开status页面</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8001/ngx_status</span><br></pre></td></tr></table></figure><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#author: twf</span></span><br><span class="line"><span class="comment">#description: zabbix监控nginx性能</span></span><br><span class="line"></span><br><span class="line">HOST=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">PORT=<span class="string">&quot;8001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检测nginx进程是否存在</span></span><br><span class="line"><span class="keyword">function</span> ping &#123;</span><br><span class="line">        ps -ef |grep nginx |grep -v grep |wc -l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测nginx存活的连接数</span></span><br><span class="line"><span class="keyword">function</span> active &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |grep <span class="string">&#x27;Active&#x27;</span> |awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取客户端请求数</span></span><br><span class="line"><span class="keyword">function</span> reading &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |grep <span class="string">&#x27;Reading&#x27;</span> |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#响应客户端请求数</span></span><br><span class="line"><span class="keyword">function</span> writing &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |grep <span class="string">&#x27;Reading&#x27;</span> |awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx已经处理完正在等待下一次请求指令的驻留连接，keepalive开启情况下，该值等于active-reading-writing</span></span><br><span class="line"><span class="keyword">function</span> waiting &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |grep <span class="string">&#x27;Reading&#x27;</span> |awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx启动到现在共处理的连接数</span></span><br><span class="line"><span class="keyword">function</span> server &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |awk NR==3 |awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx启动到现在共创建的多少次握手</span></span><br><span class="line"><span class="keyword">function</span> accepts &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |awk NR==3 |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx总共处理的请求数</span></span><br><span class="line"><span class="keyword">function</span> requests &#123;</span><br><span class="line">        curl http://<span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>/ngx_status 2&gt;/dev/null |awk NR==3 |awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$1</span></span><br></pre></td></tr></table></figure><h2 id="将自定义的UserParameter加入配置文件"><a href="#将自定义的UserParameter加入配置文件" class="headerlink" title="将自定义的UserParameter加入配置文件"></a>将自定义的UserParameter加入配置文件</h2><p>UserParameter=nginx_status[*],/usr/local/bin/ngx_status.sh $1</p><h2 id="重启zabbix-agent"><a href="#重启zabbix-agent" class="headerlink" title="重启zabbix-agent"></a>重启zabbix-agent</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="zabbix-get获取"><a href="#zabbix-get获取" class="headerlink" title="zabbix-get获取"></a>zabbix-get获取</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/12/Zabbix%E7%9B%91%E6%8E%A7Nginx/a1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Zabbix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高可用架构之MHA部署</title>
      <link href="2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/"/>
      <url>2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文是基于mysql主从环境的</p><a id="more"></a><h2 id="MHA组成"><a href="#MHA组成" class="headerlink" title="MHA组成"></a>MHA组成</h2><p>MHA主要有Manager、Node两部分组成<br>Manager：Manager可以部署在单独的服务器上，管理多个主从集群，也可以部署在一个从服务器上。MHA Manager会探测集群中master节点，当master出现故障时，它可以自动将一个slave提升为新的master，然后重新建立主从关系<br>Node：所有机器均需要安装</p><h2 id="MHA工作原理"><a href="#MHA工作原理" class="headerlink" title="MHA工作原理"></a>MHA工作原理</h2><p>当master出现故障后，MHA会挑选一个slave，进行数据补偿，让他做为新的master，并且重新建立主从关系。</p><h2 id="选主策略"><a href="#选主策略" class="headerlink" title="选主策略"></a>选主策略</h2><p>（1）如果从库（GTID）数据有差异，选择数据最接近master的slave成为备选主<br>（2）如果从库数据一致，按照配置文件顺序选主<br>（3）如果设定了权重（candidate_master=1），按照权重选主<br>    1）默认情况下如果一个slave数据落后master大于100M的中继日志数据的话，权重不会生效<br>    2）如果设置check_repl_delay=0，即使落后很多日志，也会成为备选主</p><h2 id="MHA部署"><a href="#MHA部署" class="headerlink" title="MHA部署"></a>MHA部署</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>192.168.186.133 mysql-master node<br>192.168.186.134 mysql-slave node<br>192.168.186.135 mysql-slave node manager</p><h3 id="建立软连接"><a href="#建立软连接" class="headerlink" title="建立软连接"></a>建立软连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog  /usr/bin/mysqlbinlog</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/mysql/bin/mysql  /usr/bin/mysql</span><br></pre></td></tr></table></figure><h3 id="配置ssh登陆无密码登陆"><a href="#配置ssh登陆无密码登陆" class="headerlink" title="配置ssh登陆无密码登陆"></a>配置ssh登陆无密码登陆</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#192.168.186.133：</span></span><br><span class="line">rm -rf /root/.ssh </span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="built_in">cd</span> /root/.ssh </span><br><span class="line">mv id_rsa.pub authorized_keys</span><br><span class="line">scp  -r  /root/.ssh  192.168.186.134:/root </span><br><span class="line">scp  -r  /root/.ssh  192.168.186.135:/root </span><br><span class="line"><span class="comment">#各节点验证</span></span><br><span class="line"><span class="comment">#192.168.186.133:</span></span><br><span class="line">ssh 192.168.186.133 date</span><br><span class="line">ssh 192.168.186.134 date</span><br><span class="line">ssh 192.168.186.135 date</span><br><span class="line"><span class="comment">#192.168.186.134:</span></span><br><span class="line">ssh 192.168.186.133 date</span><br><span class="line">ssh 192.168.186.134 date</span><br><span class="line">ssh 192.168.186.135 date</span><br><span class="line"><span class="comment">#192.168.186.135:</span></span><br><span class="line">ssh 192.168.186.133 date</span><br><span class="line">ssh 192.168.186.134 date</span><br><span class="line">ssh 192.168.186.135 date</span><br></pre></td></tr></table></figure><h3 id="下载mha"><a href="#下载mha" class="headerlink" title="下载mha"></a>下载mha</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github下载地址：https://github.com/yoshinorim/mha4mysql-manager/wiki/Downloads</span><br></pre></td></tr></table></figure><h3 id="所有节点安装node软件依赖包"><a href="#所有节点安装node软件依赖包" class="headerlink" title="所有节点安装node软件依赖包"></a>所有节点安装node软件依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install perl-DBD-MySQL -y</span><br><span class="line">rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="master节点创建mha用户"><a href="#master节点创建mha用户" class="headerlink" title="master节点创建mha用户"></a>master节点创建mha用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to mha@<span class="string">&#x27;192.168.186.%&#x27;</span> identified by <span class="string">&#x27;tang1611&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="Manager软件安装"><a href="#Manager软件安装" class="headerlink" title="Manager软件安装"></a>Manager软件安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y perl-Config-Tiny epel-release perl-Log-Dispatch perl-Parallel-ForkManager perl-Time-HiRes</span><br><span class="line">rpm -ivh mha4mysql-manager-0.56-0.el6.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="manager配置文件"><a href="#manager配置文件" class="headerlink" title="manager配置文件"></a>manager配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建配置文件目录</span></span><br><span class="line">mkdir -p /etc/mha</span><br><span class="line"><span class="comment">#创建日志目录</span></span><br><span class="line">mkdir -p /var/<span class="built_in">log</span>/mha/app1</span><br><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line">vim /etc/mha/app1.cnf</span><br><span class="line">[server default]</span><br><span class="line">manager_log=/var/<span class="built_in">log</span>/mha/app1/manager</span><br><span class="line">manager_workdir=/var/<span class="built_in">log</span>/mha/app1            </span><br><span class="line">master_binlog_dir=/data/binlog       </span><br><span class="line">user=mha                                   </span><br><span class="line">password=tang1611                          </span><br><span class="line">ping_interval=2</span><br><span class="line">repl_password=tang1611</span><br><span class="line">repl_user=twf</span><br><span class="line">ssh_user=root                               </span><br><span class="line">[server1]                                   </span><br><span class="line">hostname=192.168.186.133</span><br><span class="line">port=3306                                  </span><br><span class="line">[server2]            </span><br><span class="line">hostname=192.168.186.134</span><br><span class="line">port=3306</span><br><span class="line">[server3]</span><br><span class="line">hostname=192.168.186.135</span><br><span class="line">port=3306</span><br></pre></td></tr></table></figure><h3 id="ssh通信验证"><a href="#ssh通信验证" class="headerlink" title="ssh通信验证"></a>ssh通信验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_check_ssh --conf=/etc/mha/app1.cnf</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a1.png"></p><h3 id="主从状态检查"><a href="#主从状态检查" class="headerlink" title="主从状态检查"></a>主从状态检查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_check_repl  --conf=/etc/mha/app1.cnf</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a2.png"></p><h3 id="启动MHA"><a href="#启动MHA" class="headerlink" title="启动MHA"></a>启动MHA</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover  &lt; /dev/null&gt; /var/<span class="built_in">log</span>/mha/app1/manager.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h3 id="查看MHA状态"><a href="#查看MHA状态" class="headerlink" title="查看MHA状态"></a>查看MHA状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_check_status --conf=/etc/mha/app1.cnf</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a4.png"></p><h2 id="配置MHA的vip功能"><a href="#配置MHA的vip功能" class="headerlink" title="配置MHA的vip功能"></a>配置MHA的vip功能</h2><p>修改manager配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">master_ip_failover_script=/usr/<span class="built_in">local</span>/bin/master_ip_failover</span><br></pre></td></tr></table></figure><p>master_ip_failover脚本内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env perl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Copyright (C) 2011 DeNA Co.,Ltd.</span></span><br><span class="line"><span class="comment">#  You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment">#   along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment">#  Foundation, Inc.,</span></span><br><span class="line"><span class="comment">#  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Note: This is a sample script and is not complete. Modify the script based on your environment.</span></span><br><span class="line"></span><br><span class="line">use strict;</span><br><span class="line">use warnings FATAL =&gt; <span class="string">&#x27;all&#x27;</span>;</span><br><span class="line"></span><br><span class="line">use Getopt::Long;</span><br><span class="line">use MHA::DBHelper;</span><br><span class="line"></span><br><span class="line">my (</span><br><span class="line">  <span class="variable">$command</span>,        <span class="variable">$ssh_user</span>,         <span class="variable">$orig_master_host</span>,</span><br><span class="line">  <span class="variable">$orig_master_ip</span>, <span class="variable">$orig_master_port</span>, <span class="variable">$new_master_host</span>,</span><br><span class="line">  <span class="variable">$new_master_ip</span>,  <span class="variable">$new_master_port</span>,  <span class="variable">$new_master_user</span>,</span><br><span class="line">  <span class="variable">$new_master_password</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my <span class="variable">$vip</span> = <span class="string">&#x27;192.168.186.100/24&#x27;</span>;</span><br><span class="line">my <span class="variable">$key</span> = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">my <span class="variable">$ssh_start_vip</span> = <span class="string">&quot;/sbin/ifconfig ens33:<span class="variable">$key</span> <span class="variable">$vip</span>&quot;</span>;</span><br><span class="line">my <span class="variable">$ssh_stop_vip</span> = <span class="string">&quot;/sbin/ifconfig ens33:<span class="variable">$key</span> down&quot;</span>;</span><br><span class="line">GetOptions(</span><br><span class="line">  <span class="string">&#x27;command=s&#x27;</span>             =&gt; \<span class="variable">$command</span>,</span><br><span class="line">  <span class="string">&#x27;ssh_user=s&#x27;</span>            =&gt; \<span class="variable">$ssh_user</span>,</span><br><span class="line">  <span class="string">&#x27;orig_master_host=s&#x27;</span>    =&gt; \<span class="variable">$orig_master_host</span>,</span><br><span class="line">  <span class="string">&#x27;orig_master_ip=s&#x27;</span>      =&gt; \<span class="variable">$orig_master_ip</span>,</span><br><span class="line">  <span class="string">&#x27;orig_master_port=i&#x27;</span>    =&gt; \<span class="variable">$orig_master_port</span>,</span><br><span class="line">  <span class="string">&#x27;new_master_host=s&#x27;</span>     =&gt; \<span class="variable">$new_master_host</span>,</span><br><span class="line">  <span class="string">&#x27;new_master_ip=s&#x27;</span>       =&gt; \<span class="variable">$new_master_ip</span>,</span><br><span class="line">  <span class="string">&#x27;new_master_port=i&#x27;</span>     =&gt; \<span class="variable">$new_master_port</span>,</span><br><span class="line">  <span class="string">&#x27;new_master_user=s&#x27;</span>     =&gt; \<span class="variable">$new_master_user</span>,</span><br><span class="line">  <span class="string">&#x27;new_master_password=s&#x27;</span> =&gt; \<span class="variable">$new_master_password</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> &amp;main();</span><br><span class="line"></span><br><span class="line">sub main &#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\n\nIN SCRIPT TEST====<span class="variable">$ssh_stop_vip</span>==<span class="variable">$ssh_start_vip</span>===\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="variable">$command</span> eq <span class="string">&quot;stop&quot;</span> || <span class="variable">$command</span> eq <span class="string">&quot;stopssh&quot;</span> ) &#123;</span><br><span class="line">        my <span class="variable">$exit_code</span> = 1;</span><br><span class="line">        <span class="built_in">eval</span> &#123;</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Disabling the VIP on old master: <span class="variable">$orig_master_host</span> \n&quot;</span>;</span><br><span class="line">            &amp;stop_vip();</span><br><span class="line">            <span class="variable">$exit_code</span> = 0;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$@</span>) &#123;</span><br><span class="line">            warn <span class="string">&quot;Got Error: <span class="variable">$@</span>\n&quot;</span>;</span><br><span class="line">            <span class="built_in">exit</span> <span class="variable">$exit_code</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span> <span class="variable">$exit_code</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elsif ( <span class="variable">$command</span> eq <span class="string">&quot;start&quot;</span> ) &#123;</span><br><span class="line">        my <span class="variable">$exit_code</span> = 10;</span><br><span class="line">        <span class="built_in">eval</span> &#123;</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Enabling the VIP - <span class="variable">$vip</span> on the new master - <span class="variable">$new_master_host</span> \n&quot;</span>;</span><br><span class="line">            &amp;start_vip();</span><br><span class="line">            <span class="variable">$exit_code</span> = 0;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$@</span>) &#123;</span><br><span class="line">            warn <span class="variable">$@</span>;</span><br><span class="line">            <span class="built_in">exit</span> <span class="variable">$exit_code</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span> <span class="variable">$exit_code</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elsif ( <span class="variable">$command</span> eq <span class="string">&quot;status&quot;</span> ) &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Checking the Status of the script.. OK \n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        &amp;usage();</span><br><span class="line">        <span class="built_in">exit</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sub <span class="function"><span class="title">start_vip</span></span>() &#123;</span><br><span class="line">    `ssh <span class="variable">$ssh_user</span>\@<span class="variable">$new_master_host</span> \&quot; <span class="variable">$ssh_start_vip</span> \&quot;`;</span><br><span class="line">&#125;</span><br><span class="line">sub <span class="function"><span class="title">stop_vip</span></span>() &#123;</span><br><span class="line">     <span class="built_in">return</span> 0  unless  (<span class="variable">$ssh_user</span>);</span><br><span class="line">    `ssh <span class="variable">$ssh_user</span>\@<span class="variable">$orig_master_host</span> \&quot; <span class="variable">$ssh_stop_vip</span> \&quot;`;</span><br><span class="line">&#125;</span><br><span class="line">sub usage &#123;</span><br><span class="line">  <span class="built_in">print</span></span><br><span class="line"><span class="string">&quot;Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用dos2unix工具处理脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix /usr/<span class="built_in">local</span>/bin/master_ip_failover </span><br></pre></td></tr></table></figure><p>赋予可执行权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/master_ip_failover </span><br></pre></td></tr></table></figure><p>在主库上生成vip</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens33:1 192.168.186.100/24</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a5.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先重启MHA，让之前的配置生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_stop --conf=/etc/mha/app1.cnf</span><br><span class="line">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover  &lt; /dev/null&gt; /var/<span class="built_in">log</span>/mha/app1/manager.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>查看mha状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_check_status --conf=/etc/mha/app1.cnf</span><br></pre></td></tr></table></figure><p>在master(192.168.186.133)节点pkill掉mysql、mysqld</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill mysql</span><br><span class="line">pkill mysqld</span><br></pre></td></tr></table></figure><p>在192.168.186.134查看虚拟vip<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a6.png"><br>可以看出master已经在192.168.186.134机器上了<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a7.png"><br>可以从app1.cnf看出192.168.186.133已经被MHA剔除了<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E9%83%A8%E7%BD%B2/a8.png"></p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>在192.168.186.133机器执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">mysql -uroot -p<span class="string">&#x27;tang1611&#x27;</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;192.168.186.134&#x27;</span>,MASTER_USER=<span class="string">&#x27;twf&#x27;</span>, MASTER_PASSWORD=<span class="string">&#x27;tang1611&#x27;</span>;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>在192.168.186.135机器<br>vim /etc/mha/app1.cnf,将server1加进去<br>再次启动mha<br>nohup masterha_manager –conf=/etc/mha/app1.cnf –remove_dead_master_conf –ignore_last_failover  &lt; /dev/null&gt; /var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制</title>
      <link href="2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h2><p>mysql中有一种二进制日志，这种日志会记录所有修改数据库的操作，主从复制的原理实际上就是把主服务器的binlog日志复制到从服务器上执行一遍，这样从节点的数据就可以保持与主节点数据一致了。</p><a id="more"></a><h2 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a1.png"><br>（1）首先因为从节点需要复制主节点的binlog日志，所以必须保证主节点启用二进制日志（log-bin=mysql-bin）<br>（2）从节点会开启一个I/O线程扮演mysql客户端，去请求主节点的二进制日志的事件<br>（3）主节点启动一个dump线程，检查自己二进制日志中的事件，跟对方请求的位置对比，如果不带请求位置参数，则主节点就会第一个日志文件中的第一个事件一个个发送给从节点<br>（4）从节点收到主节点发送过来的数据，把它放到中继日志（relay log）中，并且记录该次请求到主节点哪个二进制日志文件的哪个位置<br>（5）从节点另外一个SQL线程会把中继日志（relay log）中的事件读取出来，并且在执行一遍</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><!--more--><p>192.168.186.133 mysql-master<br>192.168.186.134 mysql-slave<br>192.168.186.135 mysql-slave</p><p>##mysql-master配置<br>vim /etc/my.cnf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">symbolic-links=0</span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">binlog-do-db = db1</span><br><span class="line">binlog_format=mixed</span><br><span class="line">server-id=1</span><br><span class="line">innodb_file_per_table=ON</span><br></pre></td></tr></table></figure><p>查看是否开启log-bin<br>mysql&gt; show global variables like ‘%log%’;<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a2.png"><br>查看master主节点二进制日志<br>show master logs;<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a3.png"><br>查看主节点的server id<br>show global variables like ‘%server_id%’<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a4.png"><br>创建主节点复制权限的用户<br>grant replication slave,replication client on <em>.</em> to ‘twf’@’%’ identified by ‘tang1611’;</p><h2 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h2><p>vim /etc/my.cnf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">symbolic-links=0</span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">binlog-do-db = db1</span><br><span class="line">relay-log=relay-log</span><br><span class="line">relay-log-index=relay-log.index</span><br><span class="line"><span class="built_in">read</span>-only=1</span><br><span class="line">server_id=3</span><br><span class="line">innodb_file_per_table=ON</span><br></pre></td></tr></table></figure><p>查看中继日志是否开启<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a5.png"><br>在master主节点查看binlog<br>show binary logs;<br>建立主从关系<br>CHANGE MASTER TO MASTER_HOST=’192.168.186.133’,MASTER_USER=’twf’,MASTER_PASSWORD=’tang1611’, MASTER_LOG_FILE=’mysql-bin.000007’,MASTER_LOG_POS=1675;<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a6.png"><br>启动从节点复制线程<br>start slave;<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a7.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>(1)主节点创建数据库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create database mydb;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a8.png"><br>(2)在从节点查看二进制日志，查看是否成功复制成功<br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a9.png"><br><img src= "/img/loading.gif" data-lazy-src="/2020/04/05/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/a10.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK安装和部署</title>
      <link href="2020/03/28/ELK%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>2020/03/28/ELK%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>链接：<a href="https://pan.baidu.com/s/18fFb0ZVQyXLxJg1tp9Yi_A">https://pan.baidu.com/s/18fFb0ZVQyXLxJg1tp9Yi_A</a> </p><a id="more"></a><p>提取码：q7gk </p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>192.168.186.129 centos7</p><h2 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/elk</span><br><span class="line"><span class="comment">#解压缩，将文件移动到/usr/local/elk目录下</span></span><br><span class="line">tar zxvf 文件</span><br><span class="line"><span class="comment">#打开/etc/security/limits.conf文件，在末尾追加以下内容，设置更大的打开文件数</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br><span class="line"><span class="comment">#打开/etc/security/limits.d/20-nproc.conf，修改以下内容</span></span><br><span class="line">*          soft    nproc   4096</span><br><span class="line"><span class="comment">#打开/etc/sysctl.conf文件，在末尾追加以下内容</span></span><br><span class="line">vm.max_map_count=655360</span><br><span class="line">fs.file-max=655360</span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sysctl -p</span><br><span class="line"><span class="comment">#重启操作系统</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="创建用户-并授权"><a href="#创建用户-并授权" class="headerlink" title="创建用户,并授权"></a>创建用户,并授权</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#elk是不允许以root用户运行的</span></span><br><span class="line">useradd elk</span><br><span class="line">passwd elk</span><br><span class="line">chown -R elk:elk /usr/<span class="built_in">local</span>/elk</span><br></pre></td></tr></table></figure><h2 id="elasticsearch部署"><a href="#elasticsearch部署" class="headerlink" title="elasticsearch部署"></a>elasticsearch部署</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建存放数据的目录</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/elk/elasticsearch/data</span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/elk/elasticsearch/logs</span><br><span class="line"><span class="comment">#修改elasticsearch/config/elasticsearch.yml配置文件以下内容</span></span><br><span class="line">path.data: /usr/<span class="built_in">local</span>/elk/elasticsearch/data <span class="comment">#数据目录</span></span><br><span class="line">path.logs: /usr/<span class="built_in">local</span>/elk/elasticsearch/logs <span class="comment">#日志目录</span></span><br><span class="line">network.host: 0.0.0.0 <span class="comment">#允许所有ip访问</span></span><br><span class="line">http.port: 9200 <span class="comment">#端口</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span> <span class="comment">#在末尾添加</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span> <span class="comment">#在末尾添加</span></span><br><span class="line"><span class="comment">#修改jvm.options以下内容</span></span><br><span class="line">-Xms512m </span><br><span class="line">-Xmx512m<span class="string">&quot; </span></span><br><span class="line"><span class="string">#启动elasticsearch</span></span><br><span class="line"><span class="string">./bin/elasticsearch -d</span></span><br><span class="line"><span class="string">#查看elasticsearch是否启动成功</span></span><br><span class="line"><span class="string">ps -ef |grep elasticsearch</span></span><br></pre></td></tr></table></figure><h2 id="logstash部署"><a href="#logstash部署" class="headerlink" title="logstash部署"></a>logstash部署</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建文件</span></span><br><span class="line">touch  logstash/config/test.conf</span><br><span class="line"><span class="comment">#写入内容</span></span><br><span class="line">input &#123;</span><br><span class="line">        beats &#123;</span><br><span class="line">                port =&gt; 5044</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                hosts =&gt; <span class="string">&quot;127.0.0.1:9200&quot;</span></span><br><span class="line">                index =&gt; <span class="string">&quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#启动logstash</span></span><br><span class="line">nohup ./bin/logstash -f config/test.conf </span><br><span class="line"><span class="comment">#查看logstash是否启动成功</span></span><br><span class="line">ps -ef |grep logstash</span><br></pre></td></tr></table></figure><h2 id="kibana部署"><a href="#kibana部署" class="headerlink" title="kibana部署"></a>kibana部署</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动kibana</span></span><br><span class="line">nohup ./bin/kibana -H 0.0.0.0</span><br><span class="line"><span class="comment">#查看kibana是否启动成功</span></span><br><span class="line">ps -ef |grep kibana</span><br></pre></td></tr></table></figure><h2 id="filebeat部署"><a href="#filebeat部署" class="headerlink" title="filebeat部署"></a>filebeat部署</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改filebeat.yml以下内容，注意yml文件格式</span></span><br><span class="line">paths:</span><br><span class="line">  - /tmp/test_data</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">&quot;localhost:5044&quot;</span>]</span><br><span class="line"><span class="comment">#启动filebeats</span></span><br><span class="line">./filebeat -e -c filebeat.yml -d <span class="string">&quot;publish&quot;</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器访问<ip>:5601访问kibana界面，在management页面创建index pattern<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/28/ELK%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/a1.png"><br>在/tmp目录下创建test_data文件<br>echo ‘{“name”: “xili”,”age”: “18”,”sex”: “girl”}’ &gt;&gt; /tmp/test_data<br>查看filebeat控制台<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/28/ELK%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/a2.png"><br>查看kibana<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/28/ELK%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/a3.png"></ip></p>]]></content>
      
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式搭建</title>
      <link href="2020/03/26/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
      <url>2020/03/26/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><a id="more"></a><p>192.168.186.129 centos7</p><h2 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis/7001</span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis/7002</span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis/7003</span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis/7004</span><br></pre></td></tr></table></figure><h2 id="安装redis-5-0-3"><a href="#安装redis-5-0-3" class="headerlink" title="安装redis-5.0.3"></a>安装redis-5.0.3</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装gcc</span></span><br><span class="line">yum install gcc -y</span><br><span class="line"><span class="comment">#安装wget</span></span><br><span class="line">yum install wget -y</span><br><span class="line"><span class="comment">#下载redis-5.0.3.tar.gz</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar zxvf redis-5.0.3.tar.gz</span><br><span class="line"><span class="comment">#移动到redis-5.0.3目录下，执行</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#移动到redis-5.0.3/src目录下，执行</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>复制redis-server、redis-cli、redis-sentinel到/usr/local/redis/目录下<br>复制redis.conf、sentinel.conf到/usr/local/redis/目录下<br>在7001、7002、7003、7004文件夹下创建sentinel目录</p><h2 id="修改主redis-conf"><a href="#修改主redis-conf" class="headerlink" title="修改主redis.conf"></a>修改主redis.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改以下项</span></span><br><span class="line">daemonize yes <span class="comment">#后台运行</span></span><br><span class="line">port 7001 <span class="comment">#端口，按照创建的文件夹分配7001-7006端口</span></span><br><span class="line"><span class="built_in">bind</span> <span class="comment">#绑定ip，默认绑定的是本机，只允许本地访问redis-server，注释掉</span></span><br><span class="line">dir /home/bin/redis/7001/ <span class="comment">#redis数据文件存储位置</span></span><br><span class="line">appendonly yes <span class="comment">#持久化</span></span><br><span class="line">protected-mode no <span class="comment">#保护模式</span></span><br><span class="line">requirepass tang1611 <span class="comment">#设置密码，当客户端连接redis-server时，需要使用-a &lt;password&gt; 来连接</span></span><br><span class="line">masterauth tang1611 <span class="comment">#集群通信密码</span></span><br></pre></td></tr></table></figure><h2 id="修改从redis-conf"><a href="#修改从redis-conf" class="headerlink" title="修改从redis.conf"></a>修改从redis.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改以下项</span></span><br><span class="line">daemonize yes <span class="comment">#后台运行</span></span><br><span class="line">port 7002 <span class="comment">#端口，按照创建的文件夹分配7001-7006端口</span></span><br><span class="line"><span class="built_in">bind</span> <span class="comment">#绑定ip，默认绑定的是本机，只允许本地访问redis-server，注释掉</span></span><br><span class="line">dir /home/bin/redis/7002/ <span class="comment">#redis数据文件存储位置</span></span><br><span class="line">appendonly yes <span class="comment">#持久化</span></span><br><span class="line">protected-mode no <span class="comment">#保护模式</span></span><br><span class="line">requirepass tang1611 <span class="comment">#设置密码，当客户端连接redis-server时，需要使用-a &lt;password&gt; 来连接</span></span><br><span class="line">masterauth tang1611 <span class="comment">#集群通信密码</span></span><br><span class="line">replicaof 127.0.0.1 7001 <span class="comment">#表示以127.0.0.1 7001作为主redis</span></span><br></pre></td></tr></table></figure><h2 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">./redis-server 7001/redis.conf</span><br><span class="line">./redis-server 7002/redis.conf</span><br><span class="line">./redis-server 7003/redis.conf</span><br><span class="line">./redis-server 7004/redis.conf</span><br><span class="line"><span class="comment">#查看redis启动情况</span></span><br><span class="line">ps -ef |grep redis </span><br></pre></td></tr></table></figure><h2 id="sentinel-conf配置"><a href="#sentinel-conf配置" class="headerlink" title="sentinel.conf配置"></a>sentinel.conf配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改以下配置</span></span><br><span class="line"><span class="comment">#关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment">#端口，分配6001、6002、6003、6004端口</span></span><br><span class="line">port 6001</span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#pid文件目录</span></span><br><span class="line">pidfile <span class="string">&quot;/usr/local/redis/7001/sentinel/redis-sentinel.pid&quot;</span></span><br><span class="line"><span class="comment">#日志目录</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/7001/sentinel/redis-sentinel.log&quot;</span></span><br><span class="line"><span class="comment">#哨兵sentinel的工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/redis/7001/sentinel&quot;</span></span><br><span class="line"><span class="comment">#配置master机器ip及端口，2表示必须至少要有2个及以上sentinel认为master挂掉，才认为master挂掉</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7001 2</span><br><span class="line"><span class="comment">#如果redis.conf配置了requirepass,那么该项必须配置，密码与requirepass一致，该项配置必须在sentinel monitor之下</span></span><br><span class="line">sentinel auth-pass mymaster tang1611</span><br></pre></td></tr></table></figure><h2 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-sentinel 7001/sentinel.conf</span><br><span class="line">./redis-sentinel 7002/sentinel.conf</span><br><span class="line">./redis-sentinel 7003/sentinel.conf</span><br><span class="line">./redis-sentinel 7004/sentinel.conf</span><br><span class="line"><span class="comment">#查看sentinel启动情况</span></span><br><span class="line">ps -ef |grep redis</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先确定master是在7001端口的redis上,查看其role</span></span><br><span class="line">./redis.cli -a tang1611 -p 7001 info replication</span><br><span class="line"><span class="comment">#kill掉master节点</span></span><br><span class="line"><span class="built_in">kill</span> -9 &lt;pid&gt;</span><br><span class="line"><span class="comment">#查看redis-sentinel.log,从日志上可以看出来新的master（7003端口的redis）已经选举出来了</span></span><br><span class="line">tail -n 10 redis-sentinel.log</span><br><span class="line">11270:X 26 Mar 2020 16:32:53.542 * +slave slave 127.0.0.1:7004 127.0.0.1 7004 @ mymaster 127.0.0.1 7003</span><br><span class="line">11270:X 26 Mar 2020 16:32:53.542 * +slave slave 127.0.0.1:7002 127.0.0.1 7002 @ mymaster 127.0.0.1 7003</span><br><span class="line">11270:X 26 Mar 2020 16:32:53.542 * +slave slave 127.0.0.1:7001 127.0.0.1 7001 @ mymaster 127.0.0.1 7003</span><br><span class="line">11270:X 26 Mar 2020 16:33:23.552 <span class="comment"># +sdown slave 127.0.0.1:7001 127.0.0.1 7001 @ mymaster 127.0.0.1 7003</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/03/26/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/a1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介</title>
      <link href="2020/03/22/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>2020/03/22/Redis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="redis概念"><a href="#redis概念" class="headerlink" title="redis概念"></a>redis概念</h2><p>redis是一个开源的、使用C语言编写的基于内存可持久化的key-value非关系型数据库。</p><a id="more"></a><h2 id="redis优点"><a href="#redis优点" class="headerlink" title="redis优点"></a>redis优点</h2><p>（1）性能高<br>redis读的速度是110000次/s，写的速度81000次/s。<br>（2）丰富的数据类型<br>redis支持的数据类型有String、List、Set、Hash、sorted set<br>（3）原子性<br>redis操作具有原子性，要么成功执行，要么失败完全不执行<br>（4）丰富的特性<br>支持发布/订阅、数据持久化、key过期等特性</p><h2 id="redis缺点"><a href="#redis缺点" class="headerlink" title="redis缺点"></a>redis缺点</h2><p>（1）持久化<br>redis持久化方案有RDB和AOF。前者redis通过定时快照的方式将数据写入到硬盘上，对于非正常redis关闭的情况下，可能会导致数据丢失，而且这种持久化操作每次都会把所有数据写入硬盘，代价非常高。后者redis只追踪变化的数据，但是追加的log会越来越大，并且所有操作均重新执行一遍，恢复速度慢。<br>（2）耗内存<br>redis是基于内存操作的，对内存的要求较高。</p><h2 id="redis下载"><a href="#redis下载" class="headerlink" title="redis下载"></a>redis下载</h2><p>官方网站：<a href="http://redis.io/download">http://redis.io/download</a> 可以根据需求下载不同版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#redis是C语言开发的，所以需要gcc环境</span></span><br><span class="line">yum install gcc -y</span><br><span class="line"><span class="comment">#我这边下载redis-5.0.3</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar zxvf redis-5.0.3.tar.gz</span><br><span class="line"><span class="comment">#移动到redis-5.0.3目录下执行</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#移动到redis-5.0.3/src目录下执行</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="redis-conf配置"><a href="#redis-conf配置" class="headerlink" title="redis.conf配置"></a>redis.conf配置</h2><table><thead><tr><th align="left">配置</th><th align="left">默认</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">daemonize</td><td align="left">no</td><td align="left">是否后台运行</td></tr><tr><td align="left">port</td><td align="left">6379</td><td align="left">端口</td></tr><tr><td align="left">bind</td><td align="left">127.0.0.1</td><td align="left">绑定ip，默认只允许本机访问redis-server</td></tr><tr><td align="left">timeout</td><td align="left">0</td><td align="left">客户端连接超时时间，单位为秒，默认0表示关闭此设置</td></tr><tr><td align="left">loglevel</td><td align="left">notice</td><td align="left">redis支持debug、verbose、notice、warning</td></tr><tr><td align="left">tcp-keepalive</td><td align="left">300</td><td align="left">TCP连接保活策略，默认单位为秒，如果设置60秒，则server端会每60秒向连接空闲的客户端发送一次ACK请求，以检查客户端是否存活，对于无响应的客户端则会关闭其连接</td></tr><tr><td align="left">logfile</td><td align="left"></td><td align="left">redis日志文件，默认为空，如果设置了daemonize yes，redis会把日志输出到/dev/null中</td></tr><tr><td align="left">databases</td><td align="left">16</td><td align="left">redis数据库总数量，数据库索引是0-15</td></tr><tr><td align="left">save <seconds> <changes></changes></seconds></td><td align="left">save 900 1 <br> save 300 10 <br> save 60 10000</td><td align="left">RDB持久化策略，默认是当60秒内有10000个key更改，触发一次RDB快照；当300秒内有10个key更改，触发一次RDB快照；当900秒内有1个key更改，触发一次RDB快照</td></tr><tr><td align="left">stop-writes-on-bgsave-error</td><td align="left">yes</td><td align="left">如果用户开启了RDB持久化，那么当redis持久化到硬盘出现失败，redis会停止接受所有的写请求，当下一次持久化成功后，redis会恢复接受写请求</td></tr><tr><td align="left">rdbcompression</td><td align="left">yes</td><td align="left">对于存储在硬盘的快照，redis支持压缩存储，如果不想消耗cpu，可以关闭此配置，但是存储在硬盘的数据会越来越大</td></tr><tr><td align="left">rdbchecksum</td><td align="left">yes</td><td align="left">在存储快照后，redis支持对数据校验，但是会消耗大约10%的性能，如果希望性能最大化，可以关闭此功能</td></tr><tr><td align="left">dbfilename</td><td align="left">dump.rdb</td><td align="left">设置快照文件的名称</td></tr><tr><td align="left">dir</td><td align="left">./</td><td align="left">配置快照存放路径</td></tr><tr><td align="left">replicaof <masterip> <masterport></masterport></masterip></td><td align="left"></td><td align="left">redis提供主从功能，通过slaveof配置一台服务器作为另一台从服务器</td></tr><tr><td align="left">masterauth <master-password></master-password></td><td align="left"></td><td align="left">如果主服务器设置了requirepass,则从redis配置中要使用masterauth来校验密码</td></tr><tr><td align="left">slave-serve-stale-data</td><td align="left">yes</td><td align="left">当从redis失去与主redis连接，或者主从正在同步时，redis是否处理客户端发来的请求</td></tr><tr><td align="left">replica-read-only</td><td align="left">yes</td><td align="left">控制从redis是否接受写请求</td></tr><tr><td align="left">rep-timeout</td><td align="left">60</td><td align="left">主从同步情况可能会发生超时，用户可以设置超时时限，不过一定要确保比repl-ping-replica-period的值要大</td></tr><tr><td align="left">repl-disable-tcp-nodelay</td><td align="left">no</td><td align="left">控制主从同步是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据，但是会增加一些同步的延迟，大概40ms左右。如果关闭了TCP_NODELAY，那么数据同步延迟会降低，但是会消耗更多的带宽</td></tr><tr><td align="left">repl-backlog-size</td><td align="left">1mb</td><td align="left">设置队列长度，队列长度是redis中的一个缓冲区，如果与从redis断开连接后，主redis会用这个缓冲区缓存发送的数据</td></tr><tr><td align="left">repl-backlog-ttl</td><td align="left">3600</td><td align="left">如果主redis等了一段时间后，还是无法与从redis连接，那么缓冲区数据将被清除；如果设置为0表示永不清除</td></tr><tr><td align="left">min-replicas-to-write</td><td align="left">3</td><td align="left">与min-replicas-max-lag配合使用</td></tr><tr><td align="left">min-replicas-max-lag</td><td align="left">10</td><td align="left">表示当主redis发现超过M个连接延迟大于N秒时，那么主redis就停止接受写请求。从redis每秒都会向主redis发出ping，而主redis会记录每一个从redis发来的ping时间点，所以主redis能够了解从redis的运行情况</td></tr><tr><td align="left">replica-priority</td><td align="left">100</td><td align="left">规定从redis优先级，在主redis持续不正常工作时，优先级高的将成为主redis，而编号越小表示优先级越高，当编号被设置为0时表示这个从redis永远不会被选中，默认是100</td></tr><tr><td align="left">requirepass</td><td align="left">foobared</td><td align="left">设置密码验证，当客户端连接redis-server时，需要进行密码验证</td></tr><tr><td align="left">rename-command CONFIG “”</td><td align="left"></td><td align="left">对redis指令进行更名，避免外部调用。这里对CONFIG重命名</td></tr><tr><td align="left">max-clients</td><td align="left">10000</td><td align="left">设置redis-server允许客户端的最大连接数</td></tr><tr><td align="left">maxmemory <bytes></bytes></td><td align="left"></td><td align="left">设置redis可以使用的内存量，当超过此内存上限，redis将根据maxmemory-policy规则移除内部数据</td></tr><tr><td align="left">maxmemory-policy</td><td align="left">noeviction</td><td align="left">指定redis数据淘汰策略，redis提供了volatile-lru、allkeys-lru、volatile-random、allkeys-random、volatile-ttl、noeviction六种数据淘汰策略</td></tr><tr><td align="left">axmemory-samples</td><td align="left">5</td><td align="left">LRU和最小TTL算法都并非是精确算法，而是估算值，可以设置样本大小，redis默认检查5个key并选择其中LRU那个</td></tr><tr><td align="left">appendonly</td><td align="left">no</td><td align="left">redis支持数据持久化，目前redis持久化方案有RDB、AOF</td></tr><tr><td align="left">appendfilename</td><td align="left">“appendonly.aof”</td><td align="left">设置aof文件名称</td></tr><tr><td align="left">appendfsync</td><td align="left">everysec</td><td align="left">一次fsync()调用，操作系统会将缓存指令写入硬盘。redis支持三种模式，no：不调用，让操作系统自行决定sync的时间，redis性能更快；always：每次写请求后都会调用，这种情况redis会相对较慢，但数据最安全；everysec：每秒钟调用一次</td></tr><tr><td align="left">no-appendfsync-on-rewrite</td><td align="left">no</td><td align="left">bgrewriteaof机制，在一个子进程执行aof重写，不会阻塞主进程处理其余指令。但是当bgrewriteaof和主进程写aof时，两种均操作硬盘，bgrewriteaof会涉及大量硬盘操作，这样导致了主进程aof写入的阻塞，当no-appendfsync-on-rewrite设置为yes时表示这就相当于将appendfsync设置为no，不会有磁盘操作，只是写入缓冲区，不会出现阻塞，但是如果这个时候redis挂掉，会丢失数据。如果此参数设置为no，是最安全的方式，但是要忍受阻塞的情形</td></tr><tr><td align="left">auto-aof-rewrite-percentage</td><td align="left">100</td><td align="left">redis记录前一次aof文件大小作为基准值，当当前aof文件超过这个基准100%（默认100）时，触发bgrewriteaof，也就是用一个子进程重写aof。该配置为0时表示禁用重写</td></tr><tr><td align="left">auto-aof-rewrite-min-size</td><td align="left">64mb</td><td align="left">当aof文件大于64mb时，触发bgrewriteaof</td></tr><tr><td align="left">lua-time-limit</td><td align="left">5000</td><td align="left">lua脚本最大运行时间，默认单位ms</td></tr></tbody></table><h2 id="redis数据淘汰策略"><a href="#redis数据淘汰策略" class="headerlink" title="redis数据淘汰策略"></a>redis数据淘汰策略</h2><p>*volatile-lru:使用LRU算法移除过期集合中的key<br>*allkeys-lru:使用LRU算法移除key<br>*volatile-random:在过期集合中随机移除key<br>*allkeys-random:随机移除key<br>volatile-ttl:移除那些ttl值最小的key，即移除最近要过期的key<br>noeviction:不进行移除</p><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>redis支持RDB和AOF两种持久化机制，redis持久化就是将内存中的数据写入到硬盘中，避免redis挂掉导致数据丢失。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB持久化是把当前数据生成快照存储到硬盘中。触发方式有手动触发（save【阻塞式】、bgsave【推荐】）和自动触发（redis.conf中配置save）<br>RDB文件存储路径，通过redis.conf中的dir配置<br>（1）优点<br>*RDB文件是压缩的二进制文件，代表redis在某个时间点的快照，空间占用小<br>*redis加载RDB从硬盘中恢复数据远远快于AOF方式<br>（2）缺点<br>RDB没有做到实时数据持久化，如果数据更改没有达到RDB持久化触发的条件，redis在这个时候突然挂掉，那么就会导致数据丢失</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF持久化是以独立日志的方式记录每次的写命令，重启时再次执行AOF文件中的命令达到数据恢复。AOF主要是解决数据持久化的实时性问题<br>（1）AOF开启<br>通过redis.conf中的appendonly yes开启，通过appendfilename配置名称，通过dir配置数据存储路径<br>（2）AOF流程<br>*redis-server启动，如果AOF机制开启，那么初始化AOF状态，并且如果存在AOF文件，读取AOF文件<br>*随着redis不断接受命令，每个写命令都会被添加到AOF文件，AOF文件大小会增加，redis会记录之前aof大小，当目前aof文件大小达到auto-aof-rewrite-percentage、auto-aof-rewrite-min-size设定的值后，就会触发rewrite<br>*fork出一个子进程进行rewrite，重写新的aof文件，而父进程继续接受命令，现在的写命令都会添加aof_rewrite_buf_blocks缓冲区<br>*当子进程rewrite结束后，父进程收到子进程退出信号，把缓冲区的数据添加到rewrite后新的aof文件中，随后rename新的aof文件，覆盖旧的aof文件<br>*至此一个rewrite走完，继续第2步<br>（3）优点<br>*解决了数据持久化实时性的问题<br>*你可以设置不同的fsync策略，比如无fsync，每秒钟一次fsync，或者每次执行写入命令时fsync。AOF的默认策略为每秒钟fsync一次，在这种配置下，redis仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync会在后台线程执行，所以主线程可以继续努力地处理命令请求）<br>（4）缺点<br>相对于RDB文件，AOF文件的大小通常大于RDB文件，根据fsync策略，AOF速度要慢于RDB</p><h2 id="redis-cluster集群"><a href="#redis-cluster集群" class="headerlink" title="redis-cluster集群"></a>redis-cluster集群</h2><p>redis cluster集群是一个由主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis cluster集群不需要sentine哨兵也能完成节点移除和故障转移功能。需要将每个节点设置成集群模式，这种集群没有中心节点，可水平扩展。<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/22/Redis%E7%AE%80%E4%BB%8B/a1.png"><br>（1）无中心化就是客户端直接与节点相连，不需要proxy代理层，客户端只需要连接到集群的任意节点就行<br>（2）集群中所有的redis节点彼此互联<br>（3）cluster集群中内置16384（编号0-16383）个哈希槽，redis根据节点数量均匀的将槽位分到不同节点。当客户端set一个key时，redis对key使用crc16算法算出一个结果，然后把结果对16384取模，这个key都会对应到0-16383之间的槽位。<br>（4）水平扩容-当集群中新增了一个节点，redis会从其他各个节点取出部分槽位分到新加入的节点<br>（5）集群进入fail状态的必要条件<br>*某个主节点和其所有从节点全部挂掉，集群进入fail状态<br>*如果集群超过半数以上master挂掉，无论是否存在slave，集群进入fail状态<br>*如果集群任意master挂掉，且master没有slave，集群进入fail状态<br>（6）redis投票机制-投票是所有master节点参与的，如果半数以上master节点无法与某个master节点通信，则认为此master节点挂掉</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-cluster集群搭建</title>
      <link href="2020/03/17/Redis-cluster%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>2020/03/17/Redis-cluster%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><a id="more"></a><p>192.168.186.129<br>192.168.186.131<br>192.168.186.132</p><h2 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#在三台服务器分别创建一下目录</span></span><br><span class="line">mkdir -p /home/bin/redis/700&#123;1,4&#125;</span><br><span class="line">mkdir -p /home/bin/redis/700&#123;2,5&#125;</span><br><span class="line">mkdir -p /home/bin/redis/700&#123;3,6&#125;</span><br></pre></td></tr></table></figure><h2 id="安装redis-5-0-3"><a href="#安装redis-5-0-3" class="headerlink" title="安装redis-5.0.3"></a>安装redis-5.0.3</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装gcc</span></span><br><span class="line">yum install gcc -y</span><br><span class="line"><span class="comment">#安装wget</span></span><br><span class="line">yum install wget -y</span><br><span class="line"><span class="comment">#下载redis-5.0.3.tar.gz</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar zxvf redis-5.0.3.tar.gz</span><br><span class="line"><span class="comment">#移动到redis-5.0.3目录下，执行</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#移动到redis-5.0.3/src目录下，执行</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>复制redis-server、redis.conf、redis.cli到7001、7002、7003、7004、7005、7006目录下</p><h2 id="修改redis-conf"><a href="#修改redis-conf" class="headerlink" title="修改redis.conf"></a>修改redis.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改以下项</span></span><br><span class="line">daemonize yes <span class="comment">#后台运行</span></span><br><span class="line">port 7001 <span class="comment">#端口，按照创建的文件夹分配7001-7006端口</span></span><br><span class="line"><span class="built_in">bind</span> <span class="comment">#绑定ip，默认绑定的是本机，只允许本地访问redis-server，要注释掉</span></span><br><span class="line">dir /home/bin/redis/7001/ <span class="comment">#redis数据文件存储位置</span></span><br><span class="line">cluster-enabled yes <span class="comment">#开启集群模式</span></span><br><span class="line">cluster-config-file nodes.conf <span class="comment">#配置集群配置文件</span></span><br><span class="line">cluster-node-timeout <span class="comment">#超时设置</span></span><br><span class="line">appendonly yes <span class="comment">#持久化</span></span><br><span class="line">protected-mode no <span class="comment">#保护模式</span></span><br><span class="line">requirepass 123456 <span class="comment">#设置密码，当客户端连接redis-server时，需要使用-a &lt;password&gt; 来连接</span></span><br><span class="line">masterauth 123456 <span class="comment">#集群通信密码</span></span><br></pre></td></tr></table></figure><h2 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分别进入7001-7006目录下启动redis</span></span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="comment">#查看redis启动情况</span></span><br><span class="line">ps -ef |grep redis  <span class="comment">#每天机器上应该有2个redis服务</span></span><br></pre></td></tr></table></figure><h2 id="redis-cli构建集群"><a href="#redis-cli构建集群" class="headerlink" title="redis-cli构建集群"></a>redis-cli构建集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/bin/redis/redis-5.0.3/src/redis.cli -a 123456 --cluster create --cluster-replicas 1 192.168.186.129:7001 192.168.186.131:7002 192.168.186.132:7003 192.168.186.129:7004 192.168.186.131:7005 192.168.186.132:7006</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL备份</title>
      <link href="2020/03/15/MySQL%E5%A4%87%E4%BB%BD/"/>
      <url>2020/03/15/MySQL%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>编辑/etc/my.cnf,再[mysqld]板块添加如下，重启服务</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line">port=3306</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">symbolic-links=0</span><br><span class="line">max_connections=400</span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">lower_case_table_names=1</span><br><span class="line"><span class="comment">#开启、并且可以将mysql-bin改为其他的日志名</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#添加id号，如果做主从，就不能一样</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#超过200M将生成新文件，最大和默认值是1GB</span></span><br><span class="line">max_binlog_size=1G</span><br><span class="line"><span class="comment">#表示binlog使用最大内存的数，默认1M</span></span><br><span class="line">max_binlog_cache_size=1M</span><br><span class="line"><span class="comment">#表示binlog日志保留时间，默认单位是天</span></span><br><span class="line">expire_logs_days=7</span><br></pre></td></tr></table></figure><h2 id="创建用户并且授权"><a href="#创建用户并且授权" class="headerlink" title="创建用户并且授权"></a>创建用户并且授权</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建back用户</span></span><br><span class="line">create user <span class="string">&#x27;back&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;tang1611&#x27;</span>;</span><br><span class="line"><span class="comment">#授权</span></span><br><span class="line">grant reload,lock tables,replication client,create tablespace,process,super on *.* to <span class="string">&#x27;back&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> ;</span><br><span class="line">grant create,insert,select on percona_schema.* to <span class="string">&#x27;back&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">use mysql;</span><br><span class="line">update user <span class="built_in">set</span> user.Host=<span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user.User=<span class="string">&#x27;back&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="安装innobackupex"><a href="#安装innobackupex" class="headerlink" title="安装innobackupex"></a>安装innobackupex</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装依赖库</span></span><br><span class="line">yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL libev-devel</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span><br><span class="line">yum -y install percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="innobackupex全备份"><a href="#innobackupex全备份" class="headerlink" title="innobackupex全备份"></a>innobackupex全备份</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建备份目录</span></span><br><span class="line">mkdir -p /root/bin</span><br><span class="line">mkdir -p /bak/mysql-xback</span><br></pre></td></tr></table></figure><p>编写脚本<br>vim /root/bin/mybak-all.sh</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#全备份</span></span><br><span class="line"><span class="comment">#指定备份目录</span></span><br><span class="line">backup_dir=<span class="string">&quot;/bak/mysql-xback&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查目录是否存在，不存在则创建</span></span><br><span class="line">[[ -d <span class="variable">$backup_dir</span> ]] || mkdir -p <span class="variable">$backup_dir</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$backup_dir</span>/all-backup ]];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;全备份已经存在&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开始备份</span></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=back --password=<span class="string">&#x27;tang1611&#x27;</span> --no-timestamp <span class="variable">$backup_dir</span>/all-backup &amp;&gt; /tmp/mysql-backup.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看临时目录</span></span><br><span class="line">tail -n 1 /tmp/mysql-backup.log | grep <span class="string">&#x27;completed OK!&#x27;</span></span><br><span class="line"><span class="keyword">if</span> [[ $? -eq 0 ]];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;备份成功&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;all-backup&quot;</span> &gt; /tmp/mysql-backup.txt</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;备份失败&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="innobackupex增量备份"><a href="#innobackupex增量备份" class="headerlink" title="innobackupex增量备份"></a>innobackupex增量备份</h2><p>编写脚本<br>vim /root/bin/mybak-section.sh</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#增量备份</span></span><br><span class="line"><span class="comment">#备份目录</span></span><br><span class="line">backup_dir=<span class="string">&quot;/bak/mysql-xback&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新旧备份</span></span><br><span class="line">old_dir=`cat /tmp/mysql-backup.txt`</span><br><span class="line">new_dir=`date +%F-%H-%M-%S`</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查目录</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="variable">$&#123;backup_dir&#125;</span>/all-backup ]];<span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;还没有全备份，请先进行全备份！&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行/usr/bin/innobackupex --user=back --password=&#x27;tang1611&#x27; --no-timestamp --incremental --incremental-basedir=$&#123;backup_dir&#125;/$&#123;old_dir&#125; $&#123;backup_dir&#125;/$&#123;new_dir&#125; &amp;&gt; /tmp/mysql-backup.log</span></span><br><span class="line"></span><br><span class="line">tail -n 1 /tmp/mysql-backup.log | grep <span class="string">&#x27;completed OK!&#x27;</span></span><br><span class="line"><span class="keyword">if</span> [[ $? -eq 0 ]];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;new_dir&#125;</span>&quot;</span> &gt; /tmp/mysql-backup.txt</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;备份失败&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将已提交的事物重放</span></span><br><span class="line">innobackupex --apply-log --redo-only /usr/<span class="built_in">local</span>/back/mysql/all/2020-03-16_11-38-50</span><br><span class="line"><span class="comment">#整合第一个增量备份数据到全量备份数据里面</span></span><br><span class="line">innobackupex --apply-log --redo-only /usr/<span class="built_in">local</span>/back/mysql/all/2020-03-16_11-38-50 --incremental-dir=//usr/<span class="built_in">local</span>/back/mysql/increment/2020-03-16_11-40-50</span><br><span class="line"><span class="comment">#整合第二个增量备份数据到全量备份数据里面</span></span><br><span class="line">innobackupex --apply-log --redo-only /usr/<span class="built_in">local</span>/back/mysql/all/2020-03-16_11-38-50 --incremental-dir=//usr/<span class="built_in">local</span>/back/mysql/increment/2020-03-16_11-45-30</span><br><span class="line"><span class="comment">#此时数据已经是最后一次增量备份的数据了，执行恢复</span></span><br><span class="line">innobackupex --copy-back /usr/<span class="built_in">local</span>/back/mysql/all/2020-03-16_11-38-50</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下MySQL安装(转)</title>
      <link href="2020/03/15/Linux%E4%B8%8BMySQL%E5%AE%89%E8%A3%85-%E8%BD%AC/"/>
      <url>2020/03/15/Linux%E4%B8%8BMySQL%E5%AE%89%E8%A3%85-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://www.jianshu.com/p/276d59cbc529">https://www.jianshu.com/p/276d59cbc529</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx笔记四-高可用</title>
      <link href="2020/03/15/Nginx%E7%AC%94%E8%AE%B0%E5%9B%9B-%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>2020/03/15/Nginx%E7%AC%94%E8%AE%B0%E5%9B%9B-%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>nginx+keepalived实现高可用</p><a id="more"></a><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>192.168.186.100 虚拟vip<br>192.168.186.129 centos7 安装nginx、keepalived的服务器<br>192.168.186.130 centos7 安装nginx、keepalived的服务器<br>192.168.186.128 centos7 提供真实服务的httpd服务器<br>192.168.186.131 centos7 提供真实服务的httpd服务器<br>本地windows</p><h2 id="关闭防火墙和selinux"><a href="#关闭防火墙和selinux" class="headerlink" title="关闭防火墙和selinux"></a>关闭防火墙和selinux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="httpd服务器配置"><a href="#httpd服务器配置" class="headerlink" title="httpd服务器配置"></a>httpd服务器配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd -y</span><br><span class="line"><span class="comment">#在/etc/httpd/conf/httpd.conf修改httpd端口</span></span><br><span class="line">listen 8080</span><br><span class="line"><span class="comment">#在192.168.186.128的/var/www/html中创建a.html,向里面写入web1，在192.168.186.131的/var/www/html中创建a.html,向里面写入web2</span></span><br><span class="line"><span class="built_in">echo</span> web1 &gt; a.html</span><br><span class="line"><span class="built_in">echo</span> web2 &gt; a.html</span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure><h2 id="nginx负载均衡器配置"><a href="#nginx负载均衡器配置" class="headerlink" title="nginx负载均衡器配置"></a>nginx负载均衡器配置</h2><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">                server 192.168.186.128:8080;</span><br><span class="line">                server 192.168.186.131:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  192.168.186.100;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://myserver/a.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keepalived配置"><a href="#keepalived配置" class="headerlink" title="keepalived配置"></a>keepalived配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#192.168.186.128配置</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.186.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#192.168.186.131配置</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.186.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看虚拟vip是否生成、是否能够自动漂移"><a href="#查看虚拟vip是否生成、是否能够自动漂移" class="headerlink" title="查看虚拟vip是否生成、是否能够自动漂移"></a>查看虚拟vip是否生成、是否能够自动漂移</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在MASTER主机上使用ip address命令查看ens33网卡下是否存在192.168.186.100</span></span><br><span class="line">ip address</span><br><span class="line"><span class="comment">#ping 192.168.186.100是否通</span></span><br><span class="line">ping 192.168.186.100</span><br><span class="line"><span class="comment">#停止MASTER主机的keepalived，查看虚拟ip是否漂移到BACKUP主机</span></span><br><span class="line">systemctl stop keepalived</span><br><span class="line">ip address</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在windows浏览器输入192.168.186.100:80,成功轮询访问到真实httpd服务器的页面</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx笔记三-负载均衡</title>
      <link href="2020/03/15/Nginx%E7%AC%94%E8%AE%B0%E4%B8%89-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2020/03/15/Nginx%E7%AC%94%E8%AE%B0%E4%B8%89-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>192.168.186.129 centos7 安装nginx的负载均衡器<br>192.168.186.128 centos7 提供真实服务的httpd服务器<br>192.168.186.130 centos7 提供真实服务的httpd服务器<br>本地windows</p><a id="more"></a><h2 id="关闭防火墙和selinux"><a href="#关闭防火墙和selinux" class="headerlink" title="关闭防火墙和selinux"></a>关闭防火墙和selinux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="httpd服务器配置"><a href="#httpd服务器配置" class="headerlink" title="httpd服务器配置"></a>httpd服务器配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd -y</span><br><span class="line"><span class="comment">#在/etc/httpd/conf/httpd.conf修改httpd端口</span></span><br><span class="line">listen 8080</span><br><span class="line"><span class="comment">#在192.168.186.128的/var/www/html中创建a.html,向里面写入web1，在192.168.186.130的/var/www/html中创建a.html,向里面写入web2</span></span><br><span class="line"><span class="built_in">echo</span> web1 &gt; a.html</span><br><span class="line"><span class="built_in">echo</span> web2 &gt; a.html</span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure><h2 id="nginx负载均衡器配置"><a href="#nginx负载均衡器配置" class="headerlink" title="nginx负载均衡器配置"></a>nginx负载均衡器配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">                server 192.168.186.128:8080;</span><br><span class="line">                server 192.168.186.130:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  192.168.186.129;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://myserver/a.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>windows端浏览器输入192.168.186.129:80看是否能正常轮询切换到web1、web2</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果出现返回页面报400错误，有可能是invalid hostname,也可能是其他http header导致服务器端无法正常解析。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx笔记二(反向代理)</title>
      <link href="2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>192.168.186.129 centos7<br>本地windows</p><a id="more"></a><h2 id="关闭防火墙和selinux"><a href="#关闭防火墙和selinux" class="headerlink" title="关闭防火墙和selinux"></a>关闭防火墙和selinux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="安装nginx、httpd"><a href="#安装nginx、httpd" class="headerlink" title="安装nginx、httpd"></a>安装nginx、httpd</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx -y</span><br><span class="line">yum install httpd -y</span><br><span class="line"><span class="comment">#在/etc/httpd/conf/httpd.conf修改httpd端口</span></span><br><span class="line">listen 8080</span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure><h2 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开windows的C:\Windows\System32\drivers\etc的hosts文件，追加一行</span></span><br><span class="line">192.168.186.129  www.abctwf.com</span><br></pre></td></tr></table></figure><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  192.168.186.129;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器访问<a href="http://www.abctwf.com,即访问httpd首页/">www.abctwf.com，即访问httpd首页</a><br><img src= "/img/loading.gif" data-lazy-src="/2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/a1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx笔记一</title>
      <link href="2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="nginx概述"><a href="#nginx概述" class="headerlink" title="nginx概述"></a>nginx概述</h2><p>Nginx是一个高性能的HTTP和反向代理服务器，特点占用内存少，并发能力强，常用于负载均衡服务器。</p><a id="more"></a><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>nginx不仅可以做反向代理，实现负载均衡，还可用作正向代理来进行上网等功能。<br>正向代理：例如大陆用户需要访问谷歌，但是一般来说，大陆用户是无法访问谷歌的，这时候需要在浏览器设置代理，通过代理服务器访问谷歌。简单说正向代理代理的是客户端。<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%B8%80/a1.png"><br>反向代理：其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外暴露的就是一个服务器，暴露的是反向代理服务器，隐藏真实服务器的ip地址。简单的说正向代理即代理的是服务端<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%B8%80/a2.png"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>客户端发送多个请求到服务端，服务端处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回客户端。<br>这种架构模式会造成服务器处理请求日益缓慢，并发特别大的时候，甚至可能导致服务器宕机，一旦服务端宕机，整个系统就直接崩溃了，而负载均衡技术就可以解决这种业务情景。<br>负载均衡就是客户端在发送请求，请求并不直接到达真实服务器，而是最先到达负载均衡器，负载均衡器将请求按照某种算法分配到不同的真实服务器，以减少真实服务器的并发量。如果真实服务器当中某个服务器出现问题，负载均衡器会将其剔除，并不会影响到系统的正常运行。<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%B8%80/a3.png"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同服务器来解析，这样加快了解析速度，降低了单个服务器的压力。<br><img src= "/img/loading.gif" data-lazy-src="/2020/03/08/Nginx%E7%AC%94%E8%AE%B0%E4%B8%80/a4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java生产环境下性能监控</title>
      <link href="2020/01/30/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
      <url>2020/01/30/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文是基于jdk1.8，其他版本稍有不同</p><a id="more"></a><h2 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h2><p>（1）标准参数<br>-help<br>-server -client<br>-version -showversion<br>-cp -classpath<br>（2）X参数<br>非标准化参数<br>-Xint:解释执行<br>-Xcomp:第一次使用就编译成本地代码<br>-Xmixed:混合模式，由JVM自己来决定是否编译成本地代码<br><img src= "/img/loading.gif" data-lazy-src="/2020/01/30/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/a1.png"><br>（3）XX参数<br>非标准化参数<br>相对不稳定<br>主要用于JVM调优和Debug</p><h2 id="XX参数分类"><a href="#XX参数分类" class="headerlink" title="XX参数分类"></a>XX参数分类</h2><p>（1）Boolean类型<br>格式：-XX:[+-]<name>表示启动或禁用name属性<br>比如：-XX:+UseConcMarkSweepGC<br>      -XX:+UseG1GC<br>（2）非Boolean类型<br>格式：-XX:<name>=<value>表示name属性的值是value<br>比如：-XX:MaxGCPauseMillis=500<br>      XX:GCTimeRatio=19</value></name></name></p><h2 id="jps工具"><a href="#jps工具" class="headerlink" title="jps工具"></a>jps工具</h2><p>查看java进程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常用指令</span></span><br><span class="line">jps</span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure><h2 id="jinfo工具"><a href="#jinfo工具" class="headerlink" title="jinfo工具"></a>jinfo工具</h2><p>查看Java进程运行的JVM参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常用指令</span></span><br><span class="line">jinfo -flag &lt;JVM参数&gt; pid</span><br></pre></td></tr></table></figure><h2 id="jstat工具"><a href="#jstat工具" class="headerlink" title="jstat工具"></a>jstat工具</h2><p>监控进程的类装载、内存、垃圾收集、JIT编译等运行数据<br>jstat &lt;参数&gt; pid time(ms) count</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每隔1s显示类装载信息，输出10次</span></span><br><span class="line">jstat -class 14589 1000 10</span><br><span class="line"><span class="comment">#每隔1s显示gc信息，输出10次</span></span><br><span class="line">jstat -gc 14589 1000 10</span><br><span class="line"><span class="comment">#每隔1s显示JIT编译信息，输出10次</span></span><br><span class="line">jstat -compiler 14589 1000 10</span><br><span class="line">jstat -printcompilation 14589 1000 10</span><br></pre></td></tr></table></figure><p>-gc输出结果<br>S0C、S1C、S0U、S1U:S0和S1的总量与使用量<br>EC、EU：Eden区总量与使用量<br>OC、OU：Old区总量与使用量<br>MC、MU：Metaspace区总量与使用量<br>CCSC、CCSU：压缩类空间总量与使用量<br>YGC、YGCT：YoungGC的次数与时间<br>FGC、FGCT：FullGC的次数与时间<br>GCT：总的GC时间</p><h2 id="查看JVM运行时的参数"><a href="#查看JVM运行时的参数" class="headerlink" title="查看JVM运行时的参数"></a>查看JVM运行时的参数</h2><p>（1）PrintFlagsFinal</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></table></figure><p>（2）jinfo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -flag MaxHeapSize 14589</span><br></pre></td></tr></table></figure><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/01/30/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/a2.png"></p><h2 id="内存溢出演示"><a href="#内存溢出演示" class="headerlink" title="内存溢出演示"></a>内存溢出演示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class OutOfMemory &#123;</span><br><span class="line">    List&lt;User&gt; list=new ArrayList&lt;User&gt;();</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/memory&quot;</span>)</span><br><span class="line">    public void <span class="function"><span class="title">memory</span></span>() &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(new User(i++,UUID.randomUUID().toString()));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更快的看出效果，设置JVM参数：-Xmx32M -Xms32M<br><img src= "/img/loading.gif" data-lazy-src="/2020/01/30/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/a3.png"></p><h2 id="导出内存映像文件"><a href="#导出内存映像文件" class="headerlink" title="导出内存映像文件"></a>导出内存映像文件</h2><p>（1）内存溢出时自动导出<br>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=./<br><img src= "/img/loading.gif" data-lazy-src="/2020/01/30/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/a4.png"><br>（2）使用jmap命令手动导出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=heap &lt;pid&gt;</span><br></pre></td></tr></table></figure><h2 id="Tomcat优化"><a href="#Tomcat优化" class="headerlink" title="Tomcat优化"></a>Tomcat优化</h2><h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>相关文档：docs/config/http.html<br>（1）maxConnections：最大连接数，tomcat能够最大处理的最大连接数<br>（2）acceptCount：默认是100，如果请求超过了maxConnections，可以配置一个队列，将连接压到队列里。（不需要太大，太大没有意义）<br>（3）maxThreads：工作线程数，默认值是200，同一个时间点上能够同时处理的并发请求数<br>（4）minSpareThreads：最小空闲的工作线程。不能设置太小，万一请求突然变多，线程数来不及增加。</p><h3 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h3><p>（1）autoDeploy：当tomcat运行时，是否需要周期性检查有新的web应用，来部署新的应用。生产环境，建议设置为false<br>（2）enableLookups：是否需要tomcat进行DNS域名解析。生产环境，建议设置为false<br>（3）reloadable：是否需要tomcat监控/WEB-INF/classes/ and /WEB-INF/lib的变化。生产环境，建议设置为false<br>（4）tomcat有3中方式启动：bio、nio、apr<br>BIO：bio是阻塞式IO操作，使用java io技术，即每一个请求都要创建一个线程来进行处理。缺点：并发量高时，线程数较多，占资源<br>NIO：使用java nio技术，能够通过少量的线程处理大量的请求，nio是基于java中非阻塞IO操作的API实现，比传统的i/o处理方式有更高的并发运行性能<br>APR(Apache Portable Runtime/Apache可移植运行时库)：apr是从操作系统级别解决异步IO问题，大幅度提高服务器的并发处理性能，也是Tomcat生产环境运行的首选方式<br>tomcat低版本是使用BIO的，tomcat8以后默认使用NIO方式，在service.xml文件中找到此处</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;8091&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">               connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">               redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>修改成下面这个，可以使用apr的模式启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;8091&quot;</span> protocol=<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span> connectionTimeout=<span class="string">&quot;20000&quot;</span> redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="Session优化"><a href="#Session优化" class="headerlink" title="Session优化"></a>Session优化</h3><p>如果没有使用原生的Session，并且页面是使用JSP写的，建议禁用Session</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#JSP禁用Session</span></span><br><span class="line">&lt;% page session=<span class="string">&quot;false&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><h2 id="Nginx优化"><a href="#Nginx优化" class="headerlink" title="Nginx优化"></a>Nginx优化</h2><h3 id="配置线程数和并发数"><a href="#配置线程数和并发数" class="headerlink" title="配置线程数和并发数"></a>配置线程数和并发数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">worker_processes 4; <span class="comment">#cpu</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 10240; <span class="comment">#每个进程打开的最大连接数，包含了nginx与客户端和nginx与upsteam之间的连接</span></span><br><span class="line">    multi_accept on; <span class="comment">#可以一次建立多个连接</span></span><br><span class="line">    use epoll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置后端Server的长连接"><a href="#配置后端Server的长连接" class="headerlink" title="配置后端Server的长连接"></a>配置后端Server的长连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upsteam server_pool&#123;</span><br><span class="line">    server localhost:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server localhost:8081 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    keepalive 300; <span class="comment">#300个长连接</span></span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    proxy_pass http://server_pool/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置压缩"><a href="#配置压缩" class="headerlink" title="配置压缩"></a>配置压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_disable <span class="string">&quot;MSIE [1-6]\.(?!.*SV1)&quot;</span>;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_types text/plain text/css application/javascript application/x-javascript application/json application/xml application/vnd.ms-fontobject application/x-font-ttf application/svg+xml application/x-icon;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_static on; <span class="comment">#如果有压缩好的，直接使用</span></span><br></pre></td></tr></table></figure><h3 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件/etc/sysctl.conf</span></span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1 <span class="comment">#防止一个套接字在有过多试图连接到达时引起过载</span></span><br><span class="line">sysctl -w net.core.somaxconn=1024 <span class="comment">#默认128，连接队列</span></span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout=10 <span class="comment">#timewait的超时时间，系统默认时间较长，可以改小一点</span></span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse=1 <span class="comment">#os直接使用tomeout的连接</span></span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle=0 <span class="comment">#回收禁用</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件/etc/security/limits.conf</span></span><br><span class="line">* hard nofile 204800</span><br><span class="line">* soft nofile 204800</span><br><span class="line">* soft core unlimited</span><br><span class="line">* soft stack 204800</span><br></pre></td></tr></table></figure><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sendfile on; <span class="comment">#减少文件在应用和内核之间拷贝</span></span><br><span class="line">tcp_nopush on; <span class="comment">#当数据包达到一定大小再发送</span></span><br><span class="line">tcp_nodelay off; <span class="comment">#有数据包随时发送</span></span><br></pre></td></tr></table></figure><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>-Xms -Xmx：最小堆内存   最大堆内存<br>-XX:NewSize -XX:MaxNewSize:新生代大小   最大新生代大小<br>-XX:NewRatio -XX:SurvivorRatio:young区与old区的比例   Eden区域和Survivor区域<br>-XX:MetaspaceSize -XX:MaxMetaspaceSize:Metaspace区域大小   最大Metaspace区域大小<br>-XX:+UseCompressedClassPointers:是否启用压缩的类指针，启用之后就会产生CCS区域（默认占有1024M大小）<br>-XX:CompressedClassSpaceSize:设置压缩区域大小</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>（1）标记-清除<br>定义：算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有<br>缺点：效率不高，标记和清除两个过程的效率都不高。产生碎片，碎片太多会导致提前GC。<br>（2）复制<br>定义：它将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完时，它将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。<br>优缺点：实现简单，运行高效，但是空间利用率低。<br>（3）标记-整理<br>定义：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br>优缺点：没有了内存碎片，但是整理内存比较耗时。</p><h3 id="分带垃圾回收"><a href="#分带垃圾回收" class="headerlink" title="分带垃圾回收"></a>分带垃圾回收</h3><p>Young区用复制算法<br>Old区对象存活时间较长，采用标记清除或标记整理算法</p><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p>对象优先在Eden区分配<br>大对象直接进入老年代：-XX:PretenureSizeThreshold<br>长期存活的对象进入老年代：-XX:MaxTenuringThreshold -XX:+PrintTenuringDistribution -XX:TargetSurvivorRatio</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>（1）串行收集器Serial：Serial、Serial Old<br>进行垃圾收集时，必须暂停所有工作线程，直到完成，即”Stop The World”；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC -XX:+UseSerialOldGC</span><br></pre></td></tr></table></figure><p>（2）并行收集器Parallel：Parallel Scavenge、Parallel Old，吞吐量优先<br>Server模式下的默认收集器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启参数</span></span><br><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br><span class="line"><span class="comment">#开启多少个GC线程</span></span><br><span class="line">-XX:ParallelGCThreads=&lt;N&gt;</span><br><span class="line">CPU&gt;8 N=5/8</span><br><span class="line">CPU&lt;8 N=CPU个数</span><br></pre></td></tr></table></figure><p>（3）并发收集器Concurrent：CMS、G1，响应时间优先</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启参数</span></span><br><span class="line">CMS: -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class="line">G1: -XX:+UseG1GC</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CMS的相关参数</span></span><br><span class="line">-XX:ConcGCThreads:并发的GC线程数</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction:Old区内存占用多少时触发FullGC，默认92%</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly:是否动态调</span><br><span class="line">-XX:+CMSScavengeBeforeRemark:FullGC之前先做YGC</span><br><span class="line">-XX:+CMSClassUnloadingEnabled:启用回收Perm区</span><br></pre></td></tr></table></figure><h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><p>（1）优先调整堆的大小让服务器自己来选择<br>（2）如果内存小于100M，使用串行收集器<br>（3）如果是单核，并且没有停顿时间的要求，串行或者JVM自己选<br>（4）如果允许停顿时间超过1秒，选择并行或者JVM自己选<br>（5）如果响应时间必须小于1秒，选择并发收集器</p><h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>（1）定义<br>将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；<br>Region：内存分区<br>SATB：它是通过Root Tracing得到的，GC开始时后存活对象的快照<br>RSet：记录了其他Region中对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）<br>（2）YoungGC<br>1）新对象进入Eden区<br>2）存活对象拷贝到Survivor区<br>3）存活时间达到年龄阈值时，对象晋升到Old区<br>而G1垃圾收集器不是FullGC，是MixedGC（回收所有Young和部分Old）<br>（3）MixedGC时机<br>InitiatingHeapOccupancyPercent:堆占有率达到这个值则触发global concurrent marking(全局并发标记)，默认值45%<br>G1HeapWastePercent:在global concurrent marking标记之后，可以知道区有多少空间要被回收，在每次YGC之后和再次发生MixedGC之前，会检查垃圾占比是否达到此参数值，只有达到了，下次才会发生MixedGC</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MixedGC相关参数</span></span><br><span class="line">G1MixedGCLiveThresholdPercent  <span class="comment">#Old区的region被回收时候的存活对象占比</span></span><br><span class="line">G1MixedGCCountTarget  <span class="comment">#一次global concurrent marking之后，最多执行Mixed GC的次数</span></span><br><span class="line">G1OldCSetRegionThresholdPercent  <span class="comment">#一次Mixed GC中能够被选入CSet的最多old区的region数量</span></span><br><span class="line">-XX:+UseG1GC  <span class="comment">#开启G1</span></span><br><span class="line">-XX:G1HeapRegionSize=n  <span class="comment">#region的大小，1-32M，2048个</span></span><br><span class="line">-XX:MaxGCPauseMillis=200  <span class="comment">#最大停顿时间</span></span><br><span class="line">-XX:G1NewSizePercent -XX:G1MaxNewSizePercent  <span class="comment">#young区占比  young区最大占比</span></span><br><span class="line">-XX:G1ReservePercent=10  <span class="comment">#保留防止Survivor区to space溢出</span></span><br><span class="line">-XX:ParallelGCThreads=n  <span class="comment">#SWT线程数</span></span><br><span class="line">-XX:ConcGCThreads=n  <span class="comment">#并发线程数=1/4*并行</span></span><br></pre></td></tr></table></figure><p>（4）注意<br>年轻代大小：避免使用-Xmn、-XX:NewRatio等显式设置Young区大小，会覆盖暂停时间目标<br>暂停时间目标：暂停时间不要太苛刻，其吞吐量是90%的应用程序时间和10%的垃圾回收时间，太苛刻会直接影响到吞吐量</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix邮件告警</title>
      <link href="2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/"/>
      <url>2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>下面我们对内存使用率进行监控，并设置邮件告警。</p><a id="more"></a><h2 id="设置QQ邮箱"><a href="#设置QQ邮箱" class="headerlink" title="设置QQ邮箱"></a>设置QQ邮箱</h2><p>在设置-&gt;账户里面，开启POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，获取授权码<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a1.png"></p><h2 id="设置自定义监控项的key"><a href="#设置自定义监控项的key" class="headerlink" title="设置自定义监控项的key"></a>设置自定义监控项的key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入被监控主机,打开/etc/zabbix/zabbix-agent.conf，在最后一行添加</span></span><br><span class="line">UserParameter=memory_used,free -m | awk <span class="string">&#x27;/^Mem/ &#123;print $3/$2&#125;&#x27;</span></span><br><span class="line"><span class="comment">#重启agent服务</span></span><br><span class="line">systemctl restart zabbix-agent</span><br><span class="line"><span class="comment">#在zabbix server端测试key</span></span><br><span class="line">zabbix_get -s 192.168.136.135 -p 10050 -k memory_used</span><br></pre></td></tr></table></figure><h2 id="创建监控项"><a href="#创建监控项" class="headerlink" title="创建监控项"></a>创建监控项</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a2.png"></p><h2 id="创建监控图形"><a href="#创建监控图形" class="headerlink" title="创建监控图形"></a>创建监控图形</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a4.png"></p><h2 id="添加触发器"><a href="#添加触发器" class="headerlink" title="添加触发器"></a>添加触发器</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a5.png"></p><h2 id="安装mailx工具，配置Zabbix服务端外部邮箱"><a href="#安装mailx工具，配置Zabbix服务端外部邮箱" class="headerlink" title="安装mailx工具，配置Zabbix服务端外部邮箱"></a>安装mailx工具，配置Zabbix服务端外部邮箱</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装mailx</span></span><br><span class="line">yum install mailx</span><br><span class="line"><span class="comment">#配置/etc/mail.rc文件，在末尾加上smtp相关配置</span></span><br><span class="line"><span class="built_in">set</span> bsdcompat</span><br><span class="line"><span class="built_in">set</span> from=1335402049@qq.com</span><br><span class="line"><span class="built_in">set</span> smtp=smtp.qq.com</span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=1335402049@qq.com</span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=pdicfqdoyvkmhiie  <span class="comment">#授权码</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-login</span><br></pre></td></tr></table></figure><h2 id="邮件脚本"><a href="#邮件脚本" class="headerlink" title="邮件脚本"></a>邮件脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装dos2unix，解决邮件内容为附件问题</span></span><br><span class="line">yum install dos2unix</span><br><span class="line"></span><br><span class="line"><span class="comment">#在/usr/lib/zabbix/alertscripts目录下编写mail.sh脚本</span></span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">export.UTF-8</span><br><span class="line">FILE=/tmp/mailtmp.txt </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$3</span>&quot;</span> &gt;<span class="variable">$FILE</span> </span><br><span class="line">dos2unix -k <span class="variable">$FILE</span>   <span class="comment">#解决邮件内容为附件问题</span></span><br><span class="line">/bin/mail -s <span class="string">&quot;<span class="variable">$2</span>&quot;</span> <span class="variable">$1</span> &lt; <span class="variable">$FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#给mail.sh授权</span></span><br><span class="line">chmod +x mail.sh</span><br><span class="line"><span class="comment">#创建临时文件并授权</span></span><br><span class="line">touch /tmp/mailtmp.txt</span><br><span class="line">chown zabbix.zabbix /tmp/mailtmp.txt</span><br></pre></td></tr></table></figure><h2 id="添加报警媒介类型"><a href="#添加报警媒介类型" class="headerlink" title="添加报警媒介类型"></a>添加报警媒介类型</h2><p>点击管理-&gt;报警媒介类型-&gt;创建媒体类型<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a6.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a7.png"></p><h2 id="创建用户群组"><a href="#创建用户群组" class="headerlink" title="创建用户群组"></a>创建用户群组</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a8.png"></p><h2 id="创建用户添加到用户组，设置报警媒介"><a href="#创建用户添加到用户组，设置报警媒介" class="headerlink" title="创建用户添加到用户组，设置报警媒介"></a>创建用户添加到用户组，设置报警媒介</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a9.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a10.png"><br>最后添加用户</p><h2 id="创建动作"><a href="#创建动作" class="headerlink" title="创建动作"></a>创建动作</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a11.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a12.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a13.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a14.png"><br>最后添加动作,我这边只是添加了报警操作，也可以添加报警恢复后操作。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在被监控机器上执行,等待报警</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/<span class="built_in">test</span> count=3 bs=1024M</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/30/Zabbix%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/a15.png"></p>]]></content>
      
      
      <categories>
          
          <category> Zabbix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix安装与部署</title>
      <link href="2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>zabbix是一款基于web界面的提供分布式系统监控以及网络监视功能的企业级的开源解决方案<br>zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制让系统管理员快速定位，解决存在的各种问题<br>zabbix由2部分构成，zabbix server与可选组件zabbix agent<br>zabbix server可以通过SNMP、zabbix agent、ping、端口监视等方法提供对远程服务器、网络状态的监视，以及数据收集等功能，它可以运行在Linux、Solaris、HP-UX、ALX、Free BSD、Open BSD，OS X等平台上</p><a id="more"></a><h2 id="关闭防火墙和selinux"><a href="#关闭防火墙和selinux" class="headerlink" title="关闭防火墙和selinux"></a>关闭防火墙和selinux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h2 id="安装httpd服务"><a href="#安装httpd服务" class="headerlink" title="安装httpd服务"></a>安装httpd服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y httpd</span><br><span class="line"><span class="comment">#启动httpd，并设置开机自启</span></span><br><span class="line">systemctl start httpd &amp;&amp; systemctl <span class="built_in">enable</span> httpd</span><br><span class="line"><span class="comment">#查看httpd启动情况</span></span><br><span class="line">systemctl status httpd</span><br></pre></td></tr></table></figure><h2 id="安装mariadb数据库"><a href="#安装mariadb数据库" class="headerlink" title="安装mariadb数据库"></a>安装mariadb数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y mariadb mariadb-server</span><br><span class="line"><span class="comment">#启动mariadb，并设置开机自启</span></span><br><span class="line">systemctl start mariadb &amp;&amp; systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line"><span class="comment">#查看mariadb启动情况</span></span><br><span class="line">systemctl status mariadb</span><br><span class="line"><span class="comment">#查看是否安装成功</span></span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><h2 id="安装php环境"><a href="#安装php环境" class="headerlink" title="安装php环境"></a>安装php环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y php php-mysql</span><br></pre></td></tr></table></figure><h2 id="安装zabbix"><a href="#安装zabbix" class="headerlink" title="安装zabbix"></a>安装zabbix</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载包</span></span><br><span class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</span><br><span class="line"><span class="comment">#安装zabbix包</span></span><br><span class="line">yum install -y zabbix-server-mysql zabbix-get zabbix-web zabbix-web-mysql zabbix-agent zabbix-sender</span><br><span class="line"><span class="comment">#创建一个zabbix库，并设置为utf8的字符编码格式</span></span><br><span class="line">mysql</span><br><span class="line">create database zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;</span><br><span class="line"><span class="comment">#查看是否创建成功</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="comment">#创建zabbix数据库账户、设置密码并且授权</span></span><br><span class="line">grant all privileges on zabbix.* to zabbix@localhost identified by <span class="string">&#x27;zabbix&#x27;</span>;</span><br><span class="line"><span class="comment">#刷新</span></span><br><span class="line">flush privileges;</span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换到此目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/doc/zabbix-server-mysql-3.4.15</span><br><span class="line"><span class="comment">#进行解压</span></span><br><span class="line">gunzip create.sql.gz</span><br><span class="line"><span class="comment">#对表进行导入</span></span><br><span class="line">mysql</span><br><span class="line">use zabbix;</span><br><span class="line"><span class="built_in">source</span> create.sql</span><br></pre></td></tr></table></figure><h2 id="配置zabbix文件"><a href="#配置zabbix文件" class="headerlink" title="配置zabbix文件"></a>配置zabbix文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入此目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/zabbix</span><br><span class="line"><span class="comment">#对zabbix_server.conf进行配置，主要修改一下内容</span></span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br><span class="line">DBSocket=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="comment">#运行zabbix-server服务，并设置开机自启</span></span><br><span class="line">systemctl start zabbix-server &amp;&amp; systemctl <span class="built_in">enable</span> zabbix-server</span><br></pre></td></tr></table></figure><h2 id="配置php"><a href="#配置php" class="headerlink" title="配置php"></a>配置php</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入此目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/httpd/conf.d</span><br><span class="line"><span class="comment">#配置时间,编辑zabbix.conf文件，在&lt;IfModule mod_php5.c&gt;标签内增加一行 </span></span><br><span class="line">php_value date.timezone Asia/shanghai</span><br><span class="line"><span class="comment">#重启httpd服务</span></span><br><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure><p>##登录zabbix网址设置<br>在浏览器输入zabbix server服务器地址，我的是192.168.136.134/zabbix<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a1.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a2.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a3.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a4.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a5.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a6.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a7.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a8.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a9.png"></p><p>##添加对zabbix server自身的监控<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a10.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动zabbix server主机上的agent，并设置自启</span></span><br><span class="line">systemctl start zabbix-agent &amp;&amp; systemctl <span class="built_in">enable</span> zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a11.png"><br>在C:\Windows\Fonts找到黑体文件，复制到zabbix server的/usr/share/zabbix/fonts<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a12.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a13.png"></p><h2 id="在被监控主机安装zabbix-agent"><a href="#在被监控主机安装zabbix-agent" class="headerlink" title="在被监控主机安装zabbix agent"></a>在被监控主机安装zabbix agent</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#临时关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#准备zabbix-repo</span></span><br><span class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</span><br><span class="line"><span class="comment">#安装zabbix-agent</span></span><br><span class="line">yum -y install zabbix-agent</span><br><span class="line"><span class="comment">#配置主服务器地址,打开/etc/zabbix/zabbix-agent.conf文件，修改一下内容</span></span><br><span class="line">Server=192.168.136.134</span><br><span class="line">ServerActive=192.168.136.134</span><br><span class="line">Hostname=web1</span><br><span class="line"><span class="comment">#启动zabbix-agent,设置开机自启</span></span><br><span class="line">systemctl start zabbix-agent &amp;&amp; systemctl <span class="built_in">enable</span> zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="使用zabbix-server监控主机"><a href="#使用zabbix-server监控主机" class="headerlink" title="使用zabbix server监控主机"></a>使用zabbix server监控主机</h2><p>（1）点击配置-&gt;主机群组-&gt;创建主机群组<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a14.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a15.png"><br>（2）点击配置-&gt;主机-&gt;创建主机<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a16.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a17.png"><br>（3）点击配置-&gt;模板-&gt;创建模板<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a18.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a19.png"><br>（4）创建自定义key<br>我们来对web1服务器的远程登录数进行监控</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看远程登录数</span></span><br><span class="line">who |wc -l</span><br><span class="line"><span class="comment">#在被监控主机，打开/etc/zabbix/zabbix-agent.conf文件，在最后一行添加一行 </span></span><br><span class="line">UserParameter=user_connect,who|wc -l</span><br><span class="line"><span class="comment">#重启zabbix-agent服务</span></span><br><span class="line">systemctl restart zabbix-agent</span><br><span class="line"><span class="comment">#通过zabbix server主机查看自定义key是否生效</span></span><br><span class="line">zabbix_get -s 192.168.136.135 -p 10050 -k user_connect</span><br></pre></td></tr></table></figure><p>（5）添加监控项<br>重新进入刚刚创建的模板，创建监控项<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a20.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a21.png"><br>（6）为监控项创建图形，点击配置-&gt;主机-&gt;图形<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a22.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a23.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a24.png"><br>（7）查看图形<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/24/Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/a25.png"></p>]]></content>
      
      
      <categories>
          
          <category> Zabbix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS+Keepalived实现高可用</title>
      <link href="2019/11/23/LVS-Keepalived%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>2019/11/23/LVS-Keepalived%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Keepalived是专门针对LVS设计的一款强大的辅助工具，主要用来提供故障切换和健康检查功能–判断LVS负载调度器、节点服务器的可用性，及时隔离并替换新的服务器，当故障主机恢复后将其重新加入集群。</p><a id="more"></a><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>客户端：192.168.136.130<br>虚拟IP：192.168.136.100<br>LVS1：192.168.136.133<br>LVS2: 192.168.136.137<br>RS1： 192.168.136.134<br>RS2： 192.168.136.135</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#临时关闭selinux</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="LVS配置"><a href="#LVS配置" class="headerlink" title="LVS配置"></a>LVS配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载lvs和keepalived</span></span><br><span class="line">yum install -y keepalived -y ipvsadm</span><br><span class="line"><span class="comment">#修改LVS1的/etc/keepalived下的keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS-1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;      </span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.136.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.136.100 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind DR      </span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.136.134 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_port 80</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.136.135 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_port 80</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">#修改LVS2的/etc/keepalived下的keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS-2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;      </span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.136.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.136.100 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind DR      </span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.136.134 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_port 80</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.136.135 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_port 80</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">#开机重启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> keepalived &amp;&amp; systemctl <span class="built_in">enable</span> ipvsadm</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">reboot </span><br></pre></td></tr></table></figure><h2 id="RS1服务器配置"><a href="#RS1服务器配置" class="headerlink" title="RS1服务器配置"></a>RS1服务器配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装httpd服务</span></span><br><span class="line">yum install -y httpd</span><br><span class="line"><span class="comment">#写页面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;web1&quot;</span> &gt;  /var/www/html/index.html</span><br><span class="line"><span class="comment">#启动服务，开机自启</span></span><br><span class="line">systemctl start httpd &amp;&amp; systemctl <span class="built_in">enable</span> httpd</span><br><span class="line"><span class="comment">#配置lo:0回管口</span></span><br><span class="line">cp /etc/sysconfig/network-scripts/ifcfg-lo /etc/sysconfig/network-scripts/ifcfg-lo:0</span><br><span class="line"><span class="comment">#修改ifcfg-lo:0文件</span></span><br><span class="line">DEVICE=lo:0</span><br><span class="line">IPADDR=192.168.136.100</span><br><span class="line">NETMASK=255.255.255.255</span><br><span class="line">ONBOOT=yes</span><br><span class="line"><span class="comment">#在/etc/rc.local里面添加</span></span><br><span class="line">/sbin/route add -host 192.168.136.100 dev lo:0</span><br><span class="line"><span class="comment">#在/etc/sysctl.conf添加</span></span><br><span class="line">net.ipv4.conf.all.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.all.arp_announce = 2</span><br><span class="line">net.ipv4.conf.default.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.default.arp_announce = 2</span><br><span class="line">net.ipv4.conf.lo.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.lo.arp_announce = 2</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">reboot </span><br></pre></td></tr></table></figure><h2 id="RS2配置"><a href="#RS2配置" class="headerlink" title="RS2配置"></a>RS2配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装httpd服务</span></span><br><span class="line">yum install -y httpd</span><br><span class="line"><span class="comment">#写页面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;web2&quot;</span> &gt;  /var/www/html/index.html</span><br><span class="line"><span class="comment">#启动服务，开机自启</span></span><br><span class="line">systemctl start httpd &amp;&amp; systemctl <span class="built_in">enable</span> httpd</span><br><span class="line"><span class="comment">#配置lo:0回管口</span></span><br><span class="line">cp /etc/sysconfig/network-scripts/ifcfg-lo /etc/sysconfig/network-scripts/ifcfg-lo:0</span><br><span class="line"><span class="comment">#修改ifcfg-lo:0文件</span></span><br><span class="line">DEVICE=lo:0</span><br><span class="line">IPADDR=192.168.136.100</span><br><span class="line">NETMASK=255.255.255.255</span><br><span class="line">ONBOOT=yes</span><br><span class="line"><span class="comment">#在/etc/rc.local里面添加</span></span><br><span class="line">/sbin/route add -host 192.168.136.100 dev lo:0</span><br><span class="line"><span class="comment">#在/etc/sysctl.conf添加</span></span><br><span class="line">net.ipv4.conf.all.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.all.arp_announce = 2</span><br><span class="line">net.ipv4.conf.default.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.default.arp_announce = 2</span><br><span class="line">net.ipv4.conf.lo.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.lo.arp_announce = 2</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">reboot </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Keepalived </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS Keepalived </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS工作模式实验</title>
      <link href="2019/11/17/LVS%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C/"/>
      <url>2019/11/17/LVS%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要演示LVS工作模式的DR模式和NAT模式实战</p><a id="more"></a><h2 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>192.168.136.130 客户机<br>192.168.136.133 LVS负载均衡器   虚拟IP地址 192.168.136.123<br>192.168.136.134 RS真实服务器    虚拟IP地址 192.168.136.123<br>192.168.136.135 RS真实服务器    虚拟IP地址 192.168.136.123</p><h3 id="LVS负载均衡器配置"><a href="#LVS负载均衡器配置" class="headerlink" title="LVS负载均衡器配置"></a>LVS负载均衡器配置</h3><p>（1）LVS准备VIP和路由</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置虚拟ip</span></span><br><span class="line">ifconfig ens33:0 192.168.136.123 broadcast 192.168.136.255 netmask 255.255.255.0</span><br><span class="line"><span class="comment">#配置路由</span></span><br><span class="line">route add -net 192.168.136.123 dev ens33:0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置路由转发</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward=1                   <span class="comment">#开启路由转发</span></span><br><span class="line">net.ipv4.conf.all.send_redirects=0      <span class="comment">#禁用路由重定向转发</span></span><br><span class="line">net.ipv4.conf.ens33.send_redirects=0    <span class="comment">#禁用ens33转发重定向报文</span></span><br><span class="line">net.ipv4.conf.default.send_redirects=0  <span class="comment">#禁用转发默认重定向报文</span></span><br></pre></td></tr></table></figure><p>（2）LVS设置负载均衡条目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装ipvsadm</span></span><br><span class="line">yum install ipvsadm -y</span><br><span class="line"><span class="comment">#擦除虚拟服务器的所有规则</span></span><br><span class="line">ipvsadm -C</span><br><span class="line"><span class="comment">#添加一个虚拟的服务器地址(-A表示添加一个虚拟ip -t表示tcp地址 -s表示调度算法 rr表示轮询)</span></span><br><span class="line">ipvsadm -A -t 192.168.136.123:80 -s rr</span><br><span class="line"><span class="comment">#添加LVS转发规则（-a表示添加一个真实服务器地址 -t表示tcp地址 -r表示真实服务器地址 -g表示dr直接路由）</span></span><br><span class="line">ipvsadm -a -t 192.168.136.123:80 -r 192.168.136.134:80 -g  </span><br><span class="line">ipvsadm -a -t 192.168.136.123:80 -r 192.168.136.135:80 -g  </span><br></pre></td></tr></table></figure><p>（3）LVS让配置永久生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将配置写入文件中</span></span><br><span class="line">ipvsadm-save&gt; /etc/sysconfig/ipvsadm</span><br><span class="line"><span class="comment">#开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ipvsadm</span><br></pre></td></tr></table></figure><h3 id="RS服务器配置"><a href="#RS服务器配置" class="headerlink" title="RS服务器配置"></a>RS服务器配置</h3><p>（1）安装服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装httpd服务</span></span><br><span class="line">yum install httpd -y</span><br><span class="line"><span class="comment">#写页面</span></span><br><span class="line"><span class="built_in">echo</span> web1 &gt; /var/www/html/index.html</span><br><span class="line"><span class="comment">#启动httpd服务</span></span><br><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure><p>（2）给RS服务器lo网卡配置子网掩码为32位的vip</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rs1</span></span><br><span class="line">ifconfig lo:0 192.168.136.123/32</span><br><span class="line"><span class="comment">#rs2</span></span><br><span class="line">ifconfig lo:0 192.168.136.123/32  </span><br></pre></td></tr></table></figure><p>（3）给RS服务器设置内核参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#忽略arp请求，不允许收</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore </span><br><span class="line"><span class="comment">#为了让vip发包出去，但允许发</span></span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce </span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#访问虚拟vip</span></span><br><span class="line">curl http://192.168.136.130:80</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/17/LVS%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C/a1.png"></p><h2 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h2><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><p>客户机        VMNET0  192.168.0.101<br>LVS负载均衡器 VMNET0  192.168.0.102<br>              VMNET2  192.168.136.136<br>RS真实服务器  VMNET2  192.168.136.134<br>RS真实服务器  VMNET2  192.168.136.135 </p><h3 id="RS服务器配置-1"><a href="#RS服务器配置-1" class="headerlink" title="RS服务器配置"></a>RS服务器配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写页面</span></span><br><span class="line"><span class="built_in">echo</span> web1 &gt; /var/www/html/index.html</span><br><span class="line"><span class="comment">#启动httpd服务</span></span><br><span class="line">systemctl start httpd</span><br><span class="line">route add -net 192.168.0.0/24 gw 192.168.136.136</span><br></pre></td></tr></table></figure><h3 id="LVS配置"><a href="#LVS配置" class="headerlink" title="LVS配置"></a>LVS配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启路由转发</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="comment">#安装ipvsadm</span></span><br><span class="line">yum install ipvsadm -y</span><br><span class="line"><span class="comment">#添加调度算法</span></span><br><span class="line">ipvsadm -A -t 192.168.0.102:80 -s rr</span><br><span class="line">添加LVS转发规则（-a表示添加一个真实服务器地址 -t表示tcp地址 -r表示真实服务器地址 -m表示nat模式）</span><br><span class="line">ipvsadm -a -t 192.168.0.102:80 -r 192.168.136.134:80 -m</span><br><span class="line">ipvsadm -a -t 192.168.0.102:80 -r 192.168.136.135:80 -m</span><br><span class="line"><span class="comment">#将配置写入文件中</span></span><br><span class="line">ipvsadm-save&gt; /etc/sysconfig/ipvsadm</span><br><span class="line"><span class="comment">#开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ipvsadm</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://192.168.0.102:80</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/11/17/LVS%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C/a2.png"></p>]]></content>
      
      
      <categories>
          
          <category> LVS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识LVS</title>
      <link href="2019/11/17/%E5%88%9D%E8%AF%86LVS/"/>
      <url>2019/11/17/%E5%88%9D%E8%AF%86LVS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是章文嵩博士主导的开源负载均衡项目，LVS本身并不提供服务，只是把特定的请求转发给相应的真实服务器（real server），从而实现集群环境中的负载均衡。</p><a id="more"></a><h2 id="LVS工作模式"><a href="#LVS工作模式" class="headerlink" title="LVS工作模式"></a>LVS工作模式</h2><p>LVS工作模式主要有DR直接路由模式、NAT模式、TUN模式、FULL-NAT模式，这边我们主要讲DR模式和NAT模式。</p><h3 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h3><p>（1）客户端将请求发往前端的负载均衡器，请求报文源地址是CIP，目标地址是VIP<br>（2）负载均衡器收到报文后，发现请求的是规则里面存在的地址，那么它将客户端请求报文的源MAC地址改为自己DIP的MAC地址，将目标MAC地址改为RIP的MAC地址，并将此请求发给RS服务器<br>（3）RS发现请求报文中目的MAC是自己的，就会将此报文接收下来，处理完请求报文后，将响应报文通过lo接口送给eth0网卡直接发送给客户端<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/17/%E5%88%9D%E8%AF%86LVS/a1.png"></p><h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><p>（1）客户端将请求发往前端的负载均衡器，此请求报文源地址是CIP（客户端IP），目标地址VIP（负载均衡器地址）<br>（2）负载均衡器接收到报文后，发现请求是规则里面存在的地址，那么它将客户端请求报文的目标IP地址改成了RS服务器的地址，并根据算法发送出去<br>（3）RS服务器发现报文的目标地址是自己的，所以就会响应请求，并将响应报文返回给负载均衡器<br>（4）负载均衡器接收到响应的报文，将源地址修改为本机地址并发送给客户端<br><img src= "/img/loading.gif" data-lazy-src="/2019/11/17/%E5%88%9D%E8%AF%86LVS/a2.png"></p><h2 id="LVS负载均衡算法"><a href="#LVS负载均衡算法" class="headerlink" title="LVS负载均衡算法"></a>LVS负载均衡算法</h2><p>根据前面的介绍，我们了解LVS常用的两种工作模式的原理，但不管环境中采用哪种工作模式，调度算法是LVS的核心技术，下面列举了LVS常用的几种调度算法。<br>（1）RR<br>RR即轮询算法，是按依次循环的方式将请求均匀调度到不同的服务器，该算法最大的特点就是实现简单，轮询算法假设所有服务器处理请求的能力都一样，调度器会将所有的请求平均分配至真实服务器。<br>（2）WRR<br>WRR即加权轮询算法，主要是对轮询算法的一种优化，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，权值越大，处理的请求就越多，比如服务器A权值是1，服务器B权值是2，那么调度器调度至B的请求是A的2倍。<br>（3）LC<br>LC即最小连接调度算法，是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过活跃的连接数来估计服务器的情况。<br>（4）WLC<br>WLC即加权最小连接调度算法，是最小连接调度的超集。各个服务器的权值表示处理性能，服务器缺省权值为1，系统管理员可以动态地设置权值。加权最小连接调度在调度新的连接时尽可能使服务器已建立连接数和权值成比例。</p>]]></content>
      
      
      <categories>
          
          <category> LVS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible role的基本使用</title>
      <link href="2019/11/09/Ansible-role%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2019/11/09/Ansible-role%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>roles是ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中</p><a id="more"></a><p>复杂场景：建议使用roles,代码复用性高</p><h2 id="Roles各目录作用"><a href="#Roles各目录作用" class="headerlink" title="Roles各目录作用"></a>Roles各目录作用</h2><p>/roles/project/:项目名称，有以下子目录<br>    1）files/：存放由copy或script模板等调用的文件<br>    2）templates/：template模块查找所需要模板文件的目录<br>    3）tasks/：定义task，role的基本元素，至少应该包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含<br>    4）handlers/：至少包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含<br>    5）vars/：定义变量，至少应该包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含<br>    6）meta/：定义当前角色的特殊设定及其依赖关系，至少应该包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含<br>    7）default/：设定默认变量时使用此目录中的main.yml文件</p><h2 id="role应用示例"><a href="#role应用示例" class="headerlink" title="role应用示例"></a>role应用示例</h2><p>有一个nginx role：<br>    1)group:nginx<br>    2)user:nginx<br>    3)yum:install<br>    4)template:nginx.conf.j2<br>    5)handlers、notify<br>    6)service<br>(1)首先进入/etc/ansible/roles目录里面，创建一个nginx的角色目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir nginx</span><br></pre></td></tr></table></figure><p>(2)进入nginx角色目录，创建相应的文件夹,将nginx.conf.j2模板放入templates目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#templates存放模板，tasks存放任务</span></span><br><span class="line">mkdir templates tasks handlers</span><br></pre></td></tr></table></figure><p>（3）进入tasks,创建任务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建group.yml,写任务</span></span><br><span class="line">- name: create group</span><br><span class="line">  group: name=nginx state=present</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建user.yml,写任务</span></span><br><span class="line">- name: create user</span><br><span class="line">  user: name=nginx group=nginx system=yes shell=/sbin/nologin</span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建yum.yml,写任务</span></span><br><span class="line">- name: install</span><br><span class="line">  yum: name=nginx</span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建copy.yml,写任务</span></span><br><span class="line">- name: copy</span><br><span class="line">  template: src=/etc/ansible/roles/nginx/templates/nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  notify: restart</span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建service.yml,写任务</span></span><br><span class="line">- name: start</span><br><span class="line">  service: name=nginx state=started enabled=yes</span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建mian.yml,写任务</span></span><br><span class="line">- include: group.yml</span><br><span class="line">- include: user.yml</span><br><span class="line">- include: yum.yml</span><br><span class="line">- include: copy.yml</span><br><span class="line">- include: service.yml</span><br></pre></td></tr></table></figure><p>（4）进入handlers目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建restart.yml</span></span><br><span class="line">- name: restart</span><br><span class="line">  service: name=nginx state=restarted</span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建mian.yml</span></span><br><span class="line">- include: restart.yml</span><br></pre></td></tr></table></figure><p>（5）进入/etc/ansible，创建nginx_role.yml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- hosts: 192.168.136.128</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - role: nginx</span><br></pre></td></tr></table></figure><p>（6）运行nginx_role.yml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检查nginx.role.yml</span></span><br><span class="line">ansible-playbook -C nginx_role.yml</span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line">ansible-playbook nginx_role.yml</span><br></pre></td></tr></table></figure><p>此外，nginx_role.yml还可以添加标签，添加多个角色;甚至可以添加when条件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- hosts: 192.168.136.128</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: nginx, tags: [<span class="string">&#x27;web&#x27;</span>,<span class="string">&#x27;nginx&#x27;</span>] &#125;</span><br><span class="line">    - &#123; role: httpd, tags: [<span class="string">&#x27;web&#x27;</span>,<span class="string">&#x27;httpd&#x27;</span>],when: ansible_distribution_major_version == <span class="string">&quot;7&quot;</span> &#125;</span><br><span class="line">    - &#123; role: app, tags: <span class="string">&quot;app&quot;</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible playbook的基本使用</title>
      <link href="2019/11/09/Ansible-playbook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2019/11/09/Ansible-playbook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>playbook是一个不同于ansible命令行方式的模式，其功能更强大灵活。简单地说，playbook是一个非常适合部署复杂应用程序的基础，它可以定制部署，可以按照指定的操作有序执行，支持同步和异步方式。playbook是通过yaml或者yml格式进行描述定义的。</p><a id="more"></a><h2 id="playbook核心元素"><a href="#playbook核心元素" class="headerlink" title="playbook核心元素"></a>playbook核心元素</h2><p>（1）Hosts   执行远程主机列表<br>（2）Tasks   任务集<br>（3）Varniables   内置变量或自定义变量在playbook中调用<br>（4）Templates   模板，可替代模板文件中的变量并实现一些简单逻辑的文件<br>（5）Handlers和notify   这2个需要结合使用，由特定条件触发的操作，满足条件方才执行<br>（6）tags  标签，指定某条任务执行，用于运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然非常长。此时，如果确定没有变化，可以通过tags跳过一些代码片段</p><h2 id="运行playbook"><a href="#运行playbook" class="headerlink" title="运行playbook"></a>运行playbook</h2><h3 id="运行playbook的方式"><a href="#运行playbook的方式" class="headerlink" title="运行playbook的方式"></a>运行playbook的方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook &lt;filename.yml&gt; ...[options]</span><br></pre></td></tr></table></figure><h3 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h3><p>–check  只检查可能会发生的改变，但不真正执行操作<br>–list  列出运行任务的主机<br>–limit  只针对主机列表中的主机执行<br>-v  显示过程 -vv -vvv更详细</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook file.yml --check</span><br><span class="line">ansible-playbook file.yml</span><br><span class="line">ansible-playbook file.yml --<span class="built_in">limit</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="写一个playbook"><a href="#写一个playbook" class="headerlink" title="写一个playbook"></a>写一个playbook</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: install httpd package</span><br><span class="line">      yum: name=httpd</span><br><span class="line">      tags: inshttpd</span><br><span class="line">    - name: copy conf file</span><br><span class="line">      copy: src=/home/httpd.conf dest=/etc/httpd/conf backup=yes</span><br><span class="line">    - name:  start service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">      tags: shttpd</span><br><span class="line">    </span><br><span class="line"><span class="comment">#检查文件</span></span><br><span class="line">ansible-playbook ansible-playbook.yml --check</span><br><span class="line"><span class="comment">#运行playbook</span></span><br><span class="line">ansible-playbook ansible-playbook.yml</span><br><span class="line"><span class="comment">#执行对应标签的任务</span></span><br><span class="line">ansible-playbook -t inshttpd ansible-playbook.yml </span><br></pre></td></tr></table></figure><p>现在有一种场景：有些服务，我们需要修改它的配置文件，但是它的服务一直是开启状态。当我们修改了配置文件，再次执行这个playbook，那么就会产生一个问题，当进行启动服务的任务时，ansible会因为这个服务已经运行了，而不去重新执行这个任务，就会导致修改的配置没有重启服务而无法生效。handlers和notify就是解决这种场景的方法。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: install httpd package</span><br><span class="line">      yum: name=httpd</span><br><span class="line">      tags: inshttpd</span><br><span class="line">    - name: copy conf file</span><br><span class="line">      copy: src=/home/httpd.conf dest=/etc/httpd/conf backup=yes</span><br><span class="line">      notify: restart service</span><br><span class="line">    - name:  start service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">      tags: shttpd</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart service</span><br><span class="line">      service: name=httpd state=restarted</span><br></pre></td></tr></table></figure><h2 id="playbook中变量的使用"><a href="#playbook中变量的使用" class="headerlink" title="playbook中变量的使用"></a>playbook中变量的使用</h2><p>变量名：仅能由字母、数字、下划线组成，且只能以字母开头<br>变量来源：<br>    （1）ansible setup facts远程主机的所有变量都可以直接调用<br>    （2）在/etc/ansible/hosts中定义<br>        1）普通变量：主机组中主机单独定义，优先级高于公共变量<br>        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.136.128 http_port=80</span><br></pre></td></tr></table></figure><br>        2）公共变量：针对主机组中所有主机统一定义变量<br>        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>]</span><br><span class="line">192.168.136.128 http_port=80</span><br><span class="line">[<span class="built_in">test</span>:vars]</span><br><span class="line">nodename=www</span><br></pre></td></tr></table></figure><br>    （3）通过命令行指定变量(参数-e)，优先级最高<br>    （4）在playbook中定义<br>        vars:<br>        - var1: value1<br>        - var2: value2<br>    （5）在role中定义</p><h2 id="使用变量文件"><a href="#使用变量文件" class="headerlink" title="使用变量文件"></a>使用变量文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat vars.yml</span><br><span class="line">var1: httpd</span><br><span class="line">var2: nginx</span><br><span class="line"></span><br><span class="line">cat ansible-playbook.yml</span><br><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  vars_files:</span><br><span class="line">    - vars.yml</span><br><span class="line">  tasks:</span><br><span class="line">    - name: create httpd <span class="built_in">log</span></span><br><span class="line">      file: name=/home/&#123;&#123;var1&#125;&#125;.<span class="built_in">log</span> state=touch</span><br><span class="line">    - name: create nginx <span class="built_in">log</span></span><br><span class="line">      file: name=/home/&#123;&#123;var2&#125;&#125;.<span class="built_in">log</span> state=touch</span><br></pre></td></tr></table></figure><h2 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h2><p>（1）文本文件，嵌套有脚本（使用模板编程语言编写）<br>（2）Jinja2语言，使用字面量，有下面形式<br>    字符串：使用单引号或双引号<br>    数字：整数，浮点数<br>    列表：[item1,item2,…]<br>    元祖：(item1,item2,…)<br>    字典：{key1:value1,key2:value2,…}<br>    布尔型：true/false<br>（3）算术运算：+,-,*，/,//,%,**<br>（4）比较操作：==,!=,&gt;,&gt;=,&lt;,&lt;=<br>（5）逻辑运算：and,or,not<br>（6）流表达式：For If When</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install</span><br><span class="line">      yum: name=nginx</span><br><span class="line">    - name: copy template</span><br><span class="line">      template: src=/home/nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=nginx state=started enabled=yes</span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>条件测试：如果需要根据变量、facts或者此前任务的执行结果来做某task执行与否的前提时要用条件测试，通过when语句实现，在task中使用，jinja2的语法格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ansible_os_family是系统的变量</span></span><br><span class="line">tasks:</span><br><span class="line">  - name: <span class="string">&quot;shutdown RedHat flavored systems&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: /sbin/shutdown -h now</span><br><span class="line">    when: ansible_os_family == <span class="string">&quot;RedHat&quot;</span></span><br></pre></td></tr></table></figure><h2 id="with-items"><a href="#with-items" class="headerlink" title="with_items"></a>with_items</h2><p>迭代：当有需要重复性执行的任务时，可以使用迭代机制<br>对迭代项的引用，固定变量名为“item”<br>要在task中使用with_items给定要迭代的元素列表</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: create some files</span><br><span class="line">      file: name=/home/&#123;&#123; item &#125;&#125; state=touch</span><br><span class="line">      with_items:</span><br><span class="line">        - file1</span><br><span class="line">        - file2</span><br><span class="line">        - file3</span><br></pre></td></tr></table></figure><p>with_items还可以做到迭代嵌套自变量的情况<br>现在有一种情景：（1）创建user1、user2、user3三个用户（2）创建group1、group2、group3（3）user1所属组是group1，user2所属组是group2，user3所属组是group3</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: add some groups</span><br><span class="line">      group: name=&#123;&#123; item &#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - group1</span><br><span class="line">        - group2</span><br><span class="line">        - group3</span><br><span class="line">    - name: add some users</span><br><span class="line">      user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - &#123;name: <span class="string">&#x27;user1&#x27;</span>, group: <span class="string">&#x27;group1&#x27;</span>&#125;</span><br><span class="line">        - &#123;name: <span class="string">&#x27;user2&#x27;</span>, group: <span class="string">&#x27;group2&#x27;</span>&#125;</span><br><span class="line">        - &#123;name: <span class="string">&#x27;user3&#x27;</span>, group: <span class="string">&#x27;group3&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="For"><a href="#For" class="headerlink" title="For"></a>For</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ansible-playbook.yml</span><br><span class="line">- hosts: <span class="built_in">test</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    ports:</span><br><span class="line">      - 81</span><br><span class="line">      - 82</span><br><span class="line">      - 83</span><br><span class="line">  tasks:</span><br><span class="line">    - name: copy template</span><br><span class="line">      template: src=/home/nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">cat nginx.conf.j2</span><br><span class="line">&#123;% <span class="keyword">for</span> port <span class="keyword">in</span> ports %&#125;</span><br><span class="line">server&#123;</span><br><span class="line">  listen: &#123;&#123; port &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible的基本使用</title>
      <link href="2019/11/07/Ansible%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2019/11/07/Ansible%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本章主要介绍ansible基本模块的使用</p><a id="more"></a><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><p>在远程主机执行命令，默认模块，可忽略-m选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动远程主机vsftpd服务</span></span><br><span class="line">ansible <span class="built_in">test</span> -m <span class="built_in">command</span> -a <span class="string">&#x27;service vsftpf start&#x27;</span></span><br><span class="line"><span class="comment">#此命令不支持$VARNAME &lt;&gt; | ; &amp;等，建议使用shell模块实现</span></span><br><span class="line">ansible <span class="built_in">test</span> -m <span class="built_in">command</span> -a <span class="string">&#x27;echo tang1611 | passwd --stdin tang&#x27;</span> 不成功</span><br></pre></td></tr></table></figure><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>和command相似</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible <span class="built_in">test</span> -m shell -a <span class="string">&#x27;echo tang1611 | passwd --stdin tang&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h2><p>运行脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible <span class="built_in">test</span> -m script -a f1.sh</span><br></pre></td></tr></table></figure><h2 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h2><p>从控制端复制文件到被控端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#src指向的是要复制的文件，dest指向目标的目录，owner是所属组，mode是权限,backup是备份。如果目标存在，默认是覆盖的</span></span><br><span class="line">ansible <span class="built_in">test</span> -m copy -a <span class="string">&quot;src=/root/f1.sh dest=/tem/f2.sh owner=tang mode=600 backup=yes&quot;</span></span><br><span class="line"><span class="comment">#也可以利用content向文件写内容</span></span><br><span class="line">ansible <span class="built_in">test</span> -m copy -a <span class="string">&quot;content=&#x27;hello world\n&#x27; dest=/tem/f1.txt&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>从被控端取文件到控制端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#src是被控端需要复制的文件，dest是目标目录</span></span><br><span class="line">ansible <span class="built_in">test</span> -m fetch -a <span class="string">&quot;src=/root/a.sh dest=/data/scripts&quot;</span></span><br></pre></td></tr></table></figure><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>设置文件属性</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible <span class="built_in">test</span> -m file -a <span class="string">&quot;name=/home/var.log state=touch&quot;</span></span><br><span class="line">ansible <span class="built_in">test</span> -m file -a <span class="string">&quot;path=/root/a.sh owner=tang mode=755&quot;</span></span><br><span class="line">ansible <span class="built_in">test</span> -m file -a <span class="string">&#x27;src=/app/testfile dest/app/testfile-link state=link&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Hostname"><a href="#Hostname" class="headerlink" title="Hostname"></a>Hostname</h2><p>管理主机名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible <span class="built_in">test</span> -m hostname -a <span class="string">&quot;name=webhost&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h2><p>计划任务，支持时间：minute,hour,day,month,weekday</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启任务</span></span><br><span class="line">ansible <span class="built_in">test</span> -m cron -a <span class="string">&quot;minute=* weekday=1,3,5 job=&#x27;/usr/sbin/ntpdate 192.168.136.128 &amp;&gt;/dev/null&#x27; name=Synctime&quot;</span></span><br><span class="line"><span class="comment">#禁用任务</span></span><br><span class="line">ansible <span class="built_in">test</span> -m cron -a <span class="string">&#x27;disabled=yes job=&#x27;</span>/usr/sbin/ntpdate 192.168.136.128 &amp;&gt;/dev/null<span class="string">&#x27; name=Synctime&#x27;</span></span><br><span class="line"><span class="comment">#删除任务</span></span><br><span class="line">ansible <span class="built_in">test</span> -m cron -a <span class="string">&#x27;state=absent job=&#x27;</span>/usr/sbin/ntpdate 192.168.136.128 &amp;&gt;/dev/null<span class="string">&#x27; name=Synctime&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Yum"><a href="#Yum" class="headerlink" title="Yum"></a>Yum</h2><p>管理包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">ansible <span class="built_in">test</span> -m yum -a <span class="string">&quot;name=httpd state=latest&quot;</span></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">ansible <span class="built_in">test</span> -m yum -a <span class="string">&quot;name=httpd state=absent&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ansible-doc"><a href="#ansible-doc" class="headerlink" title="ansible-doc"></a>ansible-doc</h2><p>ansible模块文档说明</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出支持的模块</span></span><br><span class="line">ansible-doc -l</span><br><span class="line"><span class="comment">#ping模块功能说明</span></span><br><span class="line">ansible-doc ping</span><br></pre></td></tr></table></figure><h2 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h2><p>连接<a href="https://galaxy.ansible.com下载相应的roles/">https://galaxy.ansible.com下载相应的roles</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出所以已安装的galaxy</span></span><br><span class="line">ansible-galaxy list</span><br><span class="line"><span class="comment">#安装galaxy</span></span><br><span class="line">ansible-galaxy install geerlingguy.redis</span><br><span class="line"><span class="comment">#删除galaxy</span></span><br><span class="line">ansible-galaxy remove geerlingguy.redis</span><br></pre></td></tr></table></figure><h2 id="ansible-console"><a href="#ansible-console" class="headerlink" title="ansible-console"></a>ansible-console</h2><p>可交互执行命令，支持tab</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#连接交互式工具,会提示输入一个密码，随便输入后回车即可，不允许空值</span></span><br><span class="line">ansible-console</span><br><span class="line"><span class="comment">#切换到test组</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment">#列出组中主机</span></span><br><span class="line">list</span><br><span class="line"><span class="comment">#查询每个主机的网卡信息</span></span><br><span class="line">ifconfig ens33</span><br><span class="line"><span class="comment">#退出ansible-console环境</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible安装</title>
      <link href="2019/11/07/Ansible%E5%AE%89%E8%A3%85/"/>
      <url>2019/11/07/Ansible%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要介绍自动化运维工具ansible的安装</p><a id="more"></a><h2 id="查看ansible软件包信息"><a href="#查看ansible软件包信息" class="headerlink" title="查看ansible软件包信息"></a>查看ansible软件包信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info ansible</span><br></pre></td></tr></table></figure><h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ansible -y</span><br></pre></td></tr></table></figure><h2 id="设置ssh连接"><a href="#设置ssh连接" class="headerlink" title="设置ssh连接"></a>设置ssh连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改被控主机的etc/ssh/sshd_config,GSSAPIAuthentication设置为no,UseDNS 设置为no</span></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">systemctl restart sshd</span><br><span class="line"><span class="comment">#在主控机上生成ssh公钥，直接回车即可</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment">#将公钥拷贝到被控机</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.136.128</span><br><span class="line"><span class="comment">#测试是否可以连接</span></span><br><span class="line">ssh root@192.168.136.128</span><br></pre></td></tr></table></figure><h2 id="使用ansible连接被控机"><a href="#使用ansible连接被控机" class="headerlink" title="使用ansible连接被控机"></a>使用ansible连接被控机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建议将/etc/ansible/ansible.cfg下的host_key_checking取消注释</span></span><br><span class="line"><span class="comment">#日志功能，将/etc/ansible/ansible.cfg下的log_path注释取消</span></span><br><span class="line"><span class="comment">#添加被控主机到/etc/ansible/hosts文件</span></span><br><span class="line">cat &gt; /etc/ansible/hosts &lt;&lt; EOF</span><br><span class="line">192.168.136.128</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#使用ansible连接</span></span><br><span class="line">ansible 192.168.136.128 -m ping</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansibleble </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubeadm部署Kubernetes集群</title>
      <link href="2019/10/26/Kubeadm%E9%83%A8%E7%BD%B2Kubernetes%E9%9B%86%E7%BE%A4/"/>
      <url>2019/10/26/Kubeadm%E9%83%A8%E7%BD%B2Kubernetes%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>kubeadm是官方社区推出的快速部署kubernetes集群的工具</p><a id="more"></a><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><p>（1）一台或多台CentOS7.x-86_x64操作系统<br>（2）硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多<br>（3）集群中所有机器之间网络互通，可以访问外网，需要拉取镜像</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#关闭swap</span></span><br><span class="line">swapoff -a   临时</span><br><span class="line"><span class="comment">#添加主机名与IP对应关系（记得设置主机名）</span></span><br><span class="line">vi /etc/hosts</span><br><span class="line">192.168.136.129 k8s-master</span><br><span class="line">192.168.136.128 k8s-node1</span><br><span class="line">192.168.136.130 k8s-node2</span><br><span class="line"><span class="comment">#将桥接的IPv4流量传递到iptables的链</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更新yum</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment">#安装需要的软件包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data 1vm2</span><br><span class="line"><span class="comment">#设置yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">yum install docker-ce-17.12.1.ce</span><br><span class="line"><span class="comment">#设置开机自启，启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="添加阿里云yum软件源"><a href="#添加阿里云yum软件源" class="headerlink" title="添加阿里云yum软件源"></a>添加阿里云yum软件源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="安装kubeadm、kubelet和kebectl"><a href="#安装kubeadm、kubelet和kebectl" class="headerlink" title="安装kubeadm、kubelet和kebectl"></a>安装kubeadm、kubelet和kebectl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-1.15.0 kubeadm-1.15.0 kubectl-1.15.0</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure><h2 id="部署kubernetes-master"><a href="#部署kubernetes-master" class="headerlink" title="部署kubernetes master"></a>部署kubernetes master</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在master执行初始化</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.136.129 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.15.0 \</span><br><span class="line">--service-cidr=10.1.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><h2 id="使用kubectl工具"><a href="#使用kubectl工具" class="headerlink" title="使用kubectl工具"></a>使用kubectl工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="comment">#查看节点</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h2 id="安装pod网络插件CNI"><a href="#安装pod网络插件CNI" class="headerlink" title="安装pod网络插件CNI"></a>安装pod网络插件CNI</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><h2 id="将node加入集群"><a href="#将node加入集群" class="headerlink" title="将node加入集群"></a>将node加入集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.136.129:6443 --token 1w09k0.ugs74mxzljn7yk72 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:cac0b9e628461383dde738b184111c6b735b2010a6eb637b1a9b7ffc297a7537 </span><br></pre></td></tr></table></figure><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当节点都是Ready状态，表示集群初始化成功</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment">#查看kube-system名称空间pod状态,全部运行为成功</span></span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose（四）</title>
      <link href="2019/10/05/Docker-Compose%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>2019/10/05/Docker-Compose%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本章主要介绍Docker Compose的基础概念，以及如何编写Docker Compose文件</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Docker Compose是一个工具，它可以通过yml文件定义多容器的docker应用，通过一条命令就可以根据yml文件去创建或者管理多个应用</p><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p>docker-compose.yml由Services、Networks、volumes三个部分组成。<br>一个Services代表一个container，这个container可以从dockerhub的image来创建，也可以从本地的Dockerfile build出来的image来创建<br>Servides的启动类似于docker run，我们可以给其指定network和volume，所以可以给service指定network和volume的引用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:9.4</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;db-data:/var/lib/postgresql/data&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - back-tier</span><br><span class="line">volumes:</span><br><span class="line">  db-date:</span><br><span class="line">networks:</span><br><span class="line">  front-tier:</span><br><span class="line">    driver: bridge</span><br><span class="line">  back-tier: </span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    build: ./worker</span><br><span class="line">    links:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">    networks:</span><br><span class="line">      - back-tier</span><br><span class="line">networks:</span><br><span class="line">  back-tier: </span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><h2 id="编写一个docker-compose-yml"><a href="#编写一个docker-compose-yml" class="headerlink" title="编写一个docker-compose.yml"></a>编写一个docker-compose.yml</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  </span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: mysql</span><br><span class="line">      WORDPRESS_DB_PASSWORD: root</span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line">  </span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql-data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql-data:</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  my-bridge:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载docker-compose到/usr/local/bin目录下</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#授予docke-compose可执行权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h2 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动docker-compose.yml文件</span></span><br><span class="line">docker-compose -f docker-compose.yml up -d</span><br><span class="line"><span class="comment">#查看正在运行的docker-compose容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"><span class="comment">#停止docker-compose运行的容器</span></span><br><span class="line">docker-compose stop</span><br><span class="line"><span class="comment">#停止并删除正在运行的容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"><span class="comment">#进入docker-compose中的一个容器</span></span><br><span class="line">docker-compose <span class="built_in">exec</span> mysql bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的持久化存储（三）</title>
      <link href="2019/09/21/Docker%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>2019/09/21/Docker%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本章主要介绍一下Docker的持久化存储</p><a id="more"></a><p>对于Docker Container layer来说，我们在容器里面写数据，这个数据仅限于这个创建的容器，当我们把容器删掉，意味着我们的数据也会被删除，这种情况是我们不能接受的，所以Docker就引入了持久化机制。</p><p>Docker持久化数据的方案：<br>（1）基于本地文件系统的Volume：可以在执行Docker create或者Docker run时，通过-v参数将宿主机的目录作为容器的数据卷。这部分功能便是基于本地文件系统的volume管理<br>（2）基于plugin的Volume：支持第三方存储方案，比如NAS，AWS</p><p>Volume的类型<br>（1）收管理的data Volume，由docker后台自动创建<br>（2）绑定挂载的Volume，具体挂载位置可以由用户指定</p><h2 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h2><p>需要在Docker file中指定volume持久化路径</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建mysql容器</span></span><br><span class="line">docker run -d --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD mysql</span><br><span class="line"><span class="comment">#查看刚刚创建的mysql容器默认创建的volume</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="comment">#查看volume详细信息</span></span><br><span class="line">docker inspect 11e7434f01b8764f33d6ce0298c15ea49890e43f0e93a265ddb0f8d487b0b9aa</span><br><span class="line"><span class="comment">#删除mysql1容器</span></span><br><span class="line">docker rm mysql1</span><br><span class="line"><span class="comment">#再次查看volume，发现还在</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><h2 id="Bind-Mouting"><a href="#Bind-Mouting" class="headerlink" title="Bind Mouting"></a>Bind Mouting</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-v表示将容器/etc/nginx目录映射到宿主机home/n1</span></span><br><span class="line">docker run -d --name nginx -v /home/n1:/etc/nginx nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker网络（二）</title>
      <link href="2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前言已经介绍了Docker的镜像和容器，下面主要涉及Docker网络相关知识</p><a id="more"></a><h2 id="Linux网络命名空间"><a href="#Linux网络命名空间" class="headerlink" title="Linux网络命名空间"></a>Linux网络命名空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入一个已经运行的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 61512b362534 bash</span><br><span class="line"><span class="comment">#执行ip a</span></span><br><span class="line">ip a</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a1.png"><br>会发现有一些接口，这就是这个容器自己的network namespace<br>退出容器，在宿主机执行ip a<br><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a2.png"><br>显示出来的是宿主机的network namespace，这2个network namespace是不一样的<br>再创建第二个容器，2个docker容器的network namespace也是不一样的，他们之前是隔离开的。并且2个容器是可以ping通的</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a3.png"><br>（1）创建network namespace</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建2个network namespace</span></span><br><span class="line">ip netns add test1</span><br><span class="line">ip netns add test2</span><br><span class="line"><span class="comment">#删除network namespace</span></span><br><span class="line">ip netns delete test1</span><br><span class="line"><span class="comment">#查看创建network namespace</span></span><br><span class="line">ip netns list</span><br></pre></td></tr></table></figure><p>（2）查看test1、test2的network namespace信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> test1 ip a</span><br><span class="line">ip netns <span class="built_in">exec</span> test2 ip a</span><br></pre></td></tr></table></figure><p>（3） 使lo端口up起来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> test1 ip link <span class="built_in">set</span> dev lo</span><br></pre></td></tr></table></figure><p>（4） 添加一对veth接口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link add veth-test1 <span class="built_in">type</span> veth peer name veth-test2</span><br></pre></td></tr></table></figure><p>（5） 将veth-test1添加到test1中，veth-test2添加到test2</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> veth-test1 netns test1</span><br><span class="line">ip link <span class="built_in">set</span> veth-test2 netns test2</span><br><span class="line"><span class="comment">#查看是否添加成功</span></span><br><span class="line">ip netns <span class="built_in">exec</span> test1 ip link</span><br><span class="line">ip netns <span class="built_in">exec</span> test2 ip link</span><br></pre></td></tr></table></figure><p>（6）给veth-test1、veth-test2分配端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> test1 ip addr add 192.168.1.1/24 dev veth-test1</span><br><span class="line">ip netns <span class="built_in">exec</span> test2 ip addr add 192.168.1.2/24 dev veth-test2</span><br></pre></td></tr></table></figure><p>（7）将veth-test1、veth-test2端口up,并查看ip</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#up端口</span></span><br><span class="line">ip netns <span class="built_in">exec</span> test1 ip link <span class="built_in">set</span> dev veth-test1</span><br><span class="line">ip netns <span class="built_in">exec</span> test2 ip link <span class="built_in">set</span> dev veth-test2</span><br><span class="line"><span class="comment">#查看ip</span></span><br><span class="line">ip netns <span class="built_in">exec</span> test1 ip a</span><br><span class="line">ip netns <span class="built_in">exec</span> test2 ip a</span><br></pre></td></tr></table></figure><p>（8）查看互相是否可以通信</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> test1 ping 192.168.1.2</span><br><span class="line">ip netns <span class="built_in">exec</span> test2 ping 192.168.1.1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a4.png"><br>其实docker容器之间的通信也是通过这种技术实现的</p><h2 id="Docker-Bridge0"><a href="#Docker-Bridge0" class="headerlink" title="Docker Bridge0"></a>Docker Bridge0</h2><p>Container Test1容器通过自己端口与宿主机的docker0的veth端口相连，Container Test2容器通过自己的端口与宿主机另外一个veth端口相连，这样就保证了2个容器可以互相通信<br><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a5.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看docker的network</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="comment">#查看bridge中有哪些容器</span></span><br><span class="line">docker network inspect &lt;network ID&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a6.png"></p><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p>与其他容器通信时，通过ip来访问的。创建容器时使用–link <name>来实现容器连接，这样通过name也可以访问了,但是link这种方式是单向的<br>除非2个容器都是连接在用户自己创建的network上，可以使用name来访问</name></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name test2 --link test1 container1</span><br><span class="line">docker <span class="built_in">exec</span> -it test2 bash</span><br><span class="line">ping test1 </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建network</span></span><br><span class="line">docker network create net3</span><br><span class="line"><span class="comment">#删除network</span></span><br><span class="line">docker network rm net3</span><br><span class="line"><span class="comment">#新建容器，使用net3，使用--network</span></span><br><span class="line">docker run -d --name test2 --network net3 container1</span><br><span class="line"><span class="comment">#将已经存在的容器连接到net3上</span></span><br><span class="line">docker network connect net3 container1</span><br></pre></td></tr></table></figure><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>我们pull了一个nginx镜像，创建nginx容器，但是我们在外面无法访问nginx容器的80端口，这时就要将nginx服务暴露给外面，可以将nginx的80端口映射到本地</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p表示端口映射</span></span><br><span class="line">docker run --name nginx -d -p 80:80</span><br></pre></td></tr></table></figure><h2 id="none和host-network"><a href="#none和host-network" class="headerlink" title="none和host network"></a>none和host network</h2><p>当容器连接到none时，不存在ip和mac地址，none是与外界隔绝的network<br>当容器连接到host时，他没有独立的network，他与宿主机的network共享一套network（如果创建2个nginx都绑定在80端口，容易端口冲突）</p><h2 id="多机通信"><a href="#多机通信" class="headerlink" title="多机通信"></a>多机通信</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/09/01/Docker%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/a7.png"><br>docker提供了overlay来实现2台linux主机之间的通信<br>2台linux主机通信，必须保证2个主机上的docker容器的ip不一样，我们使用etcd来实现</p><h3 id="下载etcd"><a href="#下载etcd" class="headerlink" title="下载etcd"></a>下载etcd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget https://github.com/coreos/etcd/releases/download/v3.0.12/etcd-v3.0.12-linux-amd64.tar.gz</span><br><span class="line"><span class="comment">#解压缩</span></span><br><span class="line">tar zxvf etcd-v3.0.12-linux-amd64.tar.gz</span><br><span class="line"><span class="comment">#进入etcd-v3.0.12-linux-amd64目录下</span></span><br><span class="line"><span class="built_in">cd</span> etcd-v3.0.12-linux-amd64</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动第一台node1主机etcd服务</span></span><br><span class="line">nohup ./etcd --name docker-node1 --initial-advertise-peer-urls http://192.168.186.129:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.186.129:2380 \</span><br><span class="line">--listen-client-urls http://192.168.186.129:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.186.129:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster \</span><br><span class="line">--initial-cluster docker-node1=http://192.168.186.129:2380,docker-node2=http://192.168.186.130:2380 \</span><br><span class="line">--initial-cluster-state new&amp;</span><br><span class="line"><span class="comment">#启动另一台node2主机etcd服务</span></span><br><span class="line">nohup ./etcd --name docker-node2 --initial-advertise-peer-urls http://192.168.186.130:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.186.130:2380 \</span><br><span class="line">--listen-client-urls http://192.168.186.130:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.186.130:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster \</span><br><span class="line">--initial-cluster docker-node1=http://192.168.186.129:2380,docker-node2=http://192.168.186.130:2380 \</span><br><span class="line">--initial-cluster-state new&amp;</span><br></pre></td></tr></table></figure><h3 id="查看cluster是否建立"><a href="#查看cluster是否建立" class="headerlink" title="查看cluster是否建立"></a>查看cluster是否建立</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./etcdctl cluster-health</span><br></pre></td></tr></table></figure><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#node1</span></span><br><span class="line">service docker stop</span><br><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.186.129:2379 --cluster-advertise=192.168.186.129:2375&amp;</span><br><span class="line"><span class="comment">#node2</span></span><br><span class="line">service docker stop</span><br><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.186.130:2379 --cluster-advertise=192.168.186.130:2375&amp;</span><br></pre></td></tr></table></figure><h3 id="创建overlay"><a href="#创建overlay" class="headerlink" title="创建overlay"></a>创建overlay</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在node1上创建overlay</span></span><br><span class="line">docker network create -d overlay demo</span><br><span class="line"><span class="comment">#查看node1上的network</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="comment">#再查看node2主机上的network，会发现存在名叫demo的overlay</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在node1主机上创建busybox容器</span></span><br><span class="line">docker run -d --name test1 --net demo busybox sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#在node2上再次创建，会发现报错，提示test1已经存在</span></span><br><span class="line">docker run -d --name test1 --net demo busybox sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#创建test2</span></span><br><span class="line">docker run -d --name test2 --net demo busybox sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><h3 id="查看2个容器的ip，是不一致的"><a href="#查看2个容器的ip，是不一致的" class="headerlink" title="查看2个容器的ip，是不一致的"></a>查看2个容器的ip，是不一致的</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test1 ip a</span><br><span class="line">docker <span class="built_in">exec</span> -it test2 ip a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的镜像与容器（一）</title>
      <link href="2019/08/31/Docker%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/08/31/Docker%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文主要涉及Docker镜像、容器相关知识</p><a id="more"></a><h2 id="Docker架构和底层技术"><a href="#Docker架构和底层技术" class="headerlink" title="Docker架构和底层技术"></a>Docker架构和底层技术</h2><p>Docker提供了一个开发、打包、运行应用的平台<br>Docker Engine将应用和infrastructure分离开<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/31/Docker%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/a1.png"></p><h3 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h3><p>Docker Engine由后台进程（dockerd）、REST API Server、CLI接口（docker）组成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看Client、Server、Engine版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment">#查看docker进程</span></span><br><span class="line">ps -ef | grep docker</span><br></pre></td></tr></table></figure><h3 id="底层技术支持"><a href="#底层技术支持" class="headerlink" title="底层技术支持"></a>底层技术支持</h3><p>（1）Namespaces：做隔离pid，net，ipc，mnt，uts<br>（2）Control groups：做资源限制<br>（3）Union file systems：Container和image的分层</p><h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><p>Image里面是一层层的文件系统，即UnionFS（联合文件系统）。每一层文件系统我们都叫一层layer，Image本身是read-only的。构建镜像的时候，每个构建操作都是对一层修改，增加一层文件系统，当你使用Image的时候，你看到的是一个整体，不知道Image到底含有多少文件系统。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看image</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#删除镜像</span></span><br><span class="line">docker rmi 镜像名称</span><br><span class="line"><span class="comment">#使用Dockerfile创建镜像,其中“.”表示指向当前目录下的dockerdile，也可以使用“-f 文件目录” </span></span><br><span class="line">docker build -t 镜像名称 .</span><br></pre></td></tr></table></figure><h3 id="获取Image方式"><a href="#获取Image方式" class="headerlink" title="获取Image方式"></a>获取Image方式</h3><p>（1）Dockerfile<br>（2）Pull from Registry</p><h2 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h2><h3 id="Container概念"><a href="#Container概念" class="headerlink" title="Container概念"></a>Container概念</h3><p>（1）通过Image创建的<br>（2）在Image layer之上建立一个可读写的Container<br>（3）Image和Container的关系好比类和实例的关系<br>（4）Image负责application的存储和分发，Container负责运行application</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行容器</span></span><br><span class="line">docker run 镜像名称</span><br><span class="line"><span class="comment">#交互式运行容器</span></span><br><span class="line">docker run -it 镜像名称</span><br><span class="line"><span class="comment">#查看正在运行容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#查看已经停止的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">#删除容器</span></span><br><span class="line">docker rm 容器名称</span><br><span class="line"><span class="comment">#批量删除停止的容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line"><span class="comment">#批量删除status是exited的容器</span></span><br><span class="line">docker rm $(docker ps -f <span class="string">&quot;status=exited&quot;</span> -q)</span><br><span class="line"><span class="comment">#运行停止的容器/停止运行的容器</span></span><br><span class="line">docker start 容器名称  /   docker stop 容器名称</span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器ID bash</span><br><span class="line"><span class="comment">#从容器中创建新的镜像</span></span><br><span class="line">docker commit 容器名称 镜像名称</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>尽量使用官方的base image</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#制作base image</span></span><br><span class="line">FROM scratch</span><br><span class="line"><span class="comment">#使用base image</span></span><br><span class="line">FROM centos</span><br><span class="line">FROM ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>定义一个image的Metadata,帮助信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LABEL maintainer=“1335402049@qq.com”</span><br><span class="line">LABEL version=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">LABEL description=<span class="string">&quot;This is a dscription&quot;</span></span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>为了美观、负杂的RUN，使用反斜线换行；避免无用分层，合成多条命令成一行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN yum update &amp;&amp; yum install -y vim \</span><br><span class="line">    python-dev</span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>使用WORKDIR，不要使用RUN cd，尽量使用绝对目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WORKDIR /<span class="built_in">test</span>  <span class="comment">#如果没有会自动创建test目录</span></span><br><span class="line">WORKDIR demo</span><br><span class="line">RUN <span class="built_in">pwd</span>        <span class="comment">#输出结果：/test/demo</span></span><br></pre></td></tr></table></figure><h3 id="ADD和COPY"><a href="#ADD和COPY" class="headerlink" title="ADD和COPY"></a>ADD和COPY</h3><p>大部分情况，COPY优先于ADD；ADD除了COPY以外还有解压功能；添加远程文件/目录使用curl或者wget</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ADD hello /</span><br><span class="line">ADD test.tar.gz / <span class="comment">#添加到根目录并解压</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WORKDIR /root</span><br><span class="line">ADD hello <span class="built_in">test</span>/   <span class="comment"># /root/test/hello</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WORKDIR /root</span><br><span class="line">COPY hello <span class="built_in">test</span>/ </span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>尽量使用ENV</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENV MYSQL_VERSION 5.6  <span class="comment">#设置常量</span></span><br><span class="line">RUN apt-get install -y mysql-server=<span class="string">&quot;<span class="variable">$&#123;MYSQL_VERSION&#125;</span>&quot;</span> \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/list/*   <span class="comment">#引用常量</span></span><br></pre></td></tr></table></figure><h3 id="RUN-CMD-ENTRYPOINT"><a href="#RUN-CMD-ENTRYPOINT" class="headerlink" title="RUN CMD ENTRYPOINT"></a>RUN CMD ENTRYPOINT</h3><p>RUN:执行命令并创建新的Image Layer<br>CMD：设置容器启动后默认执行的命令和参数<br>ENTRYPOINT：设置容器启动时运行的命令</p><p>CMD与ENTRYPOINT区别？<br>（1）CMD<br>容器启动时默认执行的命令;<br>如果docker run指定了其他命令，CMD命令会被忽略；<br>如果定义了多个CMD，只有最后一个会执行<br>（2）ENTRYPOINT<br>让容器以应用程序或者服务的形式运行；<br>不会被忽略，一定会执行</p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#内存限制</span></span><br><span class="line">docker run --memory=200M 镜像名称</span><br><span class="line"><span class="comment">#cpu限制（相对）</span></span><br><span class="line">docker run --cpu-shares=10 镜像名称</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keepalived+Nginx双机热备</title>
      <link href="2019/08/24/Keepalived-Nginx%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/"/>
      <url>2019/08/24/Keepalived-Nginx%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Keepalived实现nginx双机热备，实现高可用</p><a id="more"></a><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker pull nginx</span></span><br></pre></td></tr></table></figure><h2 id="创建nginx配置文件"><a href="#创建nginx配置文件" class="headerlink" title="创建nginx配置文件"></a>创建nginx配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /home/n1/nginx.conf</span></span><br></pre></td></tr></table></figure><h2 id="nginx-conf配置文件"><a href="#nginx-conf配置文件" class="headerlink" title="nginx.conf配置文件"></a>nginx.conf配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"> </span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"> </span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"> </span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    proxy_redirect          off;</span><br><span class="line">    proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    client_max_body_size    10m;</span><br><span class="line">    client_body_buffer_size   128k;</span><br><span class="line">    proxy_connect_timeout   5s;</span><br><span class="line">    proxy_send_timeout      5s;</span><br><span class="line">    proxy_read_timeout      5s;</span><br><span class="line">    proxy_buffer_size        4k;</span><br><span class="line">    proxy_buffers           4 32k;</span><br><span class="line">    proxy_busy_buffers_size  64k;</span><br><span class="line">    proxy_temp_file_write_size 64k;</span><br><span class="line">    </span><br><span class="line">    upstream tomcat &#123;</span><br><span class="line">        server 192.168.186.129:6001;</span><br><span class="line">        server 192.168.186.129:6002;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       6101;</span><br><span class="line">        server_name  192.168.186.129; </span><br><span class="line">        location / &#123;  </span><br><span class="line">            proxy_pass   http://tomcat;</span><br><span class="line">            index  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</span></span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker exec -it n1 bash</span></span><br></pre></td></tr></table></figure><h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get update</span></span><br><span class="line"><span class="comment"># apt-get install keepalived</span></span><br><span class="line"><span class="comment"># apt-get install vim</span></span><br></pre></td></tr></table></figure><h2 id="创建keepalived配置文件"><a href="#创建keepalived配置文件" class="headerlink" title="创建keepalived配置文件"></a>创建keepalived配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure><h2 id="keepalived配置文件"><a href="#keepalived配置文件" class="headerlink" title="keepalived配置文件"></a>keepalived配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  vrrp_instance VI_1&#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface  ens33</span><br><span class="line">    virtual_router_id  51</span><br><span class="line">    priority  100</span><br><span class="line">    advert_int  1</span><br><span class="line">    authentication&#123;</span><br><span class="line">        auth_type  PASS</span><br><span class="line">        auth_pass  123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress&#123;</span><br><span class="line">        192.168.186.151</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">virtual_server 192.168.186.151 6201 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 192.168.186.129 6101 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动keepalived"><a href="#启动keepalived" class="headerlink" title="启动keepalived"></a>启动keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service keepalived start</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Keepalived </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keepalived </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署RedisCluster集群</title>
      <link href="2019/08/24/Docker%E9%83%A8%E7%BD%B2RedisCluster%E9%9B%86%E7%BE%A4/"/>
      <url>2019/08/24/Docker%E9%83%A8%E7%BD%B2RedisCluster%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前言我们已经搭建好了数据库集群，下面我们来部署Redis集群。</p><a id="more"></a><h2 id="安装Redis镜像"><a href="#安装Redis镜像" class="headerlink" title="安装Redis镜像"></a>安装Redis镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker pull yyyyttttwwww/redis</span></span><br></pre></td></tr></table></figure><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker tag yyyyttttwwww/redis redis</span></span><br><span class="line"><span class="comment"># docker rmi yyyyttttwwww/redis</span></span><br></pre></td></tr></table></figure><h2 id="创建Redis集群net2网段"><a href="#创建Redis集群net2网段" class="headerlink" title="创建Redis集群net2网段"></a>创建Redis集群net2网段</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker network create --subnet=172.19.0.0/16 net2</span></span><br></pre></td></tr></table></figure><h2 id="运行Redis容器-并进入容器"><a href="#运行Redis容器-并进入容器" class="headerlink" title="运行Redis容器,并进入容器"></a>运行Redis容器,并进入容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bash</span></span><br><span class="line"><span class="comment"># docker exec -it r1 bash</span></span><br></pre></td></tr></table></figure><h2 id="配置Redis节点"><a href="#配置Redis节点" class="headerlink" title="配置Redis节点"></a>配置Redis节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /usr/redis/redis.conf</span></span><br></pre></td></tr></table></figure><p>修改配置文件中如下信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以后台程序运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#开启集群</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment">#集群配置文件</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"><span class="comment">#设置超时时间</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"><span class="comment">#开启AOF模式，日志功能</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><h2 id="进入目录-开启Redis服务"><a href="#进入目录-开启Redis服务" class="headerlink" title="进入目录,开启Redis服务"></a>进入目录,开启Redis服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /usr/redis/src</span></span><br><span class="line"><span class="comment"># ./redis-server ../redis.conf</span></span><br></pre></td></tr></table></figure><p>这样就创建了一个Redis节点了，依照上面操作创建其他Redis节点</p><h2 id="安装redis-trib-rb"><a href="#安装redis-trib-rb" class="headerlink" title="安装redis-trib.rb"></a>安装redis-trib.rb</h2><p>redis-trib.rb是基于Ruby的Redis集群命令行工具，下载地址<a href="https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.1.tar.gz">https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.1.tar.gz</a><br>docker pull yyyyttttwwww/redis拉取的镜像，在容器的usr/redis/src目录下已经事先下载好了redis-trib.rb</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /usr/redis/cluster</span></span><br><span class="line"><span class="comment"># cp /usr/redis/src/redis-trib.rb /usr/redis/cluster</span></span><br><span class="line"><span class="comment"># apt-get install ruby</span></span><br><span class="line"><span class="comment"># apt-get install rubygems</span></span><br><span class="line"><span class="comment"># gem install redis</span></span><br></pre></td></tr></table></figure><h2 id="创建Redis集群"><a href="#创建Redis集群" class="headerlink" title="创建Redis集群"></a>创建Redis集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/24/Docker%E9%83%A8%E7%BD%B2RedisCluster%E9%9B%86%E7%BE%A4/a1.png"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入r1节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 bash</span><br><span class="line"><span class="comment">#使用redis-cli连接redis客户端</span></span><br><span class="line">/usr/redis/src/redis-cli -c</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line"><span class="built_in">set</span> a 10</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/24/Docker%E9%83%A8%E7%BD%B2RedisCluster%E9%9B%86%E7%BE%A4/a2.png"><br>这个数据最终是存到172.19.0.4这个节点了</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PXC热备份方案</title>
      <link href="2019/08/24/PXC%E7%83%AD%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"/>
      <url>2019/08/24/PXC%E7%83%AD%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对数据库文件备份是工作中必不可少的环节，常见的数据库备份方式主要是冷备份和热备份方案</p><a id="more"></a><h2 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h2><p>冷备份就是关闭数据库时候的备份方式，通常是拷贝数据文件<br>冷备份是最简单的最安全的一种备份方式<br>但是一般运营过程中不能停止数据库服务来进行数据备份</p><h2 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h2><p>热备份是在系统运行的状态下备份数据<br>MySQL常见热备份方式是LVM和XtraBackup两种备份方案<br>LVM:linux的分区备份命令,可以备份任何数据库；但是会对数据库加锁,只能读取;而且命令复杂<br>XtraBackup:不需要锁表就可以实现数据备份,而且免费</p><h2 id="XtraBackup"><a href="#XtraBackup" class="headerlink" title="XtraBackup"></a>XtraBackup</h2><p>XtraBackup是由percona提供的一款基于InnoDB的开源免费数据库热备份软件，它支持在线热备份，占用磁盘空间小，能够非常快速地备份与恢复MySQL数据库<br>1.备份过程中不锁表，快速可靠<br>2.备份过程中不会打断正在执行地事务<br>3.备份数据经过压缩，占用磁盘空间小</p><h2 id="全量备份和增量备份"><a href="#全量备份和增量备份" class="headerlink" title="全量备份和增量备份"></a>全量备份和增量备份</h2><p>1.全量备份：备份全部数据。备份时间长，占用空间大。第一次备份要使用全量备份<br>2.增量备份：只备份变化的那部分数据。备份的时间短，占用空间小。后续建议使用增量备份</p><h2 id="PXC全量备份"><a href="#PXC全量备份" class="headerlink" title="PXC全量备份"></a>PXC全量备份</h2><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker volume create backup</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/24/PXC%E7%83%AD%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/a1.png"></p><h3 id="挑选一个PXC节点node1，将其停止并删除，然后重新创建一个增加backup目录映射node1容器"><a href="#挑选一个PXC节点node1，将其停止并删除，然后重新创建一个增加backup目录映射node1容器" class="headerlink" title="挑选一个PXC节点node1，将其停止并删除，然后重新创建一个增加backup目录映射node1容器"></a>挑选一个PXC节点node1，将其停止并删除，然后重新创建一个增加backup目录映射node1容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker stop node1</span></span><br><span class="line"><span class="comment"># docker rm node1</span></span><br><span class="line"><span class="comment"># docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -v v1:/var/lib/mysql -v backup:/data --privileged -e CLUSTER_JOIN=node2 --name=node1 --net=net1 --ip 172.18.0.2 pxc</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/24/PXC%E7%83%AD%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/a2.png"></p><h3 id="PXC容器中安装XtraBackup，并执行备份"><a href="#PXC容器中安装XtraBackup，并执行备份" class="headerlink" title="PXC容器中安装XtraBackup，并执行备份"></a>PXC容器中安装XtraBackup，并执行备份</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker exec -it node1 bash</span></span><br><span class="line"><span class="comment"># apt-get update</span></span><br><span class="line"><span class="comment"># apt-get install percona-xtrabackup-24</span></span><br><span class="line"><span class="comment"># innobackupex --user=root --password=tang1611 /data/back/full</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/24/PXC%E7%83%AD%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/a3.png"></p><h2 id="PXC全量还原"><a href="#PXC全量还原" class="headerlink" title="PXC全量还原"></a>PXC全量还原</h2><p>数据库可以热备份，但是不能热还原，否则会造成业务数据和还原数据的冲突。<br>对于PXC集群为了避免还原过程中各节点数据同步冲突的问题，我们要先解散原来的集群，删除节点。然后新建节点空白数据库，执行还原，最后再建立起其他集群节点。<br>还原前还要将热备份保存的未提交的事务回滚，还原之后重启MySQL</p><h3 id="停止并删除PXC所有节点"><a href="#停止并删除PXC所有节点" class="headerlink" title="停止并删除PXC所有节点"></a>停止并删除PXC所有节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker stop node1 node2 node3 node4 node5</span></span><br><span class="line"><span class="comment"># docker rm node1 node2 node3 node4 node5</span></span><br><span class="line"><span class="comment"># docker volume rm v1 v2 v3 v4 v5</span></span><br></pre></td></tr></table></figure><h3 id="按之前程序创建v1数据卷和node1容器，进入容器，进行全量还原"><a href="#按之前程序创建v1数据卷和node1容器，进入容器，进行全量还原" class="headerlink" title="按之前程序创建v1数据卷和node1容器，进入容器，进行全量还原"></a>按之前程序创建v1数据卷和node1容器，进入容器，进行全量还原</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker volume create v1</span></span><br><span class="line"><span class="comment"># docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc</span></span><br><span class="line"><span class="comment"># docker exec -it -u root node bash</span></span><br><span class="line"><span class="comment"># rm -rf /var/lib/mysql/*</span></span><br><span class="line"><span class="comment"># innobackupex --user=root --password=tang1611 --apply-back /data/back/full/2019-06-28_03-36-59</span></span><br><span class="line"><span class="comment"># innobackupex --user=root --password=tang1611 --copy-back /data/back/full/2019-06-28_03-36-59</span></span><br><span class="line"><span class="comment"># chown -R mysql:mysql /var/lib/mysql</span></span><br><span class="line"><span class="comment"># docker stop node1</span></span><br><span class="line"><span class="comment"># docker start node1</span></span><br></pre></td></tr></table></figure><p>最后重新创建其他数据卷和其他节点，同步node1节点即可。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PXC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署高可用MySQL负载均衡、双机热备</title>
      <link href="2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/"/>
      <url>2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在之前的文章我们已经搭建好了PXC集群，所有的PXC集群节点都是可读可写的，在程序发送请求给数据库时，我们不能把所有的请求全发送给一个PXC节点，对于这种情况，就形成了一个节点负载特别高、性能差，其他节点就显得很空闲，这种情况是我们不希望的。我们希望所有的PXC节点都参与到请求的处理，所以我们就要用到数据库负载均衡技术。</p><a id="more"></a><p>这里我们使用Haproxy来做负载均衡，Haproxy是作为一个请求的转发器，将各个请求均匀分给不同的节点，这样就保证了单个节点负载低、性能好。</p><p>然而单点的Haproxy又不具备高可用，一旦Haproxy出现故障，整个程序就无法正常工作了，所以我们必须要做多个Haproxy节点，一个节点挂掉，必须要有其他Haproxy来顶替。因此这里我们使用Keepalived来实现双机热备。</p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker pull haproxy</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a1.png"></p><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a2.png"></p><h2 id="创建Haproxy配置文件"><a href="#创建Haproxy配置文件" class="headerlink" title="创建Haproxy配置文件"></a>创建Haproxy配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch /home/soft/haproxy/haproxy.cfg</span></span><br></pre></td></tr></table></figure><h2 id="Haproxy配置"><a href="#Haproxy配置" class="headerlink" title="Haproxy配置"></a>Haproxy配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    <span class="comment">#工作目录</span></span><br><span class="line">    chroot /usr/<span class="built_in">local</span>/etc/haproxy</span><br><span class="line">    <span class="comment">#日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span></span><br><span class="line">    <span class="built_in">log</span> 127.0.0.1 local5 info</span><br><span class="line">    <span class="comment">#守护进程运行</span></span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    <span class="built_in">log</span>    global</span><br><span class="line">    mode    http</span><br><span class="line">    <span class="comment">#日志格式</span></span><br><span class="line">    option    httplog</span><br><span class="line">    <span class="comment">#日志中不记录负载均衡的心跳检测记录</span></span><br><span class="line">    option    dontlognull</span><br><span class="line">    <span class="comment">#连接超时（毫秒）</span></span><br><span class="line">    timeout connect 5000</span><br><span class="line">    <span class="comment">#客户端超时（毫秒）</span></span><br><span class="line">    timeout client  50000</span><br><span class="line">    <span class="comment">#服务器超时（毫秒）</span></span><br><span class="line">    timeout server  50000</span><br><span class="line"></span><br><span class="line"><span class="comment">#监控界面</span></span><br><span class="line">listen  admin_stats</span><br><span class="line">    <span class="comment">#监控界面的访问的IP和端口</span></span><br><span class="line">    <span class="built_in">bind</span>  0.0.0.0:8888</span><br><span class="line">    <span class="comment">#访问协议</span></span><br><span class="line">    mode        http</span><br><span class="line">    <span class="comment">#URI相对地址</span></span><br><span class="line">    stats uri   /dbs</span><br><span class="line">    <span class="comment">#统计报告格式</span></span><br><span class="line">    stats realm     Global\ statistics</span><br><span class="line">    <span class="comment">#登陆帐户信息</span></span><br><span class="line">    stats auth  admin:tang1611</span><br><span class="line"><span class="comment">#数据库负载均衡</span></span><br><span class="line">listen  proxy-mysql</span><br><span class="line">    <span class="comment">#访问的IP和端口</span></span><br><span class="line">    <span class="built_in">bind</span>  0.0.0.0:3306</span><br><span class="line">    <span class="comment">#网络协议</span></span><br><span class="line">    mode  tcp</span><br><span class="line">    <span class="comment">#负载均衡算法（轮询算法）</span></span><br><span class="line">    <span class="comment">#轮询算法：roundrobin</span></span><br><span class="line">    <span class="comment">#权重算法：static-rr</span></span><br><span class="line">    <span class="comment">#最少连接算法：leastconn</span></span><br><span class="line">    <span class="comment">#请求源IP算法：source</span></span><br><span class="line">    balance  roundrobin</span><br><span class="line">    <span class="comment">#日志格式</span></span><br><span class="line">    option  tcplog</span><br><span class="line">    <span class="comment">#在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span></span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000</span><br><span class="line">    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000</span><br><span class="line">    server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000</span><br><span class="line">    server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000</span><br><span class="line">    server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000</span><br><span class="line">    <span class="comment">#使用keepalive检测死链</span></span><br><span class="line">    option  tcpka</span><br></pre></td></tr></table></figure><h2 id="创建Haproxy容器"><a href="#创建Haproxy容器" class="headerlink" title="创建Haproxy容器"></a>创建Haproxy容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 haproxy</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a3.png"></p><h2 id="进入后台运行的Haproxy容器"><a href="#进入后台运行的Haproxy容器" class="headerlink" title="进入后台运行的Haproxy容器"></a>进入后台运行的Haproxy容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker exec -it h1 bash</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a4.png"></p><h2 id="指明配置文件路径"><a href="#指明配置文件路径" class="headerlink" title="指明配置文件路径"></a>指明配置文件路径</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># haproxy -f /usr/local/etc/haproxy/haproxy.cfg</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a5.png"></p><h2 id="创建haproxy数据库账号"><a href="#创建haproxy数据库账号" class="headerlink" title="创建haproxy数据库账号"></a>创建haproxy数据库账号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CREATE USER &#x27;haproxy&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&#x27;;</span></span><br></pre></td></tr></table></figure><h2 id="进入haproxy监控页面"><a href="#进入haproxy监控页面" class="headerlink" title="进入haproxy监控页面"></a>进入haproxy监控页面</h2><p>浏览器访问 服务器ip:4001/dbs<br>其中4001是我们启动容器映射的宿主机的端口,dbs是配置文件里面配置的URL相对地址<br>例如我的访问地址是<a href="http://192.168.186.129:4001/dbs">http://192.168.186.129:4001/dbs</a><br>进入后输入用户名和密码，也是在配置文件内配置的，我这里用户名是admin，密码也是tang1611<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a6.png"></p><h2 id="验证haproxy是否转发请求"><a href="#验证haproxy是否转发请求" class="headerlink" title="验证haproxy是否转发请求"></a>验证haproxy是否转发请求</h2><p>（1）创建连接<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a7.png"><br>（2）更新数据<br>在刚刚创建的连接的表中增加一行数据，haproxy不处理任何数据，它会将这个请求发送给其他1个PXC节点，而PXC具备强一致性，就会将数据同步到其他节点<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a8.png"></p><h2 id="进入haproxy容器，更新apt-get"><a href="#进入haproxy容器，更新apt-get" class="headerlink" title="进入haproxy容器，更新apt-get"></a>进入haproxy容器，更新apt-get</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a9.png"></p><h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get install keepalived</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a10.png"></p><h2 id="安装vim编译器"><a href="#安装vim编译器" class="headerlink" title="安装vim编译器"></a>安装vim编译器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get install vim</span></span><br></pre></td></tr></table></figure><h2 id="创建keepalived配置文件"><a href="#创建keepalived配置文件" class="headerlink" title="创建keepalived配置文件"></a>创建keepalived配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure><h2 id="keepalived配置文件"><a href="#keepalived配置文件" class="headerlink" title="keepalived配置文件"></a>keepalived配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> vrrp_instance VI_1&#123;</span><br><span class="line">   state MASTER</span><br><span class="line">interface  eth0</span><br><span class="line">virtual_router_id  51</span><br><span class="line">priority  100</span><br><span class="line">advert_int  1</span><br><span class="line">authentication&#123;</span><br><span class="line">  auth_type  PASS</span><br><span class="line">  auth_pass  123456</span><br><span class="line">&#125;</span><br><span class="line">virtual_ipaddress&#123;</span><br><span class="line">  172.18.0.201</span><br><span class="line">&#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="启动keepalived"><a href="#启动keepalived" class="headerlink" title="启动keepalived"></a>启动keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service keepalived start</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/19/Docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8MySQL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/a11.png"></p><h2 id="创建第二个Haproxy容器"><a href="#创建第二个Haproxy容器" class="headerlink" title="创建第二个Haproxy容器"></a>创建第二个Haproxy容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 haproxy</span></span><br></pre></td></tr></table></figure><h2 id="进入容器，并指定配置文件"><a href="#进入容器，并指定配置文件" class="headerlink" title="进入容器，并指定配置文件"></a>进入容器，并指定配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker -it h2 bash</span></span><br><span class="line"><span class="comment"># docker -f /usr/local/etc/haproxy/haproxy.cfg</span></span><br></pre></td></tr></table></figure><h2 id="更新apt-get"><a href="#更新apt-get" class="headerlink" title="更新apt-get"></a>更新apt-get</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure><h2 id="安装keepalived-1"><a href="#安装keepalived-1" class="headerlink" title="安装keepalived"></a>安装keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get install keepalived</span></span><br></pre></td></tr></table></figure><h2 id="安装vim编译器-1"><a href="#安装vim编译器-1" class="headerlink" title="安装vim编译器"></a>安装vim编译器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get install vim</span></span><br></pre></td></tr></table></figure><h2 id="创建keepalived配置文件-1"><a href="#创建keepalived配置文件-1" class="headerlink" title="创建keepalived配置文件"></a>创建keepalived配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure><h2 id="keepalived配置文件-1"><a href="#keepalived配置文件-1" class="headerlink" title="keepalived配置文件"></a>keepalived配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> vrrp_instance VI_1&#123;</span><br><span class="line">   state MASTER</span><br><span class="line">interface  eth0</span><br><span class="line">virtual_router_id  51</span><br><span class="line">priority  100</span><br><span class="line">advert_int  1</span><br><span class="line">authentication&#123;</span><br><span class="line">  auth_type  PASS</span><br><span class="line">  auth_pass  123456</span><br><span class="line">&#125;</span><br><span class="line">virtual_ipaddress&#123;</span><br><span class="line">  172.18.0.201</span><br><span class="line">&#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="启动keepalived-1"><a href="#启动keepalived-1" class="headerlink" title="启动keepalived"></a>启动keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service keepalived start</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建MySQL高可用方案PXC集群</title>
      <link href="2019/08/18/Docker%E6%90%AD%E5%BB%BAMySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88PXC%E9%9B%86%E7%BE%A4/"/>
      <url>2019/08/18/Docker%E6%90%AD%E5%BB%BAMySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88PXC%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PXC全称Percona XtraDB Cluster，它提供了MySQL高可用的一种实现方案。PXC集群是以节点组成，推荐奇数个节点（至少3个以上），集群中的每个节点都包含完整的数据，并且所有节点都是可读可写的。PXC集群方案能够保证数据的强一致性，当程序向PXC的一个节点提交数据时，该节点先同步其他的节点，如果其他节点同步失败，那么这个提交数据的行为就算失败，只有所有节点都同步成功才返回程序提交数据成功。</p><a id="more"></a><h2 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker pull percona/percona-xtradb-cluster:5.7.20</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像文件"><a href="#查看镜像文件" class="headerlink" title="查看镜像文件"></a>查看镜像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><h2 id="修改镜像文件名称"><a href="#修改镜像文件名称" class="headerlink" title="修改镜像文件名称"></a>修改镜像文件名称</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker tag percona/percona-xtradb-cluster:5.7.20 pxc</span></span><br></pre></td></tr></table></figure><h2 id="删除原来镜像文件"><a href="#删除原来镜像文件" class="headerlink" title="删除原来镜像文件"></a>删除原来镜像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker rmi percona/percona-xtradb-cluster:5.7.20</span></span><br></pre></td></tr></table></figure><h2 id="创建pxc集群内部网络"><a href="#创建pxc集群内部网络" class="headerlink" title="创建pxc集群内部网络"></a>创建pxc集群内部网络</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker network create --subnet=172.18.0.0/24 net1</span></span><br></pre></td></tr></table></figure><h2 id="查看内部网络信息"><a href="#查看内部网络信息" class="headerlink" title="查看内部网络信息"></a>查看内部网络信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker inspect net1</span></span><br></pre></td></tr></table></figure><h2 id="创建docker卷"><a href="#创建docker卷" class="headerlink" title="创建docker卷"></a>创建docker卷</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker volume create v1</span></span><br><span class="line"><span class="comment"># docker volume create v2</span></span><br><span class="line"><span class="comment"># docker volume create v3</span></span><br><span class="line"><span class="comment"># docker volume create v4</span></span><br><span class="line"><span class="comment"># docker volume create v5</span></span><br></pre></td></tr></table></figure><h2 id="查看docker卷信息"><a href="#查看docker卷信息" class="headerlink" title="查看docker卷信息"></a>查看docker卷信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker inspect v1</span></span><br><span class="line"><span class="comment"># docker inspect v2</span></span><br><span class="line"><span class="comment"># docker inspect v3</span></span><br><span class="line"><span class="comment"># docker inspect v4</span></span><br><span class="line"><span class="comment"># docker inspect v5</span></span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -v v1:/var/lib/mysql --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc</span></span><br><span class="line"><span class="comment"># docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc</span></span><br><span class="line"><span class="comment"># docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc</span></span><br><span class="line"><span class="comment"># docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc</span></span><br><span class="line"><span class="comment"># docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=tang1611 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=tang1611 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</span></span><br></pre></td></tr></table></figure><h2 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker ps</span></span><br></pre></td></tr></table></figure><h2 id="使用本地navicate连接PXC集群节点"><a href="#使用本地navicate连接PXC集群节点" class="headerlink" title="使用本地navicate连接PXC集群节点"></a>使用本地navicate连接PXC集群节点</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/18/Docker%E6%90%AD%E5%BB%BAMySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88PXC%E9%9B%86%E7%BE%A4/a1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github-Pages和Hexo搭建自己的博客</title>
      <link href="2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是一篇使用Github Pages和Hexo搭建博客的详细教程。这是我搭建好自己博客的的第一篇文章，搭建的时候也是通过百度，经过千辛万苦完成的，希望通过我的教程，使更多的同学能够搭建自己的博客。</p><a id="more"></a><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>（1）Node.js下载地址：<a href="https://nodejs.org/en/%E3%80%82">https://nodejs.org/en/。</a><br>（2）检验Node.js是否安装成功<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a1.png"></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>（1）Git下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a><br>（2）检验Git是否安装成功，鼠标右键菜单会出现Git GUI Here和Git Bash Here<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a2.png"></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>首先选择一个磁盘，新建一个文件夹（我这里新建了一个weifeng_blog文件夹），用来存储博客相关的文件。进入刚创建的文件夹，鼠标右击，点击Git Bash Here。<br>（1）安装hexo-cli<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a3.png"><br>（2）安装hexo部署到git page和deployer<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a4.png"></p><h2 id="Hexo初始化配置"><a href="#Hexo初始化配置" class="headerlink" title="Hexo初始化配置"></a>Hexo初始化配置</h2><p>在刚刚创建的文件夹下，再新建一个hexo的文件夹。进入hexo文件夹，鼠标右击，点击Git Bash Here。初始化的过程会比较慢，耐心等待。成功后会发现hexo目录下出现很多文件。<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a5.png"></p><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><p>执行hexo g和hexo s,当你执行hexo g时，一直报错cannot find module。<br>例如：<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a6.png"><br>解决方案：npm install –save htmlparser2，这边的htmlparser2就是图片上说的缺失的module。再次执行hexo -g 和 hexo -s指令<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a7.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a8.png"><br>最后访问<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a9.png"></p><h2 id="登录Github账户"><a href="#登录Github账户" class="headerlink" title="登录Github账户"></a>登录Github账户</h2><p>Github官网：<a href="https://github.com/">https://github.com/</a></p><h2 id="创建项目代码库"><a href="#创建项目代码库" class="headerlink" title="创建项目代码库"></a>创建项目代码库</h2><p>点击头像，create a new repository。Repository name必须要以你的用户名.github.io命名，勾选Initialize this repository with a README，最后Create repository。<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a10.png"></p><h2 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>在第一次创建的文件夹下（如我的文件夹weifeng_blog）,Git Bash Here。<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a11.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a12.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a13.png"><br>进入github个人主页，点击右上角，Settings。<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a14.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a15.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a16.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a17.png"></p><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>把名称和邮箱替换成你自己的，名字可以不是GitHub的昵称，但为了方便记忆，建议与GitHub一致。<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a18.png"></p><h2 id="将本地hexo文件更新到Github库中"><a href="#将本地hexo文件更新到Github库中" class="headerlink" title="将本地hexo文件更新到Github库中"></a>将本地hexo文件更新到Github库中</h2><p><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a19.png"><br>打开创建的hexo文件夹，编辑_config.yml文件<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a20.png"><br>在hexo文件夹下，Git Bash Here。执行hexo g -d。若出现下面问题，则说明deployer没有安装成功。执行npm install hexo-deployer-git –save，然后再次执行hexo g -d<br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a21.png"><br><img src= "/img/loading.gif" data-lazy-src="/2019/08/17/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/a22.png"><br>最后就可以通过https://你的用户名.github.io来访问你的博客了。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
